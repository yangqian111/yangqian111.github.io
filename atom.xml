<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ppsheep</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ppsheep.com/"/>
  <updated>2017-03-10T09:56:26.000Z</updated>
  <id>http://ppsheep.com/</id>
  
  <author>
    <name>ppsheep</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解OC内部的消息调用、消息转发、类和对象(一)</title>
    <link href="http://ppsheep.com/2017/03/09/%E7%90%86%E8%A7%A3OC%E5%86%85%E9%83%A8%E7%9A%84%E6%B6%88%E6%81%AF%E8%B0%83%E7%94%A8%E3%80%81%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://ppsheep.com/2017/03/09/理解OC内部的消息调用、消息转发、类和对象/</id>
    <published>2017-03-09T02:28:35.000Z</published>
    <updated>2017-03-10T09:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前看过Effective Objective-C 2.0 这本书的同学可能会注意到，我之前写的关于这本书的笔记，跳过了其中的几个章节，那时候没有记下来，是觉得我自己还没有理解到位，还不能贸然瞎说，最近仔细研究了一下，还看了Runtime和Runloop，渐渐的开始理解这些东西了，现在慢慢开始记录一下，大家一起学习。</p>
<a id="more"></a>
<h3 id="对象的方法调用objc-msgSend"><a href="#对象的方法调用objc-msgSend" class="headerlink" title="对象的方法调用objc_msgSend"></a>对象的方法调用objc_msgSend</h3><p>之前已经讲过了消息派发，我决定呢将这个放在这篇文章里来，这样一起看整个一个OC的运行期进行的一些操作，理解起来也会有益处的。</p>
<p>在对象实例上调用方法是Objective-C常用的功能。用Objc的术语来讲，叫做“传递消息”。消息有“名称(name)”或“选择子(selector)”，可以接受参数，可以有返回值。</p>
<p>由于OC是C的超集，所以最好先理解C语言的函数调用方式。C语言使用“静态绑定”，也就是说，在编译期间，就能够知道所应该调用的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void printHello()&#123;</div><div class="line">    printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printGoodBye()&#123;</div><div class="line">    printf(&quot;Goodbye world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doTheThing(int type)&#123;</div><div class="line">    if (type == 0) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125;else&#123;</div><div class="line">        printGoodBye();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不考虑内联关系，那么编译器在编译代码的时候就已经知道了程序中有printHello和printGoodBye这两个函数了，如果我们将编写的方式改变一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void printHello()&#123;</div><div class="line">    printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printGoodBye()&#123;</div><div class="line">    printf(&quot;Goodbye world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doTheThing(int type)&#123;</div><div class="line">    void (*fnc)();</div><div class="line">    if (type == 0) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125;else&#123;</div><div class="line">        fnc = printGoodBye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下，就必须要使用动态绑定了，因为需要调用的函数，在运行期间才能够知道。在objc中，要向对象传递消息，就必须要使用到动态绑定的机制来决定需要调用的方法。</p>
<p>给对象传递消息，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p>在上面代码中，someObject叫做接收者，messageName叫做选择子，选择子和参数合起来叫做消息。编译器在看到该消息后，将其转化成为一条标准的C语言函数调用，所调用的函数叫做objc_msgSend，其原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self,SEL cmd,...)</div></pre></td></tr></table></figure>
<p>这是一个参数可变的函数，其中第一个参数代表的是接收者，第二个代表的是选择子，第三个以及后面的代表的是参数，编译器会把上面的传递消息的例子改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id returnValue = objc_msgSend(someObject,@selector(messageName:),</div><div class="line">									parameter);</div></pre></td></tr></table></figure>
<p>objc_msgSend函数会根据接收者和选择子来选择调用的方法，改函数会在接收者的类中寻找方法列表，如果能找到与选择子名称相符的方法，就跳至其，实现代码，如果找不到，那就继续沿着继承体系往上找，如果最终还是找不到方法，那么就会执行”消息转发“操作</p>
<p>这样看来，好像我们调用一个方法需要很多步骤，所幸的是，objc_msgSend会将匹配结果缓存子啊一张快速映射表中，我们在之后会讲到这个缓存。这样一来，每个类都会有一个缓存，这样虽然第一次执行起来会稍慢，但是后面就会很迅速了。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>要讲消息转发机制，首先我们需要先了了解一下OC中的类和对象，OC的runtime是开源的，我们可以先从这里下载到源码，对着源码来看</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">https://opensource.apple.com/tarballs/objc4/</a></p>
<p>首先，我们来看一下类和对象的定义，在objc.h文件和runtime.h文件中分别定义了对象和类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"></div><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/// A pointer to an instance of a class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</div></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以看出，在OC中id代表的是一个OC对象，Class代表的是OC中的一个类。在对象定义中，首地址是一个*isa的struct的指针。这个指针指向对象所代表的类(Class)。</p>
<p>我们再来看看类的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></div></pre></td></tr></table></figure>
<p>我们先抛开其他的不看，一眼就看到了类的首地址也是一个*isa的指针，这个就说明，其实类他也是一个对象，也是指向了一个类，这样一想，其实也是合理的，在OC中，一切皆是对象，类当然也除外，那这个类对象是属于什么类的呢？</p>
<p>其实在OC中，还有一个meta-class的概念，一般把它叫做元类，我们上面说到的类，其实就是元类的一个实例，这里有点拗口，但是这个感念一定要清楚，那之前说的OC一切皆是对象，那元类也应该是一个实例，他也应该指向一个类，说的没错，我们来看一下OC中的类的继承图就清楚了</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-03-10-080312.jpg" alt=""></p>
<p>上面是我画的一个继承图，在图中，我们能够看出，所有的类都是继承自NSObject，NSObject的父类为nil，所有的类都是元类的实例，然后根元类，即是NSObject的元类，他的父类是NSObject，然后他自己是自己的实例，这样一来就形成了一个循环，正好OC  一切皆是对象。</p>
<p>当然，在我们平时开发中，基本不会接触到元类。但是我们也需要了解其中的具体原理。</p>
<p>我们再看看上面的类定义，其中还有其他的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line"><span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>这其中包含了这个类的所有信息，其中我们常用到的就是属性列表，方法列表，还有实现的协议列表，其中有个cache，这个其实就是我们上面说到的快速缓存表，关于其中的属性列表和方法列表之类的，我在之前的一篇文章中提到过这些的应用，请移步<br> <a href="http://ppsheep.com/2016/07/25/Runtime详解/">http://ppsheep.com/2016/07/25/Runtime详解/</a></p>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><p>好，现在我们开始来讲一下消息转发，首先我们来看实例的消息转发，这里说的消息转发，其实是方法的调用，我们上面已经讲过了。<br>先来看例子</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先我在VC里执行一个不存在的方法</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(logInstanceMethod)];</div></pre></td></tr></table></figure>
<p>这里需要说明一下，因为现在项目基本都会使用ARC，如果使用了ARC，那么如果我们直接像平时调用方法那样调用一个不存在的方法，编译器会报错，因为ARC其实是在我们编译阶段，插入了内存管理的代码，在运行期间，是没有ARC的，这个和Java就不一样了。没有方法，当然没办法进行引用计数，所以，编译会报错，但是使用performSelector，这个方法，我的理解是在运行期间，才会知道是否有这样一个方法，这个方法定义出来，就是为了runtime实现的。如果有同学详细了解过，麻烦告知一下。</p>
<p>然后我们在VC里面实现几个方法，这几个方法都在NSObject头文件中有声明</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation"</span>);</div><div class="line"><span class="comment">//    [super forwardInvocation:anInvocation];</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod"</span>);</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"methodSignatureForSelector"</span>);</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector]) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先不做解释，我们运行一下，看看效果怎么样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">32.265</span> 动态添加实例方法和类方法[<span class="number">29490</span>:<span class="number">5570176</span>] resolveInstanceMethod</div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">32.267</span> 动态添加实例方法和类方法[<span class="number">29490</span>:<span class="number">5570176</span>] forwardingTargetForSelector</div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">32.267</span> 动态添加实例方法和类方法[<span class="number">29490</span>:<span class="number">5570176</span>] methodSignatureForSelector</div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">32.268</span> 动态添加实例方法和类方法[<span class="number">29490</span>:<span class="number">5570176</span>] forwardInvocation</div></pre></td></tr></table></figure>
<p>程序并没有崩溃，而是有先后顺序调用了这几个方法，这里需要说明，如果使用storyBoard的同学，resolveInstanceMethod会调用两次，因为这个初始化是，会调用一个方法叫做 setStoryBoard，这个方法，需要在父类中才会处理，在当前是找不到的，所以会直接来调用。</p>
<p>好，来分析一下：</p>
<p>消息转发大致分为两个阶段：</p>
<ul>
<li>阶段一  动态方法解析：首先会先问当前类能否动态增加方法，来处理这个不能被处理的消息，这时候就会调用到方法resolveInstanceMethod:，在这个方法中，我们可以进行动态增加方法，来处理这个实例不能处理的方法，如果当前类不能够动态增加方法，那么直接返回NO，这时候就进入第二个阶段，完整的消息转发</li>
<li>阶段二 完整消息转发：完整消息转发也分为几步   首先，类已经不能动态增加方法了，那么就需要找其他能够处理的类来处理这个方法，如果有其他对象能够处理这个消息，那么直接将这个消息发送给他，进行消息处理。如果没有找到能够处理的对象，那么进行第二步，到方法签名，然后将消息的所有细节全部封装到NSInvocation对象，进行最后的处理，如果还未能处理，那么将会调用到NSObject的doesNotRecgnized什么方法，不知道拼的对不对，意思就是没找到这个方法，然后崩溃。</li>
</ul>
<p>大致的一个流程就是这样，也对应到我们的方法调用，这里为什么我们的没有崩溃呢，因为在forwardInvocation上，我没有调用super，这样就不会到NSObject的方法了</p>
<p>上面就是一个消息转发的全过程，接下来我们来讲动态增加实例方法。</p>
<h3 id="动态增加实例方法"><a href="#动态增加实例方法" class="headerlink" title="动态增加实例方法"></a>动态增加实例方法</h3><p>上面，我们讲了，动态增加实例方法，都是在resolveInstanceMethod方法中，那么我们来增加试试看</p>
<p>首先，我先自定义一个实例方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)myInstanceMethod&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我的实例方法"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我在动态解析方法时，将执行的logInstanceMethod，换成我的这个方法myInstanceMethod</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 处理实例方法</div><div class="line"></div><div class="line"> @param sel 需要动态添加的方法</div><div class="line"> @return 是否已经有可实现的方法</div><div class="line"> */</div><div class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod"</span>);</div><div class="line">    IMP imp = [<span class="keyword">self</span> instanceMethodForSelector:<span class="keyword">@selector</span>(myInstanceMethod)];</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(logInstanceMethod)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, imp, <span class="string">"v@:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)myInstanceMethod&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我的实例方法"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中class_addMethod有四个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">OBJC_EXPORT BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, </span></span></div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">char</span> *types) </div><div class="line">    <span class="title">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>)</span>;</div></pre></td></tr></table></figure>
<p>分别代表的含义是  需要给哪个类增加方法，增加的方法的名称，具体实现的方法地址，方法的返回值和参数</p>
<p>这里解释一下，关于方法的返回值和参数，是通过字符串来表示的，具体的，可以看一下这里 </p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100</a></p>
<p>这样，我们就给我们当前的类增加了一个名为logInstanceMethod的方法，他的实现，则是在方法myInstanceMethod里</p>
<p>这里需要注意一点，我们传Class的时候，传的是 [self class]，这个返回的是当前实例所属的对象，后面我们再讲动态增加类方法的时候，还需要传一个，那就是meta-class，到时候我在讲，这里只是提一下，注意两者之间的区别</p>
<p>我们再来运行一下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">49.298</span> 动态添加实例方法和类方法[<span class="number">31090</span>:<span class="number">5856225</span>] resolveInstanceMethod</div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-10</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">49.299</span> 动态添加实例方法和类方法[<span class="number">31090</span>:<span class="number">5856225</span>] 我的实例方法</div></pre></td></tr></table></figure>
<p>这里可以看到，到了动态解析，消息转发就已经完成了，并且，我们的方法，动态添加了进去</p>
<p>好今天，先讲到这里，消化一下，说的有点多，后面一篇文章，我将会讲到，将消息转发给其他对象处理，还有动态增加类方法。</p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<p>上边是公众号，下边是我个人微信</p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br>    <image src="http://o8bxt3lx0.bkt.clouddn.com/avatar.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看过Effective Objective-C 2.0 这本书的同学可能会注意到，我之前写的关于这本书的笔记，跳过了其中的几个章节，那时候没有记下来，是觉得我自己还没有理解到位，还不能贸然瞎说，最近仔细研究了一下，还看了Runtime和Runloop，渐渐的开始理解这些东西了，现在慢慢开始记录一下，大家一起学习。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 编写高质量代码的方法" scheme="http://ppsheep.com/all-categories/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="iOS 编写高质量代码" scheme="http://ppsheep.com/all-tags/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>自定义模态loading</title>
    <link href="http://ppsheep.com/2017/02/24/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%80%81loading/"/>
    <id>http://ppsheep.com/2017/02/24/自定义模态loading/</id>
    <published>2017-02-24T06:49:01.000Z</published>
    <updated>2017-02-24T07:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天带来一款自定义的模态loading的实现，通过自定义UI，画出loading的样式，并且有个转动的样式，下面我们就来实现以下。</p>
<a id="more"></a>
<p>首先，我们来看一下效果，可能图片看着有点卡看一下大致的效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-%E6%A8%A1%E6%80%81loading.gif" alt=""></p>
<p>首先来分析以下，做动画都是先分析，再来下手</p>
<ul>
<li>首先底部是一个毛玻璃样式，图片上看不大清楚</li>
<li>然后两个圆，第一个是底部的灰色圆环</li>
<li>第二个圆是一个跑动的圆弧，这个怎么做呢，其实它也是一个圆环，只是起点和终点在不停变换，而这个变换，我们可以通过layer的动画做到</li>
<li>最小面还有一个label</li>
</ul>
<p>好了就这些，没了，看起来还是很简单的</p>
<h3 id="底部毛玻璃样式"><a href="#底部毛玻璃样式" class="headerlink" title="底部毛玻璃样式"></a>底部毛玻璃样式</h3><p>首先我们来讲底部的毛玻璃效果加上，在系统提供的UIKit中，我们就可以简单实现这种小效果，有一个类UIVisualEffectView，可以用来实现很多特殊效果</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">blurView = [[<span class="built_in">UIVisualEffectView</span> alloc] initWithEffect:[<span class="built_in">UIBlurEffect</span> effectWithStyle:<span class="built_in">UIBlurEffectStyleExtraLight</span>]];</div><div class="line">blurView.layer.cornerRadius = <span class="number">10</span>;</div><div class="line">blurView.layer.masksToBounds = <span class="literal">YES</span>;</div><div class="line">blurView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">blurView.center = <span class="built_in">CGPointMake</span>(viewCenterX, viewCenterY);</div></pre></td></tr></table></figure>
<p>这样几句简单的代码，就已经有了毛玻璃效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-071550.jpg" alt=""></p>
<p>应该还是能够看出来的</p>
<h3 id="底部圆环"><a href="#底部圆环" class="headerlink" title="底部圆环"></a>底部圆环</h3><p>接下来我们来画底部的圆环，画圆的方式有很多，这里我就通过CAShapeLayer来画圆</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/// 底部的灰色layer</span></div><div class="line"><span class="built_in">CAShapeLayer</span> *bottomShapeLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">bottomShapeLayer.strokeColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">229</span>/<span class="number">255.0</span> green:<span class="number">229</span>/<span class="number">255.0</span> blue:<span class="number">229</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>].CGColor;</div><div class="line">bottomShapeLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</div><div class="line">bottomShapeLayer.lineWidth = KShapelayerLineWidth;</div><div class="line">bottomShapeLayer.path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(KShapeLayerMargin, <span class="number">0</span>, KShapeLayerWidth, KShapeLayerWidth) cornerRadius:KShapeLayerRadius].CGPath;</div><div class="line">[<span class="keyword">self</span>.layer addSublayer:bottomShapeLayer];</div></pre></td></tr></table></figure>
<p>还是来看效果图</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-071712.jpg" alt=""></p>
<p>灰色的圆，我们已经画出来了，关于画圆的代码，我就不具体解释了，就是一个简单的UIBezierPath应用，不了解的，可以去点进源码看看，就是给定一个曲线，然后画图</p>
<h3 id="运动的圆环"><a href="#运动的圆环" class="headerlink" title="运动的圆环"></a>运动的圆环</h3><p>接下来，接着画中间的红色圆环，这里可能有的同学会走偏，其实这个运动的动画，如果对动画理解不多，很容易想到去画圆弧去了，其实这里它也是一个完整的圆，只是对它的起点和终点做了动画，所以看起来就是运动着的圆弧</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 橘黄色的layer</span></div><div class="line"><span class="keyword">self</span>.ovalShapeLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line"><span class="keyword">self</span>.ovalShapeLayer.strokeColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.984</span> green:<span class="number">0.153</span> blue:<span class="number">0.039</span> alpha:<span class="number">1.000</span>].CGColor;</div><div class="line"><span class="keyword">self</span>.ovalShapeLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</div><div class="line"><span class="keyword">self</span>.ovalShapeLayer.lineWidth = KShapelayerLineWidth;</div><div class="line"><span class="keyword">self</span>.ovalShapeLayer.path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(KShapeLayerMargin, <span class="number">0</span>,KShapeLayerWidth, KShapeLayerWidth) cornerRadius:KShapeLayerRadius].CGPath;</div><div class="line">[<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.ovalShapeLayer];</div></pre></td></tr></table></figure>
<p>来看看效果图</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-072259.jpg" alt=""></p>
<p>现在，中间的红色圆环，已经完全把灰色的圆遮住了，好进入重要的步骤，做动画</p>
<p>我们来细看一下这个动画，在整个圆的前半部分，终点的运动速度很快，起点的速度运动很慢，然后当终点走到了圆的一半，起点着急了，加快了速度，最后在整个圆的位置追上了终点点，这就是整个动画的要点</p>
<p>所以这个动画要分两步，前半部分和后半部分，我们先来做前半部分</p>
<p>要让起点和终点的速度不一样，那就是在相同的时间内，运动的弧度不同了</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 起点动画</span></div><div class="line"><span class="built_in">CABasicAnimation</span> * strokeStartAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeStart"</span>];</div><div class="line">strokeStartAnimation.fromValue = @(<span class="number">0.0</span>);</div><div class="line">strokeStartAnimation.toValue = @(<span class="number">0.25</span>);</div><div class="line">    </div><div class="line"><span class="comment">/// 终点动画</span></div><div class="line"><span class="built_in">CABasicAnimation</span> * strokeEndAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">strokeEndAnimation.fromValue = @(<span class="number">0.0</span>);</div><div class="line">strokeEndAnimation.toValue = @(<span class="number">0.5</span>);</div><div class="line">    </div><div class="line"><span class="comment">/// 组合动画</span></div><div class="line"><span class="built_in">CAAnimationGroup</span> *animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">animationGroup.animations = @[strokeStartAnimation,strokeEndAnimation];</div><div class="line">animationGroup.duration = KAnimationDurationTime;</div><div class="line">animationGroup.repeatCount = <span class="number">1</span>;</div><div class="line">animationGroup.fillMode = kCAFillModeForwards;</div><div class="line">animationGroup.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">[<span class="keyword">self</span>.ovalShapeLayer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>解释一下，在相同时间内，起点走了0.25个弧度，终点走了0.5个弧度，那这个动画组的动画就正好是我们说的前半部分  来看看效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-%E6%A8%A1%E6%80%81loading1.gif" alt=""></p>
<p>正好是我们想要的结果，再来做，下半部分动画，同样的，后面的动画就反过来了</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CABasicAnimation</span> * strokeStartAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeStart"</span>];</div><div class="line">strokeStartAnimation.fromValue = @(<span class="number">0.25</span>);</div><div class="line">strokeStartAnimation.toValue = @(<span class="number">1.0</span>);</div><div class="line">    </div><div class="line"><span class="comment">/// 终点动画</span></div><div class="line"><span class="built_in">CABasicAnimation</span> * strokeEndAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">strokeEndAnimation.fromValue = @(<span class="number">0.5</span>);</div><div class="line">strokeEndAnimation.toValue = @(<span class="number">1.0</span>);</div><div class="line">    </div><div class="line"><span class="comment">/// 组合动画</span></div><div class="line"><span class="built_in">CAAnimationGroup</span> *animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">animationGroup.animations = @[strokeStartAnimation,strokeEndAnimation];</div><div class="line">animationGroup.duration = KAnimationDurationTime;</div><div class="line">animationGroup.repeatCount = <span class="number">1</span>;</div><div class="line">animationGroup.fillMode = kCAFillModeForwards;</div><div class="line">animationGroup.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">[<span class="keyword">self</span>.ovalShapeLayer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>同样的 看看效果图</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-%E6%A8%A1%E6%80%81loading2.gif" alt=""></p>
<p>这个效果也达到了，好了现在，我们要做的，就是将两个动画组合起来，我们在第一组动画结束时，再执行第二组动画，通过GCD来做</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.9</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;&#125;);</div></pre></td></tr></table></figure>
<p>在第一组动画开始执行时，第二组动画延时第一组动画执行的时间，再执行，注意为了两组动画衔接流畅，做了一点时间的调整</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)animations&#123;</div><div class="line">    <span class="comment">/// 起点动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> * strokeStartAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeStart"</span>];</div><div class="line">    strokeStartAnimation.fromValue = @(<span class="number">0.0</span>);</div><div class="line">    strokeStartAnimation.toValue = @(<span class="number">0.25</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/// 终点动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> * strokeEndAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">    strokeEndAnimation.fromValue = @(<span class="number">0.0</span>);</div><div class="line">    strokeEndAnimation.toValue = @(<span class="number">0.5</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/// 组合动画</span></div><div class="line">    <span class="built_in">CAAnimationGroup</span> *animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">    animationGroup.animations = @[strokeStartAnimation,strokeEndAnimation];</div><div class="line">    animationGroup.duration = KAnimationDurationTime;</div><div class="line">    animationGroup.repeatCount = <span class="number">1</span>;</div><div class="line">    animationGroup.fillMode = kCAFillModeForwards;</div><div class="line">    animationGroup.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span>.ovalShapeLayer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.9</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">/// 起点动画</span></div><div class="line">        <span class="built_in">CABasicAnimation</span> * strokeStartAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeStart"</span>];</div><div class="line">        strokeStartAnimation.fromValue = @(<span class="number">0.25</span>);</div><div class="line">        strokeStartAnimation.toValue = @(<span class="number">1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">/// 终点动画</span></div><div class="line">        <span class="built_in">CABasicAnimation</span> * strokeEndAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">        strokeEndAnimation.fromValue = @(<span class="number">0.5</span>);</div><div class="line">        strokeEndAnimation.toValue = @(<span class="number">1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">/// 组合动画</span></div><div class="line">        <span class="built_in">CAAnimationGroup</span> *animationGroup = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">        animationGroup.animations = @[strokeStartAnimation,strokeEndAnimation];</div><div class="line">        animationGroup.duration = KAnimationDurationTime;</div><div class="line">        animationGroup.repeatCount = <span class="number">1</span>;</div><div class="line">        animationGroup.fillMode = kCAFillModeForwards;</div><div class="line">        animationGroup.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">        [<span class="keyword">self</span>.ovalShapeLayer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样得到的效果，就是一次执行load的动画</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-%E6%A8%A1%E6%80%81loading3.gif" alt=""></p>
<p>我们想要重复执行，在这里我使用了timer</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(animations) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.timer fire];</div></pre></td></tr></table></figure>
<p>这下就可以重复执行了</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-24-%E6%A8%A1%E6%80%81loading4.gif" alt=""></p>
<p>至于label的添加，我就不写出来了，这个就很简单了，同样的源代码，放上去</p>
<p><a href="https://github.com/yangqian111/LoadingView" target="_blank" rel="external">https://github.com/yangqian111/LoadingView</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<p>上边是公众号，下边是我个人微信</p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br>    <image src="http://o8bxt3lx0.bkt.clouddn.com/avatar.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天带来一款自定义的模态loading的实现，通过自定义UI，画出loading的样式，并且有个转动的样式，下面我们就来实现以下。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS组件" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/"/>
    
      <category term="UI小组件" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/UI%E5%B0%8F%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="模态loading" scheme="http://ppsheep.com/all-tags/%E6%A8%A1%E6%80%81loading/"/>
    
  </entry>
  
  <entry>
    <title>iOS下载速度测试</title>
    <link href="http://ppsheep.com/2017/02/21/iOS%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>http://ppsheep.com/2017/02/21/iOS下载速度测试/</id>
    <published>2017-02-21T06:03:50.000Z</published>
    <updated>2017-02-21T07:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享一个下载速度测试的方法，很多APP都有测试网络延迟，测试下载上传速度。之前测试网络延迟的ping我们已经说过了，今天再来讲讲下载速度测试的办法。</p>
<a id="more"></a>
<h3 id="基本想法"><a href="#基本想法" class="headerlink" title="基本想法"></a>基本想法</h3><p>下载上传速度的测试，我的想法是下载一个静态资源，然后计算他的速度，这里使用AF来做下载，当然原生的NSURLSession也是一样的，为了方便，我就直接使用AF了</p>
<p>去百度上找一个静态资源：</p>
<p><a href="http://sw.bos.baidu.com/sw-search-sp/software/d28b12c330f7b/android-studio-bundle_2.2.0.0.exe" target="_blank" rel="external">http://sw.bos.baidu.com/sw-search-sp/software/d28b12c330f7b/android-studio-bundle_2.2.0.0.exe</a></p>
<p>Android studion </p>
<p>新建一个类，用于速度的测试PPSNetSpeedTest</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^NetSpeedBlock)(<span class="built_in">NSString</span> *speed);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PPSNetSpeedTest</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 下载网速测试</div><div class="line"> </div><div class="line"> @param callBackBlock 每秒回调，用于实时回传网速</div><div class="line"> @param completeBlock 最后测试完成，回调平均网速</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)startDownLoadTestWithCallBlock:(NetSpeedBlock)callBackBlock completeBlock:(NetSpeedBlock)completeBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其中的NetSpeedBlock是每次速度的回调</p>
<p>方法startDownLoadTestWithCallBlock:completeBlock:分别回传了每秒的下载速度和最后的平均速度</p>
<p>在实现方法里</p>
<p>说一下，我计算每秒下载速度的思路，在AF中，有一个下载的NSProgress，在progress中有这个文件的总大小，和当前下载的大小，我进行一个timer重复操作，每秒执行一个方法，来计算速度，在每次下载progress更新的时候，我都记录上了当前完成的文件大小，然后在计算的时候，来计算这一秒下载多少文件，那就是速度了。</p>
<p>说太多，我上代码吧</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startDownLoadTestWithCallBlock:(NetSpeedBlock)callBackBlock completeBlock:(NetSpeedBlock)completeBlock&#123;</div><div class="line">    <span class="keyword">self</span>.callBackBlock = callBackBlock;</div><div class="line">    <span class="keyword">self</span>.completeBlock = completeBlock;</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:FILE_PATH]];</div><div class="line">    <span class="keyword">self</span>.downloadTask = [_urlManager downloadTaskWithRequest:request progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</div><div class="line">        _completeFile = downloadProgress.completedUnitCount;</div><div class="line">    &#125; destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *downloadURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">        <span class="keyword">return</span> [downloadURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">    &#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成下载,然后删除文件"</span>);</div><div class="line">        <span class="built_in">NSString</span> *filesTR = filePath.path;</div><div class="line">        <span class="keyword">if</span> (_second&lt;<span class="number">9</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> finishDownLoad];<span class="comment">//网速太快，10秒内下载完毕</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:filesTR]) &#123;</div><div class="line">            <span class="built_in">NSError</span> *error;</div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:filePath error:&amp;error];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    [<span class="keyword">self</span>.downloadTask resume];</div><div class="line">    _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(countTime) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">    [_timer fire];</div><div class="line">    _second = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的一个问题  就是在文件下载完成后，测试结束，需要把文件删除掉</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)countTime&#123;</div><div class="line">    ++ _second;</div><div class="line">    <span class="keyword">if</span> (_second == <span class="number">9</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> finishCurrentTest];</div><div class="line">        <span class="built_in">CGFloat</span> averageSpeed = <span class="keyword">self</span>.completeFile/(pow(<span class="number">1024</span>, <span class="number">2</span>)*<span class="number">10.0</span>);</div><div class="line">        <span class="keyword">self</span>.completeBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.2fM"</span>,averageSpeed]);</div><div class="line">        <span class="keyword">self</span>.completeBlock = <span class="literal">nil</span>;</div><div class="line">        [<span class="keyword">self</span>.downloadTask cancel];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSInteger</span> everySecondFile = <span class="keyword">self</span>.completeFile - <span class="keyword">self</span>.lastSecondCompleteFile;</div><div class="line">    <span class="built_in">CGFloat</span> sppeed = everySecondFile/pow(<span class="number">1024</span>, <span class="number">2</span>)*<span class="number">1.0</span>;</div><div class="line">    <span class="keyword">self</span>.callBackBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.2fM"</span>,sppeed]);</div><div class="line">    <span class="keyword">self</span>.lastSecondCompleteFile = <span class="keyword">self</span>.completeFile;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为下载的文件都是以字节为单位，所以我转换成了M</p>
<p>pow(1024, 2) = 1024*1024</p>
<p>self.lastSecondCompleteFile = self.completeFile;</p>
<p>这句代码 是将每次计算完成之后，将lastSecondCompleteFile更新为此次下载的大小，等到下一秒，再来进行计算</p>
<p>非常重要的一点是，我们这里使用了timer，一定不要忘记，将timer invalidate</p>
<p>在下载完成，计算平均速度</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)finishDownLoad&#123;</div><div class="line">    [<span class="keyword">self</span> finishCurrentTest];</div><div class="line">    ++ _second;</div><div class="line">    <span class="built_in">CGFloat</span> averageSpeed = <span class="keyword">self</span>.completeFile/(pow(<span class="number">1024</span>, <span class="number">2</span>)*(_second+<span class="number">1</span>)*<span class="number">1.0</span>);</div><div class="line">    <span class="keyword">self</span>.completeBlock([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.2fM"</span>,averageSpeed]);</div><div class="line">    <span class="keyword">self</span>.completeBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.callBackBlock = <span class="literal">nil</span>;</div><div class="line">    [<span class="keyword">self</span>.downloadTask cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)finishCurrentTest&#123;</div><div class="line">    [_timer invalidate];</div><div class="line">    _timer = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    [_timer invalidate];</div><div class="line">    _timer = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单看一下效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-21-6.gif" alt=""></p>
<p>源代码</p>
<p><a href="https://github.com/yangqian111/NetSpeedTest" target="_blank" rel="external">https://github.com/yangqian111/NetSpeedTest</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<p>上边是公众号，下边是我个人微信</p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br>    <image src="http://o8bxt3lx0.bkt.clouddn.com/avatar.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享一个下载速度测试的方法，很多APP都有测试网络延迟，测试下载上传速度。之前测试网络延迟的ping我们已经说过了，今天再来讲讲下载速度测试的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS组件" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/"/>
    
      <category term="网络小工具" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="下载速度测试" scheme="http://ppsheep.com/all-tags/%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>AVPlayer的使用实践</title>
    <link href="http://ppsheep.com/2017/02/17/AVPlayer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ppsheep.com/2017/02/17/AVPlayer的使用实践/</id>
    <published>2017-02-17T09:17:58.000Z</published>
    <updated>2017-02-17T10:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在网上看到一篇博客，介绍AVPlayer的使用，但是只简单介绍了一下单个的本地文件如何播放，心血来潮，就想着做一个类似于播放器的东西，能够实现播放网络歌曲，循环播放多首音乐，下面我们来实现一下</p>
<a id="more"></a>
<p>首先明确一下，在本文中需要讲到的几点：</p>
<ul>
<li>实现网络歌曲的播放</li>
<li>实现在后台也能播放歌曲</li>
<li>实现多首歌曲的循环播放</li>
<li>需要有播放/暂停和下一首的功能</li>
<li>需要在播放期间能够得知该首歌曲的总时长和当前播放时长</li>
</ul>
<p>本文中就暂时将这名多，后面还会丰富，例如实现缓存下载，实现歌曲缓存的进度查看，实现能够使用耳机按钮控制播放等等。</p>
<h3 id="播放网络歌曲"><a href="#播放网络歌曲" class="headerlink" title="播放网络歌曲"></a>播放网络歌曲</h3><p>因为需要播放网络歌曲，我就往七牛云上传了几首歌，就不用再自己到处去找歌曲了</p>
<p>首先，明确我们播放歌曲使用的是AVPlayer，至于为什么使用它不使用其他的，因为它好用啊，苹果封装了强大的功能，让我们使用，干嘛不用！其实还有其他原因，这个就等着你自己去搜索了。</p>
<h5 id="AVQueuePlayer"><a href="#AVQueuePlayer" class="headerlink" title="AVQueuePlayer"></a>AVQueuePlayer</h5><p>AVQueuePlayer是AVPlayer的一个子类，他可以实现多首歌曲播放，所以我们直接使用它了</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//传入多个AVPlayerItem来初始化AVQueuePlayer</span></div><div class="line">+ (<span class="keyword">instancetype</span>)queuePlayerWithItems:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVPlayerItem</span> *&gt; *)items;</div></pre></td></tr></table></figure>
<h5 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h5><p>AVPlayerItem是一个资源对象，我们加载歌曲的时候都是使用它，它提供了两种初始化方法</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化网络资源</span></div><div class="line">+ (<span class="keyword">instancetype</span>)playerItemWithURL:(<span class="built_in">NSURL</span> *)URL;</div><div class="line"></div><div class="line"><span class="comment">//初始化本地资源，本地的音乐或者影片资源都是通过AVAsset拿出来</span></div><div class="line">+ (<span class="keyword">instancetype</span>)playerItemWithAsset:(<span class="built_in">AVAsset</span> *)asset;</div></pre></td></tr></table></figure>
<p>先来试一下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化AVPlayerItem</span></div><div class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="built_in">NSArray</span> *urls = @[MUSIC_URL1,MUSIC_URL2,MUSIC_URL3,MUSIC_URL4,MUSIC_URL5];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *url <span class="keyword">in</span> urls) &#123;</div><div class="line">        <span class="built_in">AVPlayerItem</span> *item = [[<span class="built_in">AVPlayerItem</span> alloc] initWithURL:[<span class="built_in">NSURL</span> URLWithString:url]];</div><div class="line">        [items addObject:item];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//初始化AVQueuePlayer</span></div><div class="line"><span class="built_in">AVQueuePlayer</span> *player = [<span class="built_in">AVQueuePlayer</span> queuePlayerWithItems: items];</div><div class="line"><span class="comment">//测试播放</span></div><div class="line"><span class="keyword">if</span>(player.status == <span class="built_in">AVPlayerStatusReadyToPlay</span>)&#123;</div><div class="line">	[player play];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码看起来没有错，但是我在做的时候，却遇到一个问题，第一次点击的时候，并不会播放，第二次第三次就会开始播放了。</p>
<p>其实这里是有一个缓冲的原因，因为是网络资源，涉及到一个缓冲，后面我们会对这个做处理，歌曲确实是能够播放的</p>
<p>就这样，简单实现了多首歌曲的播放，但是我们还需要实现循环播放，这个就相对麻烦一点了。</p>
<p>要实现循环播放，我们就需要知道AVQueuePlayer的播放机制，对于AVQueuePlayer播放，是有一个队列，每次播放完成一首歌曲过后，这首歌曲就会从队列中删除，即这个item会从队列中删除，并且如果我们想直接再将这个item再次加入队列，是不能够加入的，我们必须要在new 一个item,再次加载到这个队列当中，才能够实现再次播放。这个也是挺蛋疼的。</p>
<p>知道了这个，我们就有想法了，我们能够在player最后一首歌曲即将播放完成后，再来新建一个队列啊。思路是正确的，但是我们不能够直接得到player正在播放最后一首歌曲，这时候我想到的是一个timer检测，通过timer去检测player的播放队列是否还剩下一首歌曲，如果是的话，我们就新建队列，加入到player的播放序列中</p>
<p>首先，我们在开始播放歌曲的时候，就需要将timer启动，监测player</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.checkMusicTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(checkMusic) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
<p>在checkMusic我们判断当前是否队列中只有一首歌曲</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)checkMusic</div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.player.items.count == <span class="number">1</span>)&#123;</div><div class="line">        [<span class="keyword">self</span> prepareItems];<span class="comment">//这个方法即是再次创建队列，加入到player播放序列中</span></div><div class="line">        [<span class="keyword">self</span> play];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 准备歌曲</span></div><div class="line"><span class="comment">// 因为需要歌曲循环播放，每次AVQueuePlayer播放完成一首歌曲，就会将其从队列中移除</span></div><div class="line"><span class="comment">// 所以我们需要在歌曲最后一首播放完之前重新为AVQueuePlayer创建一个播放队列，这样就能够实现循环播放</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//</span></div><div class="line">- (<span class="keyword">void</span>)prepareItems&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="built_in">NSArray</span> *urls = @[MUSIC_URL1,MUSIC_URL2,MUSIC_URL3,MUSIC_URL4,MUSIC_URL5];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *url <span class="keyword">in</span> urls) &#123;</div><div class="line">        <span class="built_in">AVPlayerItem</span> *item = [[<span class="built_in">AVPlayerItem</span> alloc] initWithURL:[<span class="built_in">NSURL</span> URLWithString:url]];</div><div class="line">        [items addObject:item];</div><div class="line"><span class="comment">//这里是添加每首歌曲的监测，我们后面会讲到</span></div><div class="line">        [item addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loadedTimeRanges"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(playbackFinished:) name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span> object:item];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.playerItems = items;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">AVPlayerItem</span> *item <span class="keyword">in</span> items) &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.player canInsertItem:item afterItem:<span class="keyword">self</span>.player.items.lastObject]) &#123;</div><div class="line">            [<span class="keyword">self</span>.player insertItem:item afterItem:<span class="keyword">self</span>.player.items.lastObject];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，我们就能够实现循环播放了，这里的代码和后面要讲到的有关联，所以这里看不清晰也没关系，接着往后看</p>
<p>上面我们讲了，有个缓冲的原因，导致首次点击播放的时候，不能够成功播放，在AVPlayerItem中有一个属性loadedTimeRanges，表示的是缓存状态，我们可以对他进行观察，来进行播放</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上面的代码已经写出了对缓冲的检测</span></div><div class="line">[item addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loadedTimeRanges"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>然后我们在观察者中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"loadedTimeRanges"</span>]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"缓冲"</span>);</div><div class="line">        [<span class="keyword">self</span> play];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在每个item中加入了观察者，在什么时候移除呢，当然是在每首歌曲播放完成后移除，如果不移除将会崩溃</p>
<p>再次对每个item进行观测，播放结束时</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(playbackFinished:) name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span> object:item];</div></pre></td></tr></table></figure>
<p>在播放结束，移除观察者</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)playbackFinished:(<span class="built_in">NSNotification</span> *)notice &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"播放完成"</span>);</div><div class="line">    [<span class="keyword">self</span>.currentItem removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loadedTimeRanges"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现后台播放"><a href="#实现后台播放" class="headerlink" title="实现后台播放"></a>实现后台播放</h3><p>要实现后台播放，很简单只需要加入几行代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置可后台播放</span></div><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">[[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:&amp;error];</div><div class="line">[[<span class="built_in">AVAudioSession</span> sharedInstance] setActive:<span class="literal">YES</span> error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>然后我们还需要在项目里设置</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-02-17-100118.jpg" alt=""></p>
<h3 id="播放暂停"><a href="#播放暂停" class="headerlink" title="播放暂停"></a>播放暂停</h3><p>这个就很简单了</p>
<p>直接调方法就行</p>
<p>上一首下一首也是直接调用方法就行</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> @method		play</div><div class="line"> @abstract		Signals the desire to begin playback at the current item's natural rate.</div><div class="line"> @discussion	Equivalent to setting the value of rate to 1.0.</div><div class="line"> */</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)play;</div><div class="line">- <span class="comment">/*!</span></div><div class="line"> @method		pause</div><div class="line"> @abstract		Pauses playback.</div><div class="line"> @discussion	Equivalent to setting the value of rate to 0.0.</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)pause;</div><div class="line"></div><div class="line"><span class="comment">/*!</span></div><div class="line">    @method     advanceToNextItem</div><div class="line">    @abstract   Ends playback of the current item and initiates playback of the next item in the player's queue.</div><div class="line">    @discussion Removes the current item from the play queue.</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)advanceToNextItem;</div></pre></td></tr></table></figure>
<h3 id="时长计算"><a href="#时长计算" class="headerlink" title="时长计算"></a>时长计算</h3><p>为player加一个观察者就行</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)playerDidPlay&#123;</div><div class="line">    <span class="comment">//    //添加播放进度观察者</span></div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">self</span>.timeObserver = [<span class="keyword">self</span>.manager.player addPeriodicTimeObserverForInterval:<span class="built_in">CMTimeMake</span>(<span class="number">1.0</span>,<span class="number">1.0</span>) queue:dispatch_get_main_queue() usingBlock:^(<span class="built_in">CMTime</span> time) &#123;</div><div class="line">            <span class="keyword">float</span> current = <span class="built_in">CMTimeGetSeconds</span>(time);</div><div class="line">            <span class="keyword">float</span> total = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.manager.currentItem.duration);</div><div class="line">            weakSelf.total = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.2f"</span>,total];</div><div class="line">            weakSelf.current = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.f"</span>,current];</div><div class="line">            weakSelf.label.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@"</span>,weakSelf.current,weakSelf.total];</div><div class="line">        &#125;];</div><div class="line">    _isPlaying = <span class="literal">YES</span>;</div><div class="line">    [<span class="keyword">self</span>.play setTitle:<span class="string">@"暂停"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的CMTime指的是帧数</p>
<p>基本上就是这些了，我把源码先放上去，后面再来丰富</p>
<p>源码地址</p>
<p><a href="https://github.com/yangqian111/AVPlayer" target="_blank" rel="external">https://github.com/yangqian111/AVPlayer</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在网上看到一篇博客，介绍AVPlayer的使用，但是只简单介绍了一下单个的本地文件如何播放，心血来潮，就想着做一个类似于播放器的东西，能够实现播放网络歌曲，循环播放多首音乐，下面我们来实现一下&lt;/p&gt;
    
    </summary>
    
      <category term="iOS基础" scheme="http://ppsheep.com/all-categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="AVPlayer" scheme="http://ppsheep.com/all-tags/AVPlayer/"/>
    
  </entry>
  
  <entry>
    <title>iOS ping网络小工具</title>
    <link href="http://ppsheep.com/2017/01/03/iOS-ping%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://ppsheep.com/2017/01/03/iOS-ping网络小工具/</id>
    <published>2017-01-03T05:30:44.000Z</published>
    <updated>2017-02-15T03:58:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ping工具经常在游戏中见到，计算网络的延迟，Apple官方有一个SimplePing的demo，用于对网络进行检测，就跟我们电脑端的ping效果相同，在一些情况下，我们可以用来进行网络速度的检测，这里将官方给出的demo进行封装，并且在SimplePing的基础上进行了一些改动，将我们需要用到的一些其他的数据取出来，便于我们的使用，源码我会放在文章末尾。</p>
<a id="more"></a>
<h3 id="SimplePing"><a href="#SimplePing" class="headerlink" title="SimplePing"></a>SimplePing</h3><p>Apple官方的demo SimplePing ，能够实现网络ping功能，但是有一些其他的数据不能够得到，例如存活时间，响应时间等等，下面是官方例子：</p>
<p><a href="https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html" target="_blank" rel="external">https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html</a></p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-03-053734.jpg" alt=""></p>
<h3 id="改动后的PPSSimplePing"><a href="#改动后的PPSSimplePing" class="headerlink" title="改动后的PPSSimplePing"></a>改动后的PPSSimplePing</h3><p>改动后的SimplePing能够计算出响应时间，得到域名的ip地址，存活时间等等。</p>
<h3 id="PPSPingItem"><a href="#PPSPingItem" class="headerlink" title="PPSPingItem"></a>PPSPingItem</h3><p>新建一个我们的自己的工程，将刚才下载的例子中的SimplePing 头文件和实现文件 两个文件拷贝到我们的工程中</p>
<p>首先，我们新建一个model PPSPingItem  用来封装我们在网络ping过程中，返回的一些数据，便于数据展示</p>
<p>我们来看一张电脑的终端ping的样式：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-03-054734.jpg" alt=""></p>
<p>我们在手机端要实现的也是这种效果</p>
<p>PPSPingItem：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">typedef NS_ENUM(NSUInteger, PPSPingStatus)&#123;</div><div class="line">    PPSPingStatusDidStart,//开始</div><div class="line">    PPSPingStatusDidFailToSendPacket,//发送数据包失败</div><div class="line">    PPSPingStatusDidReceivePacket,//收到数据包</div><div class="line">    PPSPingStatusDidReceiveUnexpectedPacket,//数据包数据错误</div><div class="line">    PPSPingStatusDidTimeout,//超时</div><div class="line">    PPSPingStatusError,//错误</div><div class="line">    PPSPingStatusFinished,//完成</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">@interface PPSPingItem : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> </div><div class="line"> ping www.163.com</div><div class="line"> </div><div class="line"> PING 163.xdwscache.ourglb0.com (183.134.24.71): 56 data bytes</div><div class="line"> </div><div class="line"> 64 bytes from 183.134.24.71: icmp_seq=0 ttl=53 time=12.914 ms</div><div class="line"> 64 bytes from 183.134.24.71: icmp_seq=1 ttl=53 time=15.136 ms</div><div class="line"> </div><div class="line"> --- 163.xdwscache.ourglb0.com ping statistics ---</div><div class="line"> 2 packets transmitted, 2 packets received, 0.0% packet loss</div><div class="line"> </div><div class="line"> */</div><div class="line"></div><div class="line">/**</div><div class="line"> 对应上面的一个ping解释属性</div><div class="line"> */</div><div class="line"></div><div class="line">@property(nonatomic) NSString *originalAddress; // 163.xdwscache.ourglb0.com</div><div class="line"></div><div class="line">@property(nonatomic, copy) NSString *IPAddress;// 183.134.24.71</div><div class="line"></div><div class="line">@property(nonatomic) NSUInteger dateBytesLength;// 64</div><div class="line"></div><div class="line">@property(nonatomic) double     timeMilliseconds;//time</div><div class="line"></div><div class="line">@property(nonatomic) NSInteger  timeToLive;//ttl</div><div class="line"></div><div class="line">@property(nonatomic) NSInteger  ICMPSequence;//icmp_seq</div><div class="line"></div><div class="line">@property(nonatomic) PPSPingStatus status;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>PPSPingItem中的属性，在我们ping网络过程中，返回数据时需要用到。</p>
<h3 id="PPSPingServices"><a href="#PPSPingServices" class="headerlink" title="PPSPingServices"></a>PPSPingServices</h3><p>PPSPingServices是一个服务类，用作ping的入口，一个管理类，供外部调用，在PPSPingServices类中，我将发起网络ping的接口做成了block，当然，如果你更喜欢delegate，也可以使用delegate实现</p>
<p>首先，一个类方法，调起Ping服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 开始收集Ping网络消息</div><div class="line"> </div><div class="line"> @param address 域名</div><div class="line"> @param handler 回调包信息 每次收到的网络信息</div><div class="line"> @return PPSPingServices</div><div class="line"> */</div><div class="line">+ (PPSPingServices *)startPingAddress:(NSString *)address</div><div class="line">                      callbackHandler:(void(^)(PPSPingItem *pingItem, NSArray *pingItems))handler;</div></pre></td></tr></table></figure>
<p>在实现文件中，我们需要实现SimplePingDelegate，delegate中一共有6个方法，分别对应这ping的不同状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//开始进行网络检测</div><div class="line">- (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address;</div><div class="line">//网络检测失败</div><div class="line">- (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error;</div><div class="line">//发送网络包成功</div><div class="line">- (void)simplePing:(SimplePing *)pinger didSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;</div><div class="line">//发送网络包失败</div><div class="line">- (void)simplePing:(SimplePing *)pinger didFailToSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber error:(NSError *)error;</div><div class="line">//收到网络包回应</div><div class="line">- (void)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;</div><div class="line">//收到错误的网络包</div><div class="line">- (void)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(NSData *)packet;</div></pre></td></tr></table></figure>
<p>开始ping网络数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 开始网络ping网络</div><div class="line"></div><div class="line"> @param sender 按钮</div><div class="line"> */</div><div class="line">- (IBAction)startPing:(id)sender &#123;</div><div class="line"> self.pingService = [PPSPingServices startPingAddress:_domainTextFiled.text callbackHandler:^(PPSPingItem *pingItem, NSArray *pingItems) &#123;</div><div class="line">     NSLog(@&quot;%@&quot;,pingItem);</div><div class="line"> &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在服务类中，我们开始ping网络，会在6个delegate方法中，分别获得ping网络的返回值</p>
<p>看一下效果图：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-09-iOSping%E5%B0%8F%E5%B7%A5%E5%85%B7.gif" alt=""></p>
<p>后面如果还有时间，会接着完善</p>
<p>源码放在：</p>
<p><a href="https://github.com/yangqian111/PPSSimplePing" target="_blank" rel="external">https://github.com/yangqian111/PPSSimplePing</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ping工具经常在游戏中见到，计算网络的延迟，Apple官方有一个SimplePing的demo，用于对网络进行检测，就跟我们电脑端的ping效果相同，在一些情况下，我们可以用来进行网络速度的检测，这里将官方给出的demo进行封装，并且在SimplePing的基础上进行了一些改动，将我们需要用到的一些其他的数据取出来，便于我们的使用，源码我会放在文章末尾。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS组件" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/"/>
    
      <category term="网络小工具" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ping工具" scheme="http://ppsheep.com/all-tags/ping%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 获取当前设备的信息-网络相关</title>
    <link href="http://ppsheep.com/2016/12/16/iOS%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%A1%E6%81%AF-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    <id>http://ppsheep.com/2016/12/16/iOS获取当前设备的信息-网络相关/</id>
    <published>2016-12-16T06:57:18.000Z</published>
    <updated>2017-02-15T04:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞网络相关的SDK，将自己在项目中能够开放出来的，记录下来，其中很多用到了C，相当于一个工具。后期还会选择开放一些ping网络的工具，找链路节点的工具，最近就在搞这个。</p>
<a id="more"></a>
<h3 id="获取当前设备的IP地址"><a href="#获取当前设备的IP地址" class="headerlink" title="获取当前设备的IP地址"></a>获取当前设备的IP地址</h3><p>对于公网的IP当然，在我们本地设备上是不能够获取到的，至少我没有找到方法获取到出口IP地址，但是局域网的IP还是能够获取到的，这里ipv4和ipv6 都能够获取出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)deviceIPAdress</div><div class="line">&#123;</div><div class="line">    NSString *address = @&quot;&quot;;</div><div class="line">    struct ifaddrs *interfaces = NULL;</div><div class="line">    struct ifaddrs *temp_addr = NULL;</div><div class="line">    int success = 0;</div><div class="line">    </div><div class="line">    success = getifaddrs(&amp;interfaces);</div><div class="line">    </div><div class="line">    if (success == 0) &#123;  // 0 表示获取成功</div><div class="line">        </div><div class="line">        temp_addr = interfaces;</div><div class="line">        while (temp_addr != NULL) &#123;</div><div class="line">            </div><div class="line">            if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;] || [[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;pdp_ip0&quot;])</div><div class="line">                &#123;</div><div class="line">                //如果是IPV4地址，直接转化</div><div class="line">                if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET)&#123;</div><div class="line">                    </div><div class="line">                    // Get NSString from C String</div><div class="line">                    address = [self formatIPV4Address:((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                //如果是IPV6地址</div><div class="line">                else if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET6)&#123;</div><div class="line">                    address = [self formatIPV6Address:((struct sockaddr_in6 *)temp_addr-&gt;ifa_addr)-&gt;sin6_addr];</div><div class="line">                    if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) break;</div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            temp_addr = temp_addr-&gt;ifa_next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    freeifaddrs(interfaces);</div><div class="line">    </div><div class="line">    //以FE80开始的地址是单播地址</div><div class="line">    if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) &#123;</div><div class="line">        return address;</div><div class="line">    &#125; else &#123;</div><div class="line">        return @&quot;127.0.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前设备网关地址"><a href="#获取当前设备网关地址" class="headerlink" title="获取当前设备网关地址"></a>获取当前设备网关地址</h3><p>网关地址，通俗点  就是路由器的地址，也是相对于局域网 这里需要区分一下ipv4和ipv6，两种获取网关地址的方法是不一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">//ipv4网关地址</div><div class="line">+ (NSString *)getGatewayIPV4Address</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    /* net.route.0.inet.flags.gateway */</div><div class="line">    int mib[] = &#123;CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_GATEWAY&#125;;</div><div class="line">    </div><div class="line">    size_t l;</div><div class="line">    char *buf, *p;</div><div class="line">    struct rt_msghdr *rt;</div><div class="line">    struct sockaddr *sa;</div><div class="line">    struct sockaddr *sa_tab[RTAX_MAX];</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">        address = @&quot;192.168.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (l &gt; 0) &#123;</div><div class="line">        buf = malloc(l);</div><div class="line">        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">            address = @&quot;192.168.0.1&quot;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (p = buf; p &lt; buf + l; p += rt-&gt;rtm_msglen) &#123;</div><div class="line">            rt = (struct rt_msghdr *)p;</div><div class="line">            sa = (struct sockaddr *)(rt + 1);</div><div class="line">            for (i = 0; i &lt; RTAX_MAX; i++) &#123;</div><div class="line">                if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) &#123;</div><div class="line">                    sa_tab[i] = sa;</div><div class="line">                    sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa-&gt;sa_len));</div><div class="line">                &#125; else &#123;</div><div class="line">                    sa_tab[i] = NULL;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (((rt-&gt;rtm_addrs &amp; (RTA_DST | RTA_GATEWAY)) == (RTA_DST | RTA_GATEWAY)) &amp;&amp;</div><div class="line">                sa_tab[RTAX_DST]-&gt;sa_family == AF_INET &amp;&amp;</div><div class="line">                sa_tab[RTAX_GATEWAY]-&gt;sa_family == AF_INET) &#123;</div><div class="line">                unsigned char octet[4] = &#123;0, 0, 0, 0&#125;;</div><div class="line">                int i;</div><div class="line">                for (i = 0; i &lt; 4; i++) &#123;</div><div class="line">                    octet[i] = (((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))-&gt;sin_addr.s_addr &gt;&gt;</div><div class="line">                                (i * 8)) &amp;</div><div class="line">                    0xFF;</div><div class="line">                &#125;</div><div class="line">                if (((struct sockaddr_in *)sa_tab[RTAX_DST])-&gt;sin_addr.s_addr == 0) &#123;</div><div class="line">                    in_addr_t addr =</div><div class="line">                    ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))-&gt;sin_addr.s_addr;</div><div class="line">                    address = [self formatIPV4Address:*((struct in_addr *)&amp;addr)];</div><div class="line">                    //                    NSLog(@&quot;IPV4address%@&quot;, address);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(buf);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">//ipv6网关地址</div><div class="line">+ (NSString *)getGatewayIPV6Address</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    /* net.route.0.inet.flags.gateway */</div><div class="line">    int mib[] = &#123;CTL_NET, PF_ROUTE, 0, AF_INET6, NET_RT_FLAGS, RTF_GATEWAY&#125;;</div><div class="line">    </div><div class="line">    size_t l;</div><div class="line">    char *buf, *p;</div><div class="line">    struct rt_msghdr *rt;</div><div class="line">    struct sockaddr_in6 *sa;</div><div class="line">    struct sockaddr_in6 *sa_tab[RTAX_MAX];</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">        address = @&quot;192.168.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (l &gt; 0) &#123;</div><div class="line">        buf = malloc(l);</div><div class="line">        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">            address = @&quot;192.168.0.1&quot;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (p = buf; p &lt; buf + l; p += rt-&gt;rtm_msglen) &#123;</div><div class="line">            rt = (struct rt_msghdr *)p;</div><div class="line">            sa = (struct sockaddr_in6 *)(rt + 1);</div><div class="line">            for (i = 0; i &lt; RTAX_MAX; i++) &#123;</div><div class="line">                if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) &#123;</div><div class="line">                    sa_tab[i] = sa;</div><div class="line">                    sa = (struct sockaddr_in6 *)((char *)sa + sa-&gt;sin6_len);</div><div class="line">                &#125; else &#123;</div><div class="line">                    sa_tab[i] = NULL;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if( ((rt-&gt;rtm_addrs &amp; (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))</div><div class="line">               &amp;&amp; sa_tab[RTAX_DST]-&gt;sin6_family == AF_INET6</div><div class="line">               &amp;&amp; sa_tab[RTAX_GATEWAY]-&gt;sin6_family == AF_INET6)</div><div class="line">                &#123;</div><div class="line">                address = [self formatIPV6Address:((struct sockaddr_in6 *)(sa_tab[RTAX_GATEWAY]))-&gt;sin6_addr];</div><div class="line">                //                NSLog(@&quot;IPV6address%@&quot;, address);</div><div class="line">                break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        free(buf);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在获取的时候判断一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> * 获取当前设备网关地址</div><div class="line"> */</div><div class="line">+ (NSString *)getGatewayIPAddress&#123;</div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    NSString *gatewayIPV4 = [self getGatewayIPV4Address];</div><div class="line">    NSString *gatewayIPV6 = [self getGatewayIPV6Address];</div><div class="line">    </div><div class="line">    if (gatewayIPV6 != nil) &#123;</div><div class="line">        address = gatewayIPV6;</div><div class="line">    &#125; else &#123;</div><div class="line">        address = gatewayIPV4;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过域名拿到域名对应的IP地址-CDN"><a href="#通过域名拿到域名对应的IP地址-CDN" class="headerlink" title="通过域名拿到域名对应的IP地址(CDN)"></a>通过域名拿到域名对应的IP地址(CDN)</h3><p>通过域名拿到的IP地址，一般来说，如果买了CDN的话，拿到的Ip都会是多个IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*!</div><div class="line"> * 通过hostname获取ip列表 DNS解析地址</div><div class="line"> */</div><div class="line">+ (NSArray *)getDNSsWithDormain:(NSString *)hostName&#123;</div><div class="line">    NSMutableArray *result = [[NSMutableArray alloc] init];</div><div class="line">    NSArray *IPDNSs = [self getDNSWithHostName:hostName];</div><div class="line">    if (IPDNSs &amp;&amp; IPDNSs.count &gt; 0) &#123;</div><div class="line">        [result addObjectsFromArray:IPDNSs];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [NSArray arrayWithArray:result];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSArray *)getDNSWithHostName:(NSString *)hostName</div><div class="line">&#123;</div><div class="line">    const char *hostN = [hostName UTF8String];</div><div class="line">    Boolean result = false;</div><div class="line">    Boolean bResolved = false;</div><div class="line">    CFHostRef hostRef;</div><div class="line">    CFArrayRef addresses = NULL;</div><div class="line">    </div><div class="line">    CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, hostN, kCFStringEncodingASCII);</div><div class="line">    </div><div class="line">    hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);</div><div class="line">    if (hostRef) &#123;</div><div class="line">        result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);</div><div class="line">        if (result == true) &#123;</div><div class="line">            addresses = CFHostGetAddressing(hostRef, &amp;result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    bResolved = result;</div><div class="line">    NSMutableArray *ipAddresses = [NSMutableArray array];</div><div class="line">    if(bResolved)</div><div class="line">        &#123;</div><div class="line">        struct sockaddr_in* remoteAddr;</div><div class="line">        </div><div class="line">        for(int i = 0; i &lt; CFArrayGetCount(addresses); i++)</div><div class="line">            &#123;</div><div class="line">            CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i);</div><div class="line">            remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData);</div><div class="line">            </div><div class="line">            if(remoteAddr != NULL)</div><div class="line">                &#123;</div><div class="line">                //获取IP地址</div><div class="line">                const char *strIP41 = inet_ntoa(remoteAddr-&gt;sin_addr);</div><div class="line">                NSString *strDNS =[NSString stringWithCString:strIP41 encoding:NSASCIIStringEncoding];</div><div class="line">                [ipAddresses addObject:strDNS];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    CFRelease(hostNameRef);</div><div class="line">    if (hostRef) &#123;</div><div class="line">        CFRelease(hostRef);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [NSArray arrayWithArray:ipAddresses];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前的网络状况"><a href="#获取当前的网络状况" class="headerlink" title="获取当前的网络状况"></a>获取当前的网络状况</h3><p>如果是WIFI环境，直接返回wifi  如果是蜂窝网络环境，那么还可以区分到底是那个运营商，还可以区分是使用的什么网络，4G 3G 2G等  运营商暂时区分了国内的三大运营商，如果还需要区分国外的，可以维基百科上查对应的code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+(NSString *)currentNetInfo&#123;</div><div class="line">    </div><div class="line">    NSString *returnName = nil;</div><div class="line">    </div><div class="line">    PPSNetWorkType type = [PPSGetAppEnvironment getNetworkTypeFromStatusBar];</div><div class="line">    if (type == PPSNetWorkTypeWiFi) &#123;</div><div class="line">        returnName = @&quot;WIFI&quot;;</div><div class="line">        return returnName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString *carrierName = nil;</div><div class="line">    CTTelephonyNetworkInfo *netInfo = [[CTTelephonyNetworkInfo alloc] init];</div><div class="line">    CTCarrier *carrier = [netInfo subscriberCellularProvider];</div><div class="line">    if (carrier != NULL) &#123;</div><div class="line">        NSArray *chinaMobileMics = @[@&quot;0&quot;,@&quot;2&quot;,@&quot;7&quot;];//移动code</div><div class="line">        NSArray *chinaTelecomMics = @[@&quot;3&quot;,@&quot;5&quot;,@&quot;11&quot;];//电信code</div><div class="line">        NSArray *chinaUnicomMics = @[@&quot;1&quot;,@&quot;6&quot;];//联通code</div><div class="line">        NSString *mobileNetworkCode = [carrier mobileNetworkCode];</div><div class="line">        if ([chinaMobileMics containsObject:mobileNetworkCode]) &#123;</div><div class="line">            carrierName = @&quot;chinamobile&quot;;</div><div class="line">        &#125;else if ([chinaTelecomMics containsObject:mobileNetworkCode])&#123;</div><div class="line">            carrierName = @&quot;chinatelecom&quot;;</div><div class="line">        &#125;else if ([chinaUnicomMics containsObject:mobileNetworkCode])&#123;</div><div class="line">            carrierName = @&quot;chinaunicom&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">            carrierName = @&quot;unknown&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        carrierName = @&quot;unknown&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    switch (type) &#123;</div><div class="line">        case PPSNetWorkType2G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;2G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType3G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;3G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType4G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;4G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType5G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;5G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkTypeNone:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;unknown&quot;];</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;unknown&quot;];</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return returnName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前的设备信息"><a href="#获取当前的设备信息" class="headerlink" title="获取当前的设备信息"></a>获取当前的设备信息</h3><p>获取当前设备的信息，是iPhone 4 5 6 7还是 等等  还有系统的版本号  手机、平板<br>之类的都能够去区分出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> 获取设备的类型</div><div class="line"> </div><div class="line"> @return 设备类型</div><div class="line"> */</div><div class="line">+ (NSString *)deviceInfo &#123;</div><div class="line">    struct utsname systemInfo;</div><div class="line">    </div><div class="line">    uname(&amp;systemInfo);</div><div class="line">    </div><div class="line">    NSString* code = [NSString stringWithCString:systemInfo.machine</div><div class="line">                                        encoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    static NSDictionary* deviceNamesByCode = nil;</div><div class="line">    </div><div class="line">    if (!deviceNamesByCode) &#123;</div><div class="line">        </div><div class="line">        deviceNamesByCode = @&#123;@&quot;i386&quot;      :@&quot;Simulator&quot;,</div><div class="line">                              @&quot;x86_64&quot;    :@&quot;Simulator&quot;,</div><div class="line">                              @&quot;iPod1,1&quot;   :@&quot;iPod Touch&quot;,        // (Original)</div><div class="line">                              @&quot;iPod2,1&quot;   :@&quot;iPod Touch&quot;,        // (Second Generation)</div><div class="line">                              @&quot;iPod3,1&quot;   :@&quot;iPod Touch&quot;,        // (Third Generation)</div><div class="line">                              @&quot;iPod4,1&quot;   :@&quot;iPod Touch&quot;,        // (Fourth Generation)</div><div class="line">                              @&quot;iPod7,1&quot;   :@&quot;iPod Touch&quot;,        // (6th Generation)</div><div class="line">                              @&quot;iPhone1,1&quot; :@&quot;iPhone&quot;,            // (Original)</div><div class="line">                              @&quot;iPhone1,2&quot; :@&quot;iPhone&quot;,            // (3G)</div><div class="line">                              @&quot;iPhone2,1&quot; :@&quot;iPhone&quot;,            // (3GS)</div><div class="line">                              @&quot;iPad1,1&quot;   :@&quot;iPad&quot;,              // (Original)</div><div class="line">                              @&quot;iPad2,1&quot;   :@&quot;iPad 2&quot;,            //</div><div class="line">                              @&quot;iPad3,1&quot;   :@&quot;iPad&quot;,              // (3rd Generation)</div><div class="line">                              @&quot;iPhone3,1&quot; :@&quot;iPhone 4&quot;,          // (GSM)</div><div class="line">                              @&quot;iPhone3,3&quot; :@&quot;iPhone 4&quot;,          // (CDMA/Verizon/Sprint)</div><div class="line">                              @&quot;iPhone4,1&quot; :@&quot;iPhone 4S&quot;,         //</div><div class="line">                              @&quot;iPhone5,1&quot; :@&quot;iPhone 5&quot;,          // (model A1428, AT&amp;T/Canada)</div><div class="line">                              @&quot;iPhone5,2&quot; :@&quot;iPhone 5&quot;,          // (model A1429, everything else)</div><div class="line">                              @&quot;iPad3,4&quot;   :@&quot;iPad&quot;,              // (4th Generation)</div><div class="line">                              @&quot;iPad2,5&quot;   :@&quot;iPad Mini&quot;,         // (Original)</div><div class="line">                              @&quot;iPhone5,3&quot; :@&quot;iPhone 5c&quot;,         // (model A1456, A1532 | GSM)</div><div class="line">                              @&quot;iPhone5,4&quot; :@&quot;iPhone 5c&quot;,         // (model A1507, A1516, A1526 (China), A1529 | Global)</div><div class="line">                              @&quot;iPhone6,1&quot; :@&quot;iPhone 5s&quot;,         // (model A1433, A1533 | GSM)</div><div class="line">                              @&quot;iPhone6,2&quot; :@&quot;iPhone 5s&quot;,         // (model A1457, A1518, A1528 (China), A1530 | Global)</div><div class="line">                              @&quot;iPhone7,1&quot; :@&quot;iPhone 6 Plus&quot;,     //</div><div class="line">                              @&quot;iPhone7,2&quot; :@&quot;iPhone 6&quot;,          //</div><div class="line">                              @&quot;iPhone8,1&quot; :@&quot;iPhone 6S&quot;,         //</div><div class="line">                              @&quot;iPhone8,2&quot; :@&quot;iPhone 6S Plus&quot;,    //</div><div class="line">                              @&quot;iPhone8,4&quot; :@&quot;iPhone SE&quot;,         //</div><div class="line">                              @&quot;iPhone9,1&quot; :@&quot;iPhone 7&quot;,          //</div><div class="line">                              @&quot;iPhone9,3&quot; :@&quot;iPhone 7&quot;,          //</div><div class="line">                              @&quot;iPhone9,2&quot; :@&quot;iPhone 7 Plus&quot;,     //</div><div class="line">                              @&quot;iPhone9,4&quot; :@&quot;iPhone 7 Plus&quot;,     //</div><div class="line">                              </div><div class="line">                              @&quot;iPad4,1&quot;   :@&quot;iPad Air&quot;,          // 5th Generation iPad (iPad Air) - Wifi</div><div class="line">                              @&quot;iPad4,2&quot;   :@&quot;iPad Air&quot;,          // 5th Generation iPad (iPad Air) - Cellular</div><div class="line">                              @&quot;iPad4,4&quot;   :@&quot;iPad Mini&quot;,         // (2nd Generation iPad Mini - Wifi)</div><div class="line">                              @&quot;iPad4,5&quot;   :@&quot;iPad Mini&quot;,         // (2nd Generation iPad Mini - Cellular)</div><div class="line">                              @&quot;iPad4,7&quot;   :@&quot;iPad Mini&quot;,         // (3rd Generation iPad Mini - Wifi (model A1599))</div><div class="line">                              @&quot;iPad6,7&quot;   :@&quot;iPad Pro (12.9\&quot;)&quot;, // iPad Pro 12.9 inches - (model A1584)</div><div class="line">                              @&quot;iPad6,8&quot;   :@&quot;iPad Pro (12.9\&quot;)&quot;, // iPad Pro 12.9 inches - (model A1652)</div><div class="line">                              @&quot;iPad6,3&quot;   :@&quot;iPad Pro (9.7\&quot;)&quot;,  // iPad Pro 9.7 inches - (model A1673)</div><div class="line">                              @&quot;iPad6,4&quot;   :@&quot;iPad Pro (9.7\&quot;)&quot;   // iPad Pro 9.7 inches - (models A1674 and A1675)</div><div class="line">                              &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString* deviceName = [deviceNamesByCode objectForKey:code];</div><div class="line">    </div><div class="line">    if (!deviceName) &#123;</div><div class="line">        // Not found on database. At least guess main device type from string contents:</div><div class="line">        </div><div class="line">        if ([code rangeOfString:@&quot;iPod&quot;].location != NSNotFound) &#123;</div><div class="line">            deviceName = @&quot;iPod Touch&quot;;</div><div class="line">        &#125;</div><div class="line">        else if([code rangeOfString:@&quot;iPad&quot;].location != NSNotFound) &#123;</div><div class="line">            deviceName = @&quot;iPad&quot;;</div><div class="line">        &#125;</div><div class="line">        else if([code rangeOfString:@&quot;iPhone&quot;].location != NSNotFound)&#123;</div><div class="line">            deviceName = @&quot;iPhone&quot;;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            deviceName = @&quot;Unknown&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIDevice *device = [UIDevice currentDevice];</div><div class="line">    NSString *systemVersion = [device systemVersion];</div><div class="line">    </div><div class="line">    return [NSString stringWithFormat:@&quot;iOS#%@#%@&quot;,deviceName,systemVersion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取的信息：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-16-081639.jpg" alt=""></p>
<p>原项目地址：</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS获取当前设备的信息-网络相关" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS获取当前设备的信息-网络相关</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞网络相关的SDK，将自己在项目中能够开放出来的，记录下来，其中很多用到了C，相当于一个工具。后期还会选择开放一些ping网络的工具，找链路节点的工具，最近就在搞这个。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS组件" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/"/>
    
      <category term="网络小工具" scheme="http://ppsheep.com/all-categories/iOS%E7%BB%84%E4%BB%B6/%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="域名解析 网络判断" scheme="http://ppsheep.com/all-tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的并发编程</title>
    <link href="http://ppsheep.com/2016/12/14/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
    <id>http://ppsheep.com/2016/12/14/iOS中的并发编程-一/</id>
    <published>2016-12-14T07:09:03.000Z</published>
    <updated>2017-01-20T09:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程，这个我们听起来再熟悉不过了，我们在代码编写过程中也经常会做这样一些操作，但是我发现，在实际的编写过程中，很多实用并发编程的方式，其实是错误使用的，当然这也包括我自己，对一些并发编程也是糊里糊涂，今天的工作中涉及到了许多的并发方面的问题，专门抽时间去学习了一下，现在记录下来。</p>
<a id="more"></a>
<h3 id="OS-X和iOS中的并发编程"><a href="#OS-X和iOS中的并发编程" class="headerlink" title="OS X和iOS中的并发编程"></a>OS X和iOS中的并发编程</h3><p>在OS X和iOS中，Apple都为我们提供了相同的并发编程API。pthread 、 NSThread 、GCD 、NSOperationQueue。</p>
<h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><p>pthread是比较底层的并发API，这个用起来并不是那么容易，而且在我们日常的编码过程中，我们也应该抛弃掉这种效率极低的并发编程方式。这里就不对这种并发做过多详细的介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p>NSThread这个我们听起来就很熟悉了，实际上，这是Apple对pthread的一个封装，封装成了Objectivc-C的接口API，在cocoa环境中，我们能够轻易使用NSThread来进行并发编程。</p>
<p>例如我们现在有这样一个场景，需要计算100万个数字中的最大数和最小数，首先我们可以定义一个NSThread的子类，专门来进行这个运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@interface FindMinMaxThread : NSThread</div><div class="line">@property (nonatomic) NSUInteger min;</div><div class="line">@property (nonatomic) NSUInteger max;</div><div class="line">- (instancetype)initWithNumbers:(NSArray *)numbers;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FindMinMaxThread &#123;</div><div class="line">    NSArray *_numbers;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithNumbers:(NSArray *)numbers</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _numbers = numbers;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)main</div><div class="line">&#123;</div><div class="line">    NSUInteger min;</div><div class="line">    NSUInteger max;</div><div class="line">    // 进行相关数据的处理</div><div class="line">    self.min = min;</div><div class="line">    self.max = max;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的 start 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *threads = [NSMutableSet set];</div><div class="line">NSUInteger numberCount = self.numbers.count;</div><div class="line">NSUInteger threadCount = 4;</div><div class="line">for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;</div><div class="line">    NSUInteger offset = (count / threadCount) * i;</div><div class="line">    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);</div><div class="line">    NSRange range = NSMakeRange(offset, count);</div><div class="line">    NSArray *subset = [self.numbers subarrayWithRange:range];</div><div class="line">    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</div><div class="line">    [threads addObject:thread];</div><div class="line">    [thread start];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然，看起来这个多线程实现起来比较简单，但是呢，在实际的编码中，我们并不会采用这种方式来进行，并发编程。</p>
<p>这种方式，其实是我们自己来操作线程，进行并发编程，这样就涉及到一个问题，例如，我们在使用到AFNetworking 进行网络访问的时候，本身AF中已经对网络访问进行了异步的线程处理，如果我们在调用AF的时候，再次进行并发线程处理，那么我们使用NSThread这种方式进行并发编程的时候，就回造成线程的指数级增长，因为我们操作的都是单个的线程。开了这么多的线程，当然会造成内存和CPU的高度浪费，而且会造成其他的一些不必要的bug。</p>
<p>那正确的并发编程 的姿势 是什么，当然是  GCD 和 operation queue ——基于队列的并发编程。这两种方式，通过管理一个被大家协同使用的线程池，来解决上面的问题。</p>
<h4 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch(GCD)"></a>Grand Central Dispatch(GCD)</h4><p>通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个线程池。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p>
<p>GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</p>
<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-14-gcd-queues.png" alt=""></p>
<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p>
<p><strong>稍后我们将详细介绍GCD的使用</strong></p>
<h4 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h4><p>操作队列是Apple在GCD之上，实现了一些更方便的功能，更高级的AP，这些功能对于开发者来讲通常来说，是最安全的最好的选择。</p>
<p>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。</p>
<p>你可以通过重写 main 或者 start 方法 来定义自己的 operations 。前一种方法非常简单，开发者不需要管理一些状态属性（例如 isExecuting 和 isFinished），当 main 方法返回的时候，这个 operation 就结束了。这种方式使用起来非常简单，但是灵活性相对重写 start 来说要少一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@implementation YourOperation</div><div class="line">    - (void)main</div><div class="line">    &#123;</div><div class="line">        // 进行处理 ...</div><div class="line">    &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你希望拥有更多的控制权，以及在一个操作中可以执行异步任务，那么就重写 start 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@implementation YourOperation</div><div class="line">    - (void)start</div><div class="line">    &#123;</div><div class="line">        self.isExecuting = YES;</div><div class="line">        self.isFinished = NO;</div><div class="line">        // 开始处理，在结束时应该调用 finished ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (void)finished</div><div class="line">    &#123;</div><div class="line">        self.isExecuting = NO;</div><div class="line">        self.isFinished = YES;</div><div class="line">    &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。</p>
<p>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 isCancelled 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)main</div><div class="line">&#123;</div><div class="line">    while (notDone &amp;&amp; !self.isCancelled) &#123;</div><div class="line">        // 进行处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">YourOperation *operation = [[YourOperation alloc] init];</div><div class="line">[queue  addOperation:operation];</div></pre></td></tr></table></figure>
<p>另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</div><div class="line">    // 代码...</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>虽然通过这种的方式在队列中添加操作会非常方便，但是定义你自己的 NSOperation 子类会在调试时很有帮助。如果你重写 operation 的description 方法，就可以很容易的标示出在某个队列中当前被调度的所有操作 。</p>
<p>除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。</p>
<p>另外还有一个方便的功能就是根据队列中 operation 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[intermediateOperation addDependency:operation1];</div><div class="line">[intermediateOperation addDependency:operation2];</div><div class="line">[finishedOperation addDependency:intermediateOperation];</div></pre></td></tr></table></figure>
<p>这些简单的代码可以确保 operation1 和 operation2 在 intermediateOperation 之前执行，当然，也会在 finishOperation 之前被执行。对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。</p>
<p>从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。</p>
<p>参考：</p>
<p><a href="https://www.objccn.io/issue-2-1/" target="_blank" rel="external">https://www.objccn.io/issue-2-1/</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程，这个我们听起来再熟悉不过了，我们在代码编写过程中也经常会做这样一些操作，但是我发现，在实际的编写过程中，很多实用并发编程的方式，其实是错误使用的，当然这也包括我自己，对一些并发编程也是糊里糊涂，今天的工作中涉及到了许多的并发方面的问题，专门抽时间去学习了一下，现在记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS中的并发编程" scheme="http://ppsheep.com/all-categories/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS中的并发编程" scheme="http://ppsheep.com/all-tags/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UITableViewController子控制器的使用方法</title>
    <link href="http://ppsheep.com/2016/12/14/UITableViewController%E5%AD%90%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://ppsheep.com/2016/12/14/UITableViewController子控制器的使用方法/</id>
    <published>2016-12-14T02:24:25.000Z</published>
    <updated>2017-02-15T04:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中  我们讲了通过整合tableview的代理，来达到代码复用，减少控制器代码量的效果，今天我们接着来讲另外的一些方法来减轻控制器代码量，整合封装，提高代码的可读性。</p>
<a id="more"></a>
<h3 id="UITableViewController的使用"><a href="#UITableViewController的使用" class="headerlink" title="UITableViewController的使用"></a>UITableViewController的使用</h3><p>TableView在iOS应用程序中是非常通用的组件，Apple为我们提供了tableview专属的view controller类UITableViewController。Table view controller实现了一些非常有用的特性，来避免一遍又一遍的写那些死板的代码！</p>
<p>但是，我们经常会遇到这样一个问题，table view controller 只限于管理一个全屏展示的table view。大多数情况下，我们想达到的效果就是这样，但是如果不是呢，我们就只能使用通常的控制器，其实还有其他的方法来达到使用table view controller 的目的。</p>
<h4 id="UITableViewController的特性"><a href="#UITableViewController的特性" class="headerlink" title="UITableViewController的特性"></a>UITableViewController的特性</h4><p>Table view controllers 会在第一次显示 table view 的时候帮你加载其数据。另外，它还会帮你切换 table view 的编辑模式、响应键盘通知、以及一些小任务，比如闪现侧边的滑动提示条和清除选中时的背景色。为了让这些特性生效，当你在子类中覆写类似 viewWillAppear: 或者 viewDidAppear: 等事件方法时，需要调用 super 版本。</p>
<p>Table view controllers 相对于标准 view controllers 的一个特别的好处是它支持 Apple 实现的“下拉刷新”。目前，文档中唯一的使用 UIRefreshControl 的方式就是通过 table view controller ，虽然通过努力在其他地方也能让它工作（例如直接将UIRefreshControl直接addSubView到tableview），但很可能在下一次 iOS 更新的时候就不行了。</p>
<p>这些要素加一起，为我们提供了大部分 Apple 所定义的标准 table view 交互行为，如果你的应用恰好符合这些标准，那么直接使用 table view controllers 来避免写那些死板的代码是个很好的方法。</p>
<h4 id="UITableViewController的限制"><a href="#UITableViewController的限制" class="headerlink" title="UITableViewController的限制"></a>UITableViewController的限制</h4><p>Table view controllers 的 view 属性永远都是一个 table view。如果你稍后决定在 table view 旁边显示一些东西（比如一个地图，一个小的按钮），如果不依赖于那些奇怪的 hacks，估计就没什么办法了。</p>
<p>如果你是用代码或 .xib 文件来定义的界面，那么迁移到一个标准 view controller 将会非常简单。但是如果你使用了 storyboards，那么这个过程要多包含几个步骤。除非重新创建，否则你并不能在 storyboards 中将 table view controller 改成一个标准的 view controller。这意味着你必须将所有内容拷贝到新的 view controller，然后再重新连接一遍。</p>
<p>最后，你需要把迁移后丢失的 table view controller 的特性给补回来。大多数都是 viewWillAppear: 或 viewDidAppear: 中简单的一条语句。切换编辑模式需要实现一个 action 方法，用来切换 table view 的 editing 属性。大多数工作来自重新创建对键盘的支持。</p>
<p>在选择这条路之前，其实还有一个更轻松的选择，它可以通过分离我们需要关心的功能（关注点分离），让你获得额外的好处：</p>
<h4 id="使用-Child-View-Controllers"><a href="#使用-Child-View-Controllers" class="headerlink" title="使用 Child View Controllers"></a>使用 Child View Controllers</h4><p>和完全抛弃 table view controller 不同，你还可以将它作为 child view controller 添加到其他 view controller 中。这样，parent view controller 在管理其他的你需要的新加的界面元素的同时，table view controller 还可以继续管理它的 table view。</p>
<p>我们来看代码：</p>
<p>我有一个UITableViewController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface MyTableViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyTableViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;cell&quot;];</div><div class="line">    self.refreshControl = [[UIRefreshControl alloc] initWithFrame:CGRectMake(0, 0, 20, 20)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Table view data source</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line"></div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line"></div><div class="line">    return 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    cell.textLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row];</div><div class="line">    </div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想要使用这个UITableViewController来管理我的tableview</p>
<p>然后  我还有一个view controller，在这个view controller中  我既要包含这个table view  还要有其他的view  用上面的加自controller来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self addMyTableViewController];</div><div class="line">    [self addOtherView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//添加zicontroller</div><div class="line">- (void)addMyTableViewController&#123;</div><div class="line">    MyTableViewController *vc = [[MyTableViewController alloc] init];</div><div class="line">    [self addChildViewController:vc];</div><div class="line">    CGRect frame = self.view.bounds;</div><div class="line">    frame.size.height = 300;</div><div class="line">    vc.view.frame = frame;</div><div class="line">    [self.view addSubview:vc.view];</div><div class="line">    [vc didMoveToParentViewController:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addOtherView&#123;</div><div class="line">    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(20, 400, 100, 30)];</div><div class="line">    btn.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:btn];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-14-032856.jpg" alt=""></p>
<p>如果我们使用了这种方法，那么我们就需要在子controller 和 父 controller之间建立起通信渠道，因为，如果点击了cell，在父类中我需要知道，虽然这样看起来是额外的开销，但是我们的代码变得非常清晰，复用性也更高</p>
<p>我们怎样建立起通信呢，当然最简单的就是使用delegate，这个就比较简单的了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@protocol MyTableViewControllerDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)didSelectCell;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface MyTableViewController : UITableViewController</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;MyTableViewControllerDelegate&gt; delegate;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>传递点击事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    if ([self.delegate respondsToSelector:@selector(didSelectCell)]) &#123;</div><div class="line">        [self.delegate didSelectCell];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在父controller中捕获点击事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyTableViewController *vc = [[MyTableViewController alloc] init];</div><div class="line">vc.delegate = self;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)didSelectCell&#123;</div><div class="line">    NSLog(@&quot;点击&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在cell内部控制cell的状态"><a href="#在cell内部控制cell的状态" class="headerlink" title="在cell内部控制cell的状态"></a>在cell内部控制cell的状态</h3><p>如果我们想自定义cell内部的状态，在点击cell的时候  自定义高亮样式 我们知道有这样的delegate方法，让我们在view controller中操作，但是我们要讲的就是减少view controller的代码</p>
<p>首先我们来看看在view controller 中 怎样来改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView</div><div class="line">        didHighlightRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">   //高亮时</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tableView:(UITableView *)tableView</div><div class="line">        didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    //非高亮</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View 的实现细节和 delegate 的实现交织在一起了。我们应该把这些细节移到 cell 自身中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123;</div><div class="line">    [super setHighlighted:highlighted animated:animated];</div><div class="line">    if (highlighted) &#123;</div><div class="line">        //高亮时改变cell的状态</div><div class="line">    &#125;else&#123;</div><div class="line">        //非高亮时改变</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Table view controllers（以及其他的 controller 对象！）应该在 model 和 view 对象之间扮演协调者和调解者的角色。它不应该关心明显属于 view 层或 model 层的任务。你应该始终记住这点，这样 delegate 和 data source 方法会变得更小巧，最多包含一些简单的样板代码。</p>
<p>这不仅减少了 table view controllers 那样的大小和复杂性，而且还把业务逻辑和 view 的逻辑放到了更合适的地方。Controller 层的里里外外的实现细节都被封装成了简单的 API，最终，它变得更加容易理解，也更利于团队协作。</p>
<p>参考:</p>
<p><a href="https://www.objccn.io/issue-1-2/" target="_blank" rel="external">https://www.objccn.io/issue-1-2/</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中  我们讲了通过整合tableview的代理，来达到代码复用，减少控制器代码量的效果，今天我们接着来讲另外的一些方法来减轻控制器代码量，整合封装，提高代码的可读性。&lt;/p&gt;
    
    </summary>
    
      <category term="ViewController" scheme="http://ppsheep.com/all-categories/ViewController/"/>
    
    
      <category term="ViewController" scheme="http://ppsheep.com/all-tags/ViewController/"/>
    
  </entry>
  
  <entry>
    <title>Runtime简单应用</title>
    <link href="http://ppsheep.com/2016/12/10/Runtime%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://ppsheep.com/2016/12/10/Runtime简单应用/</id>
    <published>2016-12-10T02:48:34.000Z</published>
    <updated>2017-02-16T06:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一篇文章，我们讲解了Runtime的一些基础知识，接下来，我会讲一些怎么来运用这种Runtime机制，用到实际的编码中，有哪些情况下，我们需要用到这种机制</p>
<a id="more"></a>
<h3 id="关联对象的应用"><a href="#关联对象的应用" class="headerlink" title="关联对象的应用"></a>关联对象的应用</h3><p>一般的，我们都在类声明中添加属性，但是出于某种原因，我们需要在分类中添加属性，但是分类中只能添加方法，不能添加属性，这时候我们Runtime就起到关键性作用了</p>
<p>Runtime提供了三个方法来设置关联对象</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置关联对象 </span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</div><div class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>);</div><div class="line"><span class="comment">//获取关联对象</span></div><div class="line">OBJC_EXPORT <span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</div><div class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>);</div><div class="line"><span class="comment">//移除关联对象</span></div><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</div><div class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>);</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">//参数解释</span></div><div class="line"><span class="keyword">id</span> object 被关联的对象</div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *key 关联的key 必须唯一</div><div class="line"><span class="keyword">id</span> value 关联的对象</div><div class="line">objc_AssociationPolicy policy 关联策略</div><div class="line"></div><div class="line"><span class="comment">//其中的关联策略就相当于我们的property中的copy assign之类的</span></div><div class="line">OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div></pre></td></tr></table></figure>
<h6 id="添加公共属性"><a href="#添加公共属性" class="headerlink" title="添加公共属性"></a>添加公共属性</h6><p>两种解决办法：</p>
<ol>
<li>继承NSArray，在子类中添加一个属性</li>
<li>使用分类，利用Runtime实现添加属性</li>
</ol>
<p>我们举例第二种：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">PPS</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *myString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"NSArray+PPS.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> MY_STRING = <span class="string">"my_string"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">PPS</span>)</span></div><div class="line"></div><div class="line">-(<span class="built_in">NSString</span> *)myString&#123;</div><div class="line">    <span class="keyword">id</span> myString = objc_getAssociatedObject(<span class="keyword">self</span>, MY_STRING);</div><div class="line">    <span class="keyword">return</span> myString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setMyString:(<span class="built_in">NSString</span> *)myString&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, MY_STRING, myString, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样，我们可以直接用点语法，对属性直接操作</p>
<h5 id="添加私有成员变量"><a href="#添加私有成员变量" class="headerlink" title="添加私有成员变量"></a>添加私有成员变量</h5><p>给按钮添加点击事件的回调，不用addtarget的方式</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">PPS</span>)</span></div><div class="line"><span class="comment">//传入点击事件的回调</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame callback:(<span class="keyword">void</span> (^)(<span class="built_in">UIButton</span> *button))callbackBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIButton+PPS.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> * <span class="built_in">CALLBACK_BLOCK_IDENTIFER</span> = <span class="string">"CALLBACK_BLOCK_IDENTIFER"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span>()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^callbackBlock)(<span class="built_in">UIButton</span> * button);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">PPS</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span> (^)(<span class="built_in">UIButton</span> *))callbackBlock &#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">CALLBACK_BLOCK_IDENTIFER</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setCallbackBlock:(<span class="keyword">void</span> (^)(<span class="built_in">UIButton</span> *))callbackBlock &#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">CALLBACK_BLOCK_IDENTIFER</span>, callbackBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame callback:(<span class="keyword">void</span> (^)(<span class="built_in">UIButton</span> *))callbackBlock &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        <span class="keyword">self</span>.callbackBlock = callbackBlock;</div><div class="line">        [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(didClickAction:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didClickAction:(<span class="built_in">UIButton</span> *)button &#123;</div><div class="line">    <span class="comment">//想想这里为什么需要使用weak一下</span></div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    weakSelf.callbackBlock(button);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们在初始化button的时候,可以直接处理点击事件</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.btn = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>) callback:^(<span class="built_in">UIButton</span> *button) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"点击事件"</span>);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h3 id="成员变量和属性"><a href="#成员变量和属性" class="headerlink" title="成员变量和属性"></a>成员变量和属性</h3><p>这个的使用，运用最广泛的还是在json和model的转换，我们可以通过Runtime机制，将model中的所有成员属性都找出来，然后将这些成员属性的名称和返回的json字典中对比，查看有哪些匹配，然后纷纷赋值进去</p>
<h6 id="json转model"><a href="#json转model" class="headerlink" title="json转model"></a>json转model</h6><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithDict:(<span class="built_in">NSDictionary</span> *)dict &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</div><div class="line">        <span class="comment">//(1)获取类的属性及属性对应的类型</span></div><div class="line">        <span class="built_in">NSMutableArray</span> * keys = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        <span class="built_in">NSMutableArray</span> * attributes = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 例子</div><div class="line">         * name = value3 attribute = T@"NSString",C,N,V_value3</div><div class="line">         * name = value4 attribute = T^i,N,V_value4</div><div class="line">         */</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</div><div class="line">        objc_property_t * properties = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">            objc_property_t property = properties[i];</div><div class="line">            <span class="comment">//通过property_getName函数获得属性的名字</span></div><div class="line">            <span class="built_in">NSString</span> * propertyName = [<span class="built_in">NSString</span> stringWithCString:property_getName(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            [keys addObject:propertyName];</div><div class="line">            <span class="comment">//通过property_getAttributes函数可以获得属性的名字和@encode编码</span></div><div class="line">            <span class="built_in">NSString</span> * propertyAttribute = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            [attributes addObject:propertyAttribute];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//立即释放properties指向的内存</span></div><div class="line">        free(properties);</div><div class="line"></div><div class="line">        <span class="comment">//(2)根据类型给属性赋值</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> * key <span class="keyword">in</span> keys) &#123;</div><div class="line">            <span class="keyword">if</span> ([dict valueForKey:key] == <span class="literal">nil</span>) <span class="keyword">continue</span>;</div><div class="line">            [<span class="keyword">self</span> setValue:[dict valueForKey:key] forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然这上面只是最简单的转换，其中还有很多问题待解决</p>
<p>如何识别int等基础类型数据<br>如何处理nil和Null<br>json嵌套如何处理</p>
<h5 id="访问私有变量"><a href="#访问私有变量" class="headerlink" title="访问私有变量"></a>访问私有变量</h5><p>我们知道，如果成员变量放在了m文件中，就成了私有变量，但是我们依然可以通过Runtime获取，这时候，我们就需要知道成员变量的名称了</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar ivar = class_getInstanceVariable([Model <span class="keyword">class</span>], <span class="string">"_str1"</span>);</div><div class="line"><span class="built_in">NSString</span> * str1 = object_getIvar(model, ivar);</div></pre></td></tr></table></figure>
<p>OC没有绝对的私有变量和方法，方法当然也可以这样获取出来</p>
<p>抛砖引玉，到此。。。</p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的一篇文章，我们讲解了Runtime的一些基础知识，接下来，我会讲一些怎么来运用这种Runtime机制，用到实际的编码中，有哪些情况下，我们需要用到这种机制&lt;/p&gt;
    
    </summary>
    
      <category term="Runtime" scheme="http://ppsheep.com/all-categories/Runtime/"/>
    
    
      <category term="Runtime" scheme="http://ppsheep.com/all-tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>分离UITableView数据源和协议</title>
    <link href="http://ppsheep.com/2016/12/05/%E5%88%86%E7%A6%BBUITableView%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://ppsheep.com/2016/12/05/分离UITableView数据源和协议/</id>
    <published>2016-12-05T14:29:37.000Z</published>
    <updated>2017-02-15T04:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>View controllers 通常是 iOS 项目中最大的文件，并且它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率最低的。接下来我将结合一些我自己看到的东西和平时在使用的方法，来节省ViewController中的代码量。</p>
<a id="more"></a>
<h3 id="把-Data-Source-和其他-Protocols-分离出来"><a href="#把-Data-Source-和其他-Protocols-分离出来" class="headerlink" title="把 Data Source 和其他 Protocols 分离出来"></a>把 Data Source 和其他 Protocols 分离出来</h3><p>我们在平时的编码中，最经常使用到的一个控件就是UITableView了，那我们每次需要使用到tableview的时候，都需要写一些重复的代码，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#pragma mark - tableview datasource</div><div class="line"></div><div class="line">#pragma mark - tableview datasource</div><div class="line"></div><div class="line">- (PPSFriend *)friendAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    return self.friends[indexPath.row];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    return self.friends.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    PPSFriendCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;friendCell&quot; forIndexPath:indexPath];</div><div class="line">    PPSFriend *friend = [self friendAtIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = friend.name;</div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面一些代码，我们每天都在写，每次用到UITableView都需要重写这些毫无技术可言的代码，那我们试想一下能否写一个封装类，将这些重复的方法全部封起来，多次使用呢？答案当然是，可以的。</p>
<p>上面的代码，其实都是在围绕着friends这个数组做一系列的事情，我们可以独立出来一个类，使用一个block或者delegate来设置cell，当然这取决于你的习惯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#pragma mark - tableview config cell</div><div class="line">- (void)configCell&#123;</div><div class="line">    void (^configCell)(PPSFriendCell *, PPSFriend *) = ^(PPSFriendCell *cell, PPSFriend *friend)&#123;</div><div class="line">        cell.textLabel.text = friend.name;</div><div class="line">    &#125;;</div><div class="line">    PPSArrayDatasource *datasources = [[PPSArrayDatasource alloc] initWithItems:self.friends cellIdentifier:@&quot;friendCell&quot; configureCellBlock:configCell];</div><div class="line">    self.tableView.dataSource = datasources;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，你可以把 view controller 中的这 3 个方法去掉了，取而代之，你可以创建一个 PPSArrayDatasource 类的实例作为 table view 的 data source。</p>
<p>现在你不用担心把一个 index path 映射到数组中的位置了，每次你想把这个数组显示到一个 table view 中时，你都可以复用这些代码。你也可以实现一些额外的方法，比如 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tableView:commitEditingStyle:forRowAtIndexPath:</div></pre></td></tr></table></figure>
<h4 id="多个section"><a href="#多个section" class="headerlink" title="多个section"></a>多个section</h4><p>还有一种情况，如果是多个section的情况下，我们还可以再扩展一下，将block定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef void(^TableViewCellConfigureBlock)(id cell, id item, NSIndexPath *indexPath);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#pragma mark - tableview config cell</div><div class="line">- (void)configCell&#123;</div><div class="line">    void (^configCell)(PPSFriendCell *, PPSFriend *, NSIndexPath *) = ^(PPSFriendCell *cell, PPSFriend *friend, NSIndexPath *indexPath)&#123;</div><div class="line">        cell.textLabel.text = friend.name;</div><div class="line">    &#125;;</div><div class="line">    PPSArrayDatasource *datasources = [[PPSArrayDatasource alloc] initWithItems:self.friends cellIdentifier:@&quot;friendCell&quot; configureCellBlock:configCell];</div><div class="line">    self.tableView.dataSource = datasources;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么在PPSArrayDatasource的items中装的应该就是一个一个的数组了，分别对应的每个section，这里我只是针对这种情况说明一下，不管是多个section还是单个section都可以使用这种方法，来瘦身</p>
<p>在 table view controllers 之间共享。</p>
<p>这样的好处在于，你可以单独测试这个类，再也不用写第二遍。该原则同样适用于数组之外的其他对象。</p>
<h3 id="将业务逻辑移到model中"><a href="#将业务逻辑移到model中" class="headerlink" title="将业务逻辑移到model中"></a>将业务逻辑移到model中</h3><p>下面是在viewcontroller中写的用来查找一个用户的目前的优先事项的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)loadPriorities &#123;</div><div class="line">    NSDate* now = [NSDate date];</div><div class="line">    NSString* formatString = @&quot;startDate = %@&quot;;</div><div class="line">    NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];</div><div class="line">    NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate];</div><div class="line">    self.priorities = [priorities allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把这些代码移动到 User 类的 category 中会变得更加清晰，处理之后，在 View Controller.m 中看起来就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)loadPriorities &#123;</div><div class="line">    self.priorities = [user currentPriorities];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 User+Extensions.m 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSArray*)currentPriorities &#123;</div><div class="line">    NSDate* now = [NSDate date];</div><div class="line">    NSString* formatString = @&quot;startDate = %@&quot;;</div><div class="line">    NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];</div><div class="line">    return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些代码不能被轻松地移动到 model 对象中，但明显和 model 代码紧密联系，对于这种情况，我们可以使用一个 Store：</p>
<h3 id="创建store类"><a href="#创建store类" class="headerlink" title="创建store类"></a>创建store类</h3><p>在一些情况下中，我们需要加载文件并解析它。下面就是 view controller 中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)readArchive &#123;</div><div class="line">    NSBundle* bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">    NSURL *archiveURL = [bundle URLForResource:@&quot;photodata&quot;</div><div class="line">                                 withExtension:@&quot;bin&quot;];</div><div class="line">    NSAssert(archiveURL != nil, @&quot;Unable to find archive in bundle.&quot;);</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:archiveURL</div><div class="line">                                         options:0</div><div class="line">                                           error:NULL];</div><div class="line">    NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</div><div class="line">    _users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;users&quot;];</div><div class="line">    _photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;photos&quot;];</div><div class="line">    [unarchiver finishDecoding];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是 view controller 没必要知道这些，所以我们可以创建了一个 Store 对象来做这些事。通过分离，我们就可以复用这些代码，单独测试他们，并且让 view controller 保持小巧。Store 对象会关心数据加载、缓存和设置数据栈。它也经常被称为服务层或者仓库。</p>
<h3 id="把网络层请求逻辑移到model层"><a href="#把网络层请求逻辑移到model层" class="headerlink" title="把网络层请求逻辑移到model层"></a>把网络层请求逻辑移到model层</h3><p>和上面的主题相似：不要在 view controller 中做网络请求的逻辑。取而代之，你应该将它们封装到另一个类中。这样，你的 view controller 就可以在之后通过使用回调（比如一个 completion 的 block）来请求网络了。这样的好处是，缓存和错误控制也可以在这个类里面完成。</p>
<h3 id="把View移到View层"><a href="#把View移到View层" class="headerlink" title="把View移到View层"></a>把View移到View层</h3><p>不应该在 view controller 中构建复杂的 view 层次结构。你可以使用 Interface Builder 或者把 views 封装到一个 UIView 子类当中。例如，如果你要创建一个选择日期的控件，把它放到一个名为 DatePickerView 的类中会比把所有的事情都在 view controller 中做好好得多。再一次，这样增加了可复用性并保持了简单。</p>
<p>简单来说，就是将一个viewcontroller中复杂的view构造，放到一个单独的view类中，然在viewcontroller中，只需要构建一个这个类就行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们已经看到一些用来创建更小巧的 view controllers 的技术。我们并不是想把这些技术应用到每一个可能的角落，只是我们有一个目标：写可维护的代码。知道这些模式后，我们就更有可能把那些笨重的 view controllers 变得更整洁。</p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;View controllers 通常是 iOS 项目中最大的文件，并且它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率最低的。接下来我将结合一些我自己看到的东西和平时在使用的方法，来节省ViewController中的代码量。&lt;/p&gt;
    
    </summary>
    
      <category term="ViewController" scheme="http://ppsheep.com/all-categories/ViewController/"/>
    
    
      <category term="ViewController" scheme="http://ppsheep.com/all-tags/ViewController/"/>
    
  </entry>
  
  <entry>
    <title>Swift谈一谈</title>
    <link href="http://ppsheep.com/2016/10/28/swift%E8%B0%88%E4%B8%80%E8%B0%88/"/>
    <id>http://ppsheep.com/2016/10/28/swift谈一谈/</id>
    <published>2016-10-28T03:48:07.000Z</published>
    <updated>2017-02-15T05:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 3发布已经有一段时间了，如果已经有同学在使用Swift，那么从2.3迁移到3.0，我想肯定是极其痛苦的，在ABI稳定性方面，2.x和3.0相比，有较大的改动。不过，苹果官方宣布，在将来的Swift 3到Swift 4，会保持ABI稳定，那么也就是意味着，Swift的ABI相对稳定了，那此时是否就是正式投入Swift的时间了，其实呢，这个还是看自己。 在我自己的平时工作中，主要还是使用的OC，因为毕竟需要合作，不能说你用，大家都要跟着你用，不过这也是一个大的趋势，使用Swift的开发者越来越多，称赞Swift的开发者也是越来越多，那我自己内心也是想开搞的，虽说不会及时使用到工作中，自己玩玩也是可以的。其实现在开始已经相对较晚了。</p>
<a id="more"></a>
<h3 id="我对Swift的"><a href="#我对Swift的" class="headerlink" title="我对Swift的"></a>我对Swift的</h3><p>Swift 我一直在尝试，但是却因为工作上，没有将它考虑在内，所以一直都停止在尝试。结合到我现在的工作环境，我觉得在将来很长的一段时间内，它还是不会加入到我的工作中来，但是我在想，我需要改变我对他的态度的。如果不作出改变的话，我将一直停留在  只知道他的拼写而已，其他的一无所知。</p>
<p>在Swift 3发布之时，苹果宣布，将在2017年春节之时发布3.x , 4.0也将在2017年秋季发布，我们看到了苹果对于Swift所作出的努力，那我们作为开发者，是否也应该作出一些努力。</p>
<h3 id="我对Swift的学习规划"><a href="#我对Swift的学习规划" class="headerlink" title="我对Swift的学习规划"></a>我对Swift的学习规划</h3><p>之前我大致浏览过swift2.0 官方教程的  中译版<br><a href="http://www.swiftguide.cn" target="_blank" rel="external">http://www.swiftguide.cn</a></p>
<p>至于我还记得多少，嘿嘿嘿。。。你猜。。。</p>
<p>所以我打算呢，还是再过一遍官方的教程，这次呢，我不打算看中译版了，我还是去iBook上看原版吧。顺便提一句，现在国内iBook已经不可用了，你需要上美国的商店，才能找到官方的教程，这个嘛，可以申请一个美国的账号咯，至于方法，Google一下，或者 国内某大型搜索引擎网站，搜索一下。不过好像之前我有同事去搜过，好像现在不行了，一定要求绑定支付方式，最后他一怒之下，某宝了一个，哈哈哈哈，笑死我了。。。</p>
<p>如果你们有需要，可以联系我，我直接发你们一份，我就不直接放上来了。。。我的联系方式，我放了微信上来的，我记得，在关于我里面。</p>
<h3 id="Swift-你来吗？"><a href="#Swift-你来吗？" class="headerlink" title="Swift 你来吗？"></a>Swift 你来吗？</h3><p>后面我也将会把我的学习过程放到博客上来，你要一起来吗? 对了，我还在Objc中国上面买了几本Swift的书，那些书可真是不错，为什么说不错，因为我现在看不懂，看不懂，我就觉得他们写的很好，要是我现在就看得懂，那还学个屁！！！建议呢，这些书，可以在看完官方教程后，再来阅读，喵神维护的网站，还是很不错的，上面还有很多之前从objc.io翻译过来的博客，质量都很高的，有时间也可以阅读。</p>
<h3 id="关于之前博客停更的说明"><a href="#关于之前博客停更的说明" class="headerlink" title="关于之前博客停更的说明"></a>关于之前博客停更的说明</h3><p>最近几周，博客更新都很慢，主要原因呢，是要赶两个SDK，说来话长，某一天，我的领导不想跟我讲话，并向我扔出了2个SDK，然后我就傻逼了，并且还甩出了多少天拿出来，这样的话，期间呢，还到广州出差了一周，是的，你没听错，我，一个程序员，也出差了！！！我是昨天刚回到杭州，在出差期间呢，也是能挤出一点时间来更新一下，但是呢，你知道吗？广州的茶点心，真是不错，剩余时间，全部拿出来，去吃了，真是不好意思，可惜没有怎么拍照片，下次去了，一定拍几张照片发上来。</p>
<p>废话讲完了，一不小心，打了这么多字！！！！尴尬</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 3发布已经有一段时间了，如果已经有同学在使用Swift，那么从2.3迁移到3.0，我想肯定是极其痛苦的，在ABI稳定性方面，2.x和3.0相比，有较大的改动。不过，苹果官方宣布，在将来的Swift 3到Swift 4，会保持ABI稳定，那么也就是意味着，Swift的ABI相对稳定了，那此时是否就是正式投入Swift的时间了，其实呢，这个还是看自己。 在我自己的平时工作中，主要还是使用的OC，因为毕竟需要合作，不能说你用，大家都要跟着你用，不过这也是一个大的趋势，使用Swift的开发者越来越多，称赞Swift的开发者也是越来越多，那我自己内心也是想开搞的，虽说不会及时使用到工作中，自己玩玩也是可以的。其实现在开始已经相对较晚了。&lt;/p&gt;
    
    </summary>
    
      <category term="扯淡" scheme="http://ppsheep.com/all-categories/%E6%89%AF%E6%B7%A1/"/>
    
    
      <category term="扯淡" scheme="http://ppsheep.com/all-tags/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画实践三(UIView的动画你真的会用吗？)</title>
    <link href="http://ppsheep.com/2016/08/20/iOS%E5%8A%A8%E7%94%BB%E5%AE%9E%E8%B7%B5%E4%B8%89-UIView%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97/"/>
    <id>http://ppsheep.com/2016/08/20/iOS动画实践三-UIView的动画你真的会用吗/</id>
    <published>2016-08-20T02:31:53.000Z</published>
    <updated>2017-02-15T05:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这一节中，我们继续讲解UIView中的一些动画的使用，之前已经讲过了基础的用法，和spring动画的用法，在这一节中，我们将要介绍Transitions，也是一个我们经常使用到的动画</p>
<a id="more"></a>
<p>首先我们把上次的工程打开，没看上一篇文章的同学，请移步</p>
<p><a href="http://ppsheep.com/2017/01/22/iOS动画实践二-UIView的动画你真的会用吗/">http://ppsheep.com/2017/01/22/iOS动画实践二-UIView的动画你真的会用吗/</a></p>
<h3 id="加入、移除、隐藏-view的动画"><a href="#加入、移除、隐藏-view的动画" class="headerlink" title="加入、移除、隐藏 view的动画"></a>加入、移除、隐藏 view的动画</h3><p>我们知道Transitions的意思是一个过渡动画、转变动画，但是具体什么效果，我们还是不知道，接下来，我们先来看看这个动画是一个什么要样的效果？</p>
<p>首先我们创建一个animationContainerView，这个就是做动画的view，为什么叫做ContainerView，因为我们还要在这个view中放上其他的一些控件一起来做动画</p>
<p>我们将其他的控件先隐藏掉，加入动画的view看看，是什么效果</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">animationContainerView = <span class="type">UIView</span>(frame: view.bounds)</div><div class="line">animationContainerView?.frame = view.bounds</div><div class="line">view.addSubview(animationContainerView!)</div></pre></td></tr></table></figure>
<p>然后再viewDidAppear方法中，做一个transition动画</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newView = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(named: <span class="string">"banner"</span>))</div><div class="line">newView.center  = animationContainerView!.center</div><div class="line"><span class="type">UIView</span>.transition(with: animationContainerView!, duration: <span class="number">0.83</span>, options: [.curveEaseOut,.transitionFlipFromTop], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.animationContainerView?.addSubview(newView)</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>好我们来看看效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-2.gif" alt=""></p>
<p>我故意将动画放的很慢，这样效果就能够更明显，这里这个option有很多种效果，我就不全部展示了，这里我提两个比较不一样的</p>
<h4 id="transitionCrossDissolve"><a href="#transitionCrossDissolve" class="headerlink" title="transitionCrossDissolve"></a>transitionCrossDissolve</h4><p>这是一个渐渐显示的一个效果</p>
<p>将option参数换掉就行，还是直接看效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-3.gif" alt=""></p>
<p>可能模拟器的动画效果不是那么明显，大家可以自己手动实验一下</p>
<h4 id="transitionCurlUp-这个是整个一个view的一个效果"><a href="#transitionCurlUp-这个是整个一个view的一个效果" class="headerlink" title="transitionCurlUp 这个是整个一个view的一个效果"></a>transitionCurlUp 这个是整个一个view的一个效果</h4><p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-4.gif" alt=""></p>
<p>上面我都是使用的addsubview来做动画，要做移除view的动画，或者隐藏的动画，直接变换方法就行，具体的操作，我就不做了</p>
<h4 id="翻转效果"><a href="#翻转效果" class="headerlink" title="翻转效果"></a>翻转效果</h4><p>我们新创建一个VC-AnotherViewController</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="type">UIView</span>.transition(from: view, to: anotherVc.view , duration: <span class="number">1.0</span>, options: [.curveEaseInOut,.transitionFlipFromLeft]) &#123; (<span class="literal">true</span>) <span class="keyword">in</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一行代码就可以实现翻转效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-5.gif" alt=""></p>
<p>这种效果也是我们常见的</p>
<h3 id="登录动画"><a href="#登录动画" class="headerlink" title="登录动画"></a>登录动画</h3><p>接下来我们在我们之前做的登录页面上，加上一些Transitions的动画</p>
<p>说一下我想要实现的效果，当我们点击登录按钮的时候，有一个动画出现，显示当前的登录进度，就是这么一个简单的实现</p>
<p>一步一步来，首先，在点击按钮的时候，让label出现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先将lable加入到view中</span></div><div class="line">    <span class="comment">//动画的view</span></div><div class="line">    <span class="keyword">let</span> status = <span class="type">UIImageView</span>(image: <span class="type">UIImage</span>(named: <span class="string">"banner"</span>))</div><div class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>()</div><div class="line">    <span class="keyword">let</span> message = [<span class="string">"连接中..."</span>,<span class="string">"授权中..."</span>,<span class="string">"发送认证消息..."</span>,<span class="string">"认证失败..."</span>]</div><div class="line">    <span class="keyword">var</span> statusPosition = <span class="type">CGPoint</span>.zero</div></pre></td></tr></table></figure>
<p>在页面加载时将status隐藏起来</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先将label隐藏</span></div><div class="line">status.isHidden = <span class="literal">true</span></div><div class="line">status.center = loginBtn.center</div><div class="line">view.addSubview(status)</div><div class="line"></div><div class="line">label.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: status.frame.size.width, height: status.frame.size.height)</div><div class="line">label.textAlignment = .center</div><div class="line">label.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">18</span>)</div><div class="line">label.textColor = <span class="type">UIColor</span>.blue</div><div class="line">status.addSubview(label)</div><div class="line"></div><div class="line">statusPosition = status.center</div></pre></td></tr></table></figure>
<p>然后我们在点击的时候，调用方法 showMeesage</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMessage</span><span class="params">(index: Int)</span></span> &#123;</div><div class="line">    label.text = message[index]</div><div class="line">    <span class="type">UIView</span>.transition(with: status, duration: <span class="number">0.5</span>, options: [.curveEaseIn,.transitionFlipFromBottom], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.status.isHidden = <span class="literal">false</span></div><div class="line">    &#125;) &#123; (<span class="literal">true</span>) <span class="keyword">in</span></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是看一下效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-6.gif" alt=""></p>
<h4 id="加上动效"><a href="#加上动效" class="headerlink" title="加上动效"></a>加上动效</h4><p>现在连接的状态是出现了，但是这样它就不动了，我们想要这个状态不断更新，为了实现这样的操作，我们定义一个函数，这个函数是这样的，传入一个重复操作的间隔时间，再传入需要操作的方法，即一个闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A delay function</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(seconds: Double, completion:@escaping <span class="params">()</span></span></span>-&gt;()) &#123;</div><div class="line">  <span class="keyword">let</span> popTime = <span class="type">DispatchTime</span>.now() + <span class="type">Double</span>(<span class="type">Int64</span>( <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>) * seconds )) / <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>)</div><div class="line">  </div><div class="line">  <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: popTime) &#123;</div><div class="line">    completion()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法的意思是，每几秒钟执行一次completion，因为我们需要更新UI，所以这个completion必须要在主线程中执行</p>
<p>另外我们还需要一个移除状态的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeMessage</span><span class="params">(index: Int)</span></span> &#123;</div><div class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.0</span>, options: [], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.status.center.x += <span class="keyword">self</span>.view.bounds.size.width</div><div class="line">    &#125;) &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.status.isHidden = <span class="literal">true</span></div><div class="line">        <span class="keyword">self</span>.status.center = <span class="keyword">self</span>.statusPosition</div><div class="line">        </div><div class="line">        <span class="keyword">self</span> .showMessage(index: index+<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMessage</span><span class="params">(index: Int)</span></span> &#123;</div><div class="line">    label.text = message[index]</div><div class="line">    <span class="type">UIView</span>.transition(with: status, duration: <span class="number">0.5</span>, options: [.curveEaseIn,.transitionFlipFromBottom], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.status.isHidden = <span class="literal">false</span></div><div class="line">    &#125;) &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">        </div><div class="line">        delay(seconds: <span class="number">2</span>, completion: &#123; </div><div class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.message.<span class="built_in">count</span>-<span class="number">1</span> &#123;<span class="comment">//到了最后一条消息</span></div><div class="line">                <span class="keyword">self</span>.removeMessage(index: index)</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-24-7.gif" alt=""></p>
<p>好今天就讲到这里，马上要放假咯，收拾收拾，回家过年</p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这一节中，我们继续讲解UIView中的一些动画的使用，之前已经讲过了基础的用法，和spring动画的用法，在这一节中，我们将要介绍Transitions，也是一个我们经常使用到的动画&lt;/p&gt;
    
    </summary>
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-categories/iOS%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-tags/iOS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画实践二(UIView的动画你真的会用吗？)</title>
    <link href="http://ppsheep.com/2016/08/12/iOS%E5%8A%A8%E7%94%BB%E5%AE%9E%E8%B7%B5%E4%BA%8C-UIView%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97/"/>
    <id>http://ppsheep.com/2016/08/12/iOS动画实践二-UIView的动画你真的会用吗/</id>
    <published>2016-08-12T08:58:59.000Z</published>
    <updated>2017-02-15T05:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一章，是我们一个动手实现动画的开头，围绕上一章节的动画，我们再来接着实现这个登录页面的其他功能，我们今天要加上的是登录点击过后的一些效果</p>
<a id="more"></a>
<h3 id="给登录按钮加上动画"><a href="#给登录按钮加上动画" class="headerlink" title="给登录按钮加上动画"></a>给登录按钮加上动画</h3><p>我们之前给head和输入框都加上了动画，但是点击按钮还是没有出现动画的，我们接下来，给点击按钮加上动画</p>
<p>在登录按钮，我们就不使用像上面的那种效果了，我们换一种，UIView中的弹动效果</p>
<p>在按钮出现之前，我们将按钮的y值增加50，并且alpha设置为0.0</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">loginBtn.alpha = <span class="number">0.0</span></div><div class="line">loginBtn.center.y += <span class="number">30.0</span></div></pre></td></tr></table></figure>
<p>在将要出现时，我们对他使用动画</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.5</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0.0</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.loginBtn.center.y -= <span class="number">30.0</span></div><div class="line">    <span class="keyword">self</span>.loginBtn.alpha = <span class="number">1.0</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>这也是UIView自带的一种动画，其中的<br>usingSpringWithDamping代表抖动指数 0到1之间<br>initialSpringVelocity代表的是动画开始的初始速度</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-4.gif" alt=""></p>
<p>能够看到登录按钮有一个抖动的效果，为了效果能明显一点，我故意将值设置很大，在平时开发中，应该要和视觉商量</p>
<h3 id="按钮点击动画"><a href="#按钮点击动画" class="headerlink" title="按钮点击动画"></a>按钮点击动画</h3><p>我们在按钮上加上一个动画，在我们点击按钮的时候，让按钮变长一些，并且带有弹簧效果的变长</p>
<p>在按钮的点击事件上，加上</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//改变大小</span></div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">1.5</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.2</span>, initialSpringVelocity: <span class="number">0.0</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.loginBtn.bounds.size.width += <span class="number">80</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">//改变位置</span></div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.33</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.7</span>, initialSpringVelocity: <span class="number">0.0</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.loginBtn.center.y += <span class="number">60</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>这种动画效果，和我们刚刚改变按钮的位置的动画效果是一种，spring动画，并且这个在动画未执行完的时候，再次点击，并不会再次从头执行动画</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-9.gif" alt=""></p>
<h3 id="再加一朵菊花，加上一个按钮颜色变化"><a href="#再加一朵菊花，加上一个按钮颜色变化" class="headerlink" title="再加一朵菊花，加上一个按钮颜色变化"></a>再加一朵菊花，加上一个按钮颜色变化</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//菊花加到点击按钮上，先让他隐藏</span></div><div class="line">spinner.frame = <span class="type">CGRect</span>(x: -<span class="number">20.0</span>, y: <span class="number">6.0</span>, width: <span class="number">20.0</span>, height: <span class="number">20.0</span>)</div><div class="line">spinner.startAnimating()</div><div class="line">spinner.alpha = <span class="number">0.0</span></div><div class="line">loginBtn.addSubview(spinner)</div><div class="line"></div><div class="line"><span class="comment">//在按钮点击的时候，显示出来</span></div><div class="line"><span class="keyword">self</span>.spinner.center = <span class="type">CGPoint</span>(x: <span class="number">40.0</span>, y: <span class="keyword">self</span>.loginBtn.frame.size.height/<span class="number">2</span>)</div><div class="line"><span class="keyword">self</span>.spinner.alpha = <span class="number">1.0</span></div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-10.gif" alt=""></p>
<p>我们再将之前使用的delay的用户名和密码两个个元素改变一下，得到的效果又不一样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.3</span>, usingSpringWithDamping: <span class="number">0.2</span>, initialSpringVelocity: <span class="number">0.0</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.usernameTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.4</span>, usingSpringWithDamping: <span class="number">0.2</span>, initialSpringVelocity: <span class="number">0.0</span>, options: [], animations: &#123;</div><div class="line">    <span class="keyword">self</span>.passwordTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>其实，我们可以看出，想要做出简单的动画，其实并不难，主要是参数的使用和方法的使用</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-11.gif" alt=""></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章，是我们一个动手实现动画的开头，围绕上一章节的动画，我们再来接着实现这个登录页面的其他功能，我们今天要加上的是登录点击过后的一些效果&lt;/p&gt;
    
    </summary>
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-categories/iOS%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-tags/iOS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画实践一(UIView的动画你真的会用吗?)</title>
    <link href="http://ppsheep.com/2016/08/02/iOS%E5%8A%A8%E7%94%BB%E5%AE%9E%E8%B7%B5%E4%B8%80-UIView%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97/"/>
    <id>http://ppsheep.com/2016/08/02/iOS动画实践一-UIView的动画你真的会用吗/</id>
    <published>2016-08-02T06:58:15.000Z</published>
    <updated>2017-02-15T05:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是简单介绍了一些动画方面的属性之类的，一些基础概念，感觉效果并不是很好，我自己讲起来也觉得比较枯燥，更不要说让别人有兴趣看下去，接下来，在动画方面，尽量坚持实现一些实际的效果，这样看起来也舒服，也能在实践中用起来</p>
<a id="more"></a>
<p>我们今天做一个登录界面的动效，在我们进入登录界面时，登录框从左边飞出，并且登录界面还有云朵，渐渐出现。在这一个章节中，我们将介绍在UIView的动画中，option的不同效果。</p>
<h3 id="准备好做动画的界面"><a href="#准备好做动画的界面" class="headerlink" title="准备好做动画的界面"></a>准备好做动画的界面</h3><p>首先新建一个工程，做好如下的界面，界面的绘制，我就不讲了，到时候这个工程我会上传到github，素材可以直接去那里取的</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-072536.jpg" alt=""></p>
<h3 id="飞入的动画效果"><a href="#飞入的动画效果" class="headerlink" title="飞入的动画效果"></a>飞入的动画效果</h3><p>我们首先来实现的效果是让header “PPSheep Login” 首先飞入，然后username的输入框，密码的输入框随后飞入</p>
<p>在页面出现之前，我们不能够让这三个元素出现在界面上，首先，我们在viewWillApper方法中，在页面即将出现前，将三个元素移出界面</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line">    headingLabel.center.x -= view.bounds.width</div><div class="line">    usernameTextFiled.center.x -= view.bounds.width</div><div class="line">    passwordTextFiled.center.x -= view.bounds.width</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这样</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-073907.jpg" alt=""></p>
<p>然后我们就可以开始实现动画效果</p>
<p>在页面完全出现的时候，我们将三个元素从左挪至可视区域</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0</span>, options: [], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.headingLabel.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">        <span class="keyword">self</span>.usernameTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">        <span class="keyword">self</span>.passwordTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">    &#125;, completion: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下实现效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-iOSping%E5%B0%8F%E5%B7%A5%E5%85%B7.gif" alt=""></p>
<p>但是这样，看起来怪怪的，都是同时进入，我们想要分开一下，比如标题先进入，然后接着用户名，再接着密码。这个时候就需要用到方法中的一个delay参数，这个可以设置延迟多少时间执行</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0</span>, options: [], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.headingLabel.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">    &#125;, completion: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.5</span>, options: [], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.usernameTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">    &#125;, completion: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.7</span>, options: [], animations: &#123; </div><div class="line">        <span class="keyword">self</span>.passwordTextFiled.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">    &#125;, completion: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们使用了delay这个参数，来达到执行动画的先后顺序</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-2.gif" alt=""></p>
<p>那其中还有一个参数，option，我们一直没有使用，它是做什么的？这里面包含了很多动画的一些效果，我就挑其中我们最常使用的来讲一下，看一下效果</p>
<h4 id="repeat重复动画效果"><a href="#repeat重复动画效果" class="headerlink" title="repeat重复动画效果"></a>repeat重复动画效果</h4><p>我们将option设置为repeat</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0</span>, options: .<span class="keyword">repeat</span> , animations: &#123;</div><div class="line">    <span class="keyword">self</span>.headingLabel.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>实现的是一个重复的动画效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-3.gif" alt=""></p>
<h4 id="autoreverse回弹效果"><a href="#autoreverse回弹效果" class="headerlink" title="autoreverse回弹效果"></a>autoreverse回弹效果</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0</span>, options: .autoreverse , animations: &#123;</div><div class="line">    <span class="keyword">self</span>.headingLabel.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>这样是在动画执行将要结束的时候，会有一个向原来位置趋向的一个动画</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-5.gif" alt=""></p>
<h4 id="curveEaseInOut慢进慢出"><a href="#curveEaseInOut慢进慢出" class="headerlink" title="curveEaseInOut慢进慢出"></a>curveEaseInOut慢进慢出</h4><p>通常上面的两个option经常和这个慢进慢出结合起来使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0</span>, options: [.<span class="keyword">repeat</span>,.autoreverse,.curveEaseInOut] , animations: &#123;</div><div class="line">    <span class="keyword">self</span>.headingLabel.center.x += <span class="keyword">self</span>.view.bounds.width</div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>形成一个循环的效果图</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-6.gif" alt=""></p>
<p>这个有一个循环，且适合我们审美的一个动画效果</p>
<h3 id="云朵的出现alpha"><a href="#云朵的出现alpha" class="headerlink" title="云朵的出现alpha"></a>云朵的出现alpha</h3><p>控制一个空间渐渐出现，其实就是讲alpha值的改变放到动画中，alpha从 0 到 1 渐渐出现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.7</span>, delay: <span class="number">1</span>, options: [], animations: &#123; </div><div class="line">    <span class="keyword">self</span>.cloud1.alpha = <span class="number">1</span></div><div class="line">    <span class="keyword">self</span>.cloud2.alpha = <span class="number">1</span></div><div class="line">    <span class="keyword">self</span>.cloud3.alpha = <span class="number">1</span></div><div class="line">    <span class="keyword">self</span>.cloud4.alpha = <span class="number">1</span></div><div class="line">&#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>一个完整的动画效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-22-7.gif" alt=""></p>
<p>源码位置：</p>
<p><a href="https://github.com/yangqian111/iOS-Animations/tree/master/Animations01" target="_blank" rel="external">https://github.com/yangqian111/iOS-Animations/tree/master/Animations01</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前只是简单介绍了一些动画方面的属性之类的，一些基础概念，感觉效果并不是很好，我自己讲起来也觉得比较枯燥，更不要说让别人有兴趣看下去，接下来，在动画方面，尽量坚持实现一些实际的效果，这样看起来也舒服，也能在实践中用起来&lt;/p&gt;
    
    </summary>
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-categories/iOS%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="iOS动画" scheme="http://ppsheep.com/all-tags/iOS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Runtime详解</title>
    <link href="http://ppsheep.com/2016/07/25/Runtime%E8%AF%A6%E8%A7%A3/"/>
    <id>http://ppsheep.com/2016/07/25/Runtime详解/</id>
    <published>2016-07-25T02:07:16.000Z</published>
    <updated>2017-02-15T05:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>RunTime一直是iOS开发中非常重要的而且必须要理解的东西，最近在学习RunTime，有自己的一些心得，现在记录下来，便于以后查阅<br><a id="more"></a></p>
<h3 id="什么是RunTime"><a href="#什么是RunTime" class="headerlink" title="什么是RunTime"></a>什么是RunTime</h3><ul>
<li>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如[target doSomething]方法会被转化成 objc_msgSend(target,@select(doSomething))</li>
<li>OC中的一切都被设计成对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，在runtime中使用结构体表示</li>
<li>相关的定义:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/// 描述类中的一个方法</div><div class="line">typedef struct objc_method *Method;</div><div class="line"></div><div class="line">/// 实例变量</div><div class="line">typedef struct objc_ivar *Ivar;</div><div class="line"></div><div class="line">/// 类别Category</div><div class="line">typedef struct objc_category *Category;</div><div class="line"></div><div class="line">/// 类中声明的属性</div><div class="line">typedef struct objc_property *objc_property_t;</div></pre></td></tr></table></figure>
<ul>
<li>类在RunTime中的表示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//类在runtime中的表示</div><div class="line"> struct objc_class &#123;</div><div class="line">     Class isa;//指针，顾名思义，表示是一个什么，</div><div class="line">     //实例的isa指向类对象，类对象的isa指向元类</div><div class="line"></div><div class="line"> #if !__OBJC2__</div><div class="line">     Class super_class;  //指向父类</div><div class="line">     const char *name;  //类名</div><div class="line">     long version;</div><div class="line">     long info;</div><div class="line">     long instance_size</div><div class="line">     struct objc_ivar_list *ivars //成员变量列表</div><div class="line">     struct objc_method_list **methodLists; //方法列表</div><div class="line">     struct objc_cache *cache;//缓存</div><div class="line">     //一种优化，调用过的方法存入缓存列表，下次调用先找缓存</div><div class="line">     struct objc_protocol_list *protocols //协议列表</div><div class="line">     #endif</div><div class="line"> &#125; OBJC2_UNAVAILABLE;</div><div class="line"> /* Use `Class` instead of `struct objc_class *` */</div></pre></td></tr></table></figure>
<h3 id="获取类中的属性方法列表等"><a href="#获取类中的属性方法列表等" class="headerlink" title="获取类中的属性方法列表等"></a>获取类中的属性方法列表等</h3><p>有时候我们有这样的需求，需要知道当前类中的每个属性的名字</p>
<p>我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表，方法列表，成员变量列表，和遵循的协议列表)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">unsigned int count;</div><div class="line">//获取属性列表</div><div class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class="line">for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class="line">    const char *propertyName = property_getName(propertyList[i]);</div><div class="line">    NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取方法列表</div><div class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class="line">for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">    Method method = methodList[i];</div><div class="line">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取成员变量列表</div><div class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class="line">for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">    Ivar myIvar = ivarList[i];</div><div class="line">    const char *ivarName = ivar_getName(myIvar);</div><div class="line">    NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获取协议列表</div><div class="line">__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class="line">for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">    Protocol *myProtocal = protocolList[i];</div><div class="line">    const char *protocolName = protocol_getName(myProtocal);</div><div class="line">    NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来测试一下 新建一个工程</p>
<p>在.h文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface ViewController : UIViewController&lt;UITabBarDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *property1;</div><div class="line">@property (nonatomic, copy) NSString *property2;</div><div class="line">@property (nonatomic, copy) NSString *property3;</div><div class="line">@property (nonatomic, copy) NSString *property4;</div><div class="line"></div><div class="line">- (void)testGetMethods;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在.m文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()&lt;UINavigationBarDelegate&gt;</div><div class="line">&#123;</div><div class="line">    @private</div><div class="line">    NSUInteger countTest;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *property5;</div><div class="line">@property (nonatomic, copy) NSString *property6;</div><div class="line">@property (nonatomic, copy) NSString *property7;</div><div class="line">@property (nonatomic, copy) NSString *property8;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self getProperties];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)getProperties&#123;</div><div class="line">    unsigned int count;</div><div class="line">    //获取属性列表</div><div class="line">    NSLog(@&quot;----------获取属性---------&quot;);</div><div class="line">    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class="line">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class="line">        const char *propertyName = property_getName(propertyList[i]);</div><div class="line">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;----------获取方法---------&quot;);</div><div class="line">    //获取方法列表</div><div class="line">    Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class="line">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">        Method method = methodList[i];</div><div class="line">        NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;----------获取成员变量---------&quot;);</div><div class="line">    //获取成员变量列表</div><div class="line">    Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class="line">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">        Ivar myIvar = ivarList[i];</div><div class="line">        const char *ivarName = ivar_getName(myIvar);</div><div class="line">        NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;----------获取协议---------&quot;);</div><div class="line">    //获取协议列表</div><div class="line">    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class="line">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class="line">        Protocol *myProtocal = protocolList[i];</div><div class="line">        const char *protocolName = protocol_getName(myProtocal);</div><div class="line">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)testGetMethods&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>运行一下  我们看输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">2016-10-31 10:34:15.698751 iOS RunTime解析[1023:187762] ----------获取属性---------</div><div class="line">2016-10-31 10:34:15.698886 iOS RunTime解析[1023:187762] property----&gt;property5</div><div class="line">2016-10-31 10:34:15.698950 iOS RunTime解析[1023:187762] property----&gt;property6</div><div class="line">2016-10-31 10:34:15.698999 iOS RunTime解析[1023:187762] property----&gt;property7</div><div class="line">2016-10-31 10:34:15.699046 iOS RunTime解析[1023:187762] property----&gt;property8</div><div class="line">2016-10-31 10:34:15.699160 iOS RunTime解析[1023:187762] property----&gt;property1</div><div class="line">2016-10-31 10:34:15.699211 iOS RunTime解析[1023:187762] property----&gt;property2</div><div class="line">2016-10-31 10:34:15.699257 iOS RunTime解析[1023:187762] property----&gt;property3</div><div class="line">2016-10-31 10:34:15.699305 iOS RunTime解析[1023:187762] property----&gt;property4</div><div class="line">2016-10-31 10:34:15.699369 iOS RunTime解析[1023:187762] property----&gt;hash</div><div class="line">2016-10-31 10:34:15.699470 iOS RunTime解析[1023:187762] property----&gt;superclass</div><div class="line">2016-10-31 10:34:15.699520 iOS RunTime解析[1023:187762] property----&gt;description</div><div class="line">2016-10-31 10:34:15.699804 iOS RunTime解析[1023:187762] property----&gt;debugDescription</div><div class="line">2016-10-31 10:34:15.699872 iOS RunTime解析[1023:187762] ----------获取方法---------</div><div class="line">2016-10-31 10:34:15.699970 iOS RunTime解析[1023:187762] method----&gt;getProperties</div><div class="line">2016-10-31 10:34:15.700054 iOS RunTime解析[1023:187762] method----&gt;testGetMethods</div><div class="line">2016-10-31 10:34:15.700124 iOS RunTime解析[1023:187762] method----&gt;property1</div><div class="line">2016-10-31 10:34:15.700188 iOS RunTime解析[1023:187762] method----&gt;setProperty1:</div><div class="line">2016-10-31 10:34:15.700249 iOS RunTime解析[1023:187762] method----&gt;property2</div><div class="line">2016-10-31 10:34:15.700399 iOS RunTime解析[1023:187762] method----&gt;setProperty2:</div><div class="line">2016-10-31 10:34:15.700485 iOS RunTime解析[1023:187762] method----&gt;property3</div><div class="line">2016-10-31 10:34:15.700596 iOS RunTime解析[1023:187762] method----&gt;setProperty3:</div><div class="line">2016-10-31 10:34:15.700666 iOS RunTime解析[1023:187762] method----&gt;property4</div><div class="line">2016-10-31 10:34:15.700789 iOS RunTime解析[1023:187762] method----&gt;setProperty4:</div><div class="line">2016-10-31 10:34:15.700885 iOS RunTime解析[1023:187762] method----&gt;property5</div><div class="line">2016-10-31 10:34:15.700937 iOS RunTime解析[1023:187762] method----&gt;setProperty5:</div><div class="line">2016-10-31 10:34:15.700988 iOS RunTime解析[1023:187762] method----&gt;property6</div><div class="line">2016-10-31 10:34:15.701036 iOS RunTime解析[1023:187762] method----&gt;setProperty6:</div><div class="line">2016-10-31 10:34:15.701083 iOS RunTime解析[1023:187762] method----&gt;property7</div><div class="line">2016-10-31 10:34:15.701132 iOS RunTime解析[1023:187762] method----&gt;setProperty7:</div><div class="line">2016-10-31 10:34:15.701244 iOS RunTime解析[1023:187762] method----&gt;property8</div><div class="line">2016-10-31 10:34:15.701309 iOS RunTime解析[1023:187762] method----&gt;setProperty8:</div><div class="line">2016-10-31 10:34:15.701440 iOS RunTime解析[1023:187762] method----&gt;.cxx_destruct</div><div class="line">2016-10-31 10:34:15.701518 iOS RunTime解析[1023:187762] method----&gt;didReceiveMemoryWarning</div><div class="line">2016-10-31 10:34:15.701621 iOS RunTime解析[1023:187762] method----&gt;viewDidLoad</div><div class="line">2016-10-31 10:34:15.701671 iOS RunTime解析[1023:187762] ----------获取成员变量---------</div><div class="line">2016-10-31 10:34:15.701746 iOS RunTime解析[1023:187762] Ivar----&gt;countTest</div><div class="line">2016-10-31 10:34:15.701795 iOS RunTime解析[1023:187762] Ivar----&gt;_property1</div><div class="line">2016-10-31 10:34:15.701865 iOS RunTime解析[1023:187762] Ivar----&gt;_property2</div><div class="line">2016-10-31 10:34:15.701916 iOS RunTime解析[1023:187762] Ivar----&gt;_property3</div><div class="line">2016-10-31 10:34:15.701964 iOS RunTime解析[1023:187762] Ivar----&gt;_property4</div><div class="line">2016-10-31 10:34:15.702012 iOS RunTime解析[1023:187762] Ivar----&gt;_property5</div><div class="line">2016-10-31 10:34:15.702059 iOS RunTime解析[1023:187762] Ivar----&gt;_property6</div><div class="line">2016-10-31 10:34:15.702106 iOS RunTime解析[1023:187762] Ivar----&gt;_property7</div><div class="line">2016-10-31 10:34:15.702154 iOS RunTime解析[1023:187762] Ivar----&gt;_property8</div><div class="line">2016-10-31 10:34:15.702192 iOS RunTime解析[1023:187762] ----------获取协议---------</div><div class="line">2016-10-31 10:34:15.702850 iOS RunTime解析[1023:187762] protocol----&gt;UINavigationBarDelegate</div><div class="line">2016-10-31 10:34:15.702908 iOS RunTime解析[1023:187762] protocol----&gt;UITabBarDelegate</div></pre></td></tr></table></figure>
<p>我们可以看到 无论是.h中申明 还是.m中的申明  全部打印了出来</p>
<p>而且还有一个规律  就是.m中的属性和方法 总是被首先打印出来</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>我们看一下方法调用在运行时的过程</p>
<p>如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。</p>
<p>如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作。</p>
<ul>
<li>首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行。</li>
<li>如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行</li>
<li>如果没找到，去父类指针所指向的对象中执行1，2.</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用。</li>
<li>如果没有重写拦截调用的方法，程序报错。</li>
</ul>
<p>那么  这样 我们是不是可以这样做呢？</p>
<ul>
<li>重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法后就不会再去父类中找了。</li>
<li>如果想调用已经重写过的方法的父类的实现，只需使用super这个编译器标识，它会在运行时跳过在当前的类对象中寻找方法的过程。</li>
</ul>
<h3 id="拦截调用"><a href="#拦截调用" class="headerlink" title="拦截调用"></a>拦截调用</h3><p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。</p>
<p>那么什么是拦截调用呢。</p>
<p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel;</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</div><div class="line">//后两个方法需要转发到其他的类处理</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div></pre></td></tr></table></figure>
<ul>
<li>第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</li>
<li>第二个方法和第一个方法相似，只不过处理的是实例方法。</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target。</li>
<li>第四个方法是将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法。</li>
</ul>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢？<br>有一个办法是根据传进来的SEL类型的selector动态添加一个方法。</p>
<p>首先从外部隐式调用一个不存在的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//隐式调用方法</div><div class="line">[target performSelector:@selector(resolveAdd:) withObject:@&quot;test&quot;];</div></pre></td></tr></table></figure>
<p>然后，在target对象内部重写拦截调用的方法，动态添加方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void runAddMethod(id self, SEL _cmd, NSString *string)&#123;</div><div class="line">    NSLog(@&quot;add C IMP &quot;, string);</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line"></div><div class="line">    //给本类动态添加一个方法</div><div class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;resolveAdd:&quot;]) &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中class_addMethod的四个参数分别是：</p>
<ul>
<li>Class cls 给哪个类添加方法，本例中是self</li>
<li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。</li>
<li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用+ (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li>
<li>“v@:*”方法的签名，代表有一个参数的方法。</li>
</ul>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。</p>
<p>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。</p>
<p>这个时候，runtime的关联属性就发挥它的作用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//首先定义一个全局变量，用它的地址作为关联对象的key</div><div class="line">static char associatedObjectKey;</div><div class="line">//设置关联对象</div><div class="line">objc_setAssociatedObject(target, &amp;associatedObjectKey, @&quot;添加的字符串属性&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC); </div><div class="line">//获取关联对象</div><div class="line">NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);</div><div class="line">NSLog(@&quot;AssociatedObject = %@&quot;, string);</div></pre></td></tr></table></figure>
<p>objc_setAssociatedObject的四个参数：</p>
<ul>
<li>id object给谁设置关联对象。</li>
<li>const void *key关联对象唯一的key，获取时会用到。</li>
<li>id value关联对象。</li>
<li>objc_AssociationPolicy关联策略，有以下几种策略：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum&#123;</div><div class="line">	OBJC_ASSOCIATION_ASSIGN = 0,</div><div class="line">	OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, </div><div class="line">	OBJC_ASSOCIATION_COPY_NONATOMIC = 3,</div><div class="line">	OBJC_ASSOCIATION_RETAIN = 01401,</div><div class="line">	OBJC_ASSOCIATION_COPY = 01403 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>objc_getAssociatedObject的两个参数:</p>
<ul>
<li>id object获取谁的关联对象。</li>
<li>const void *key根据这个唯一的key获取关联对象。</li>
</ul>
<p>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//添加关联对象</div><div class="line">- (void)addAssociatedObject:(id)object&#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">//获取关联对象</div><div class="line">- (id)getAssociatedObject&#123;</div><div class="line">    return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。</p>
<h3 id="方法交换"><a href="#方法交换" class="headerlink" title="方法交换"></a>方法交换</h3><p>就是将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法中的代码，反之亦然。</p>
<p>我们来试一下  定义一个UIViewController的category</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> load方法会在类第一次加载的时候被调用</div><div class="line"> 调用的时间比较靠前，适合在这个方法里做方法交换</div><div class="line"> */</div><div class="line">+(void)load&#123;</div><div class="line">    //方法交换应该被保证，在程序中只会执行一次</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        //获得viewController的生命周期方法的selector</div><div class="line">        SEL systemSel = @selector(viewWillAppear:);</div><div class="line">        //自己实现的将要被交换的方法的selector</div><div class="line">        SEL customeSel = @selector(custome_viewWillAppear:);</div><div class="line">        //两个方法的Method</div><div class="line">        Method systemMethod = class_getInstanceMethod([self class], systemSel);</div><div class="line">        Method customeMethod = class_getInstanceMethod([self class], customeSel);</div><div class="line">        </div><div class="line">        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</div><div class="line">        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(customeMethod), method_getTypeEncoding(customeMethod));</div><div class="line">        if (isAdd) &#123;</div><div class="line">            //如果成功，说明类中不存在这个方法的实现</div><div class="line">            //将被交换方法的实现替换到这个并不存在的实现</div><div class="line">            class_replaceMethod(self, customeSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</div><div class="line">        &#125;else&#123;</div><div class="line">            //否则，交换两个方法的实现</div><div class="line">            method_exchangeImplementations(systemMethod, customeMethod);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)custome_viewWillAppear:(BOOL)animated&#123;</div><div class="line">    //这时候调用自己，看起来像是死循环</div><div class="line">    //但是其实自己的实现已经被替换了</div><div class="line">    [self custome_viewWillAppear:animated];//这里 是去执行系统的viewWillApper:方法</div><div class="line">    NSLog(@&quot;custome&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在其他的controller中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;UIViewController+Custome.h&quot;</div><div class="line"></div><div class="line">@interface ViewController : UIViewController&lt;UITabBarDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *property1;</div><div class="line">@property (nonatomic, copy) NSString *property2;</div><div class="line">@property (nonatomic, copy) NSString *property3;</div><div class="line">@property (nonatomic, copy) NSString *property4;</div><div class="line"></div><div class="line">- (void)testGetMethods;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在.m中我们重写vieWillApper:方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)viewWillAppear:(BOOL)animated&#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将会看到在控制台 直接打印出了custome  </p>
<p>其实vieWillApper：方法已经被我们替换成我们自己的custome_viewWillAppear：</p>
<p>然后在我们自定义的custome_viewWillAppear:方法中  又调用了custome_viewWillAppear：本身  其实他已经被替换成viewWillApper：方法  所以这样就实现了 方法交换</p>
<p>写的有点多了  </p>
<p>演示代码  我放在了</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS%20RunTime解析" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS%20RunTime解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RunTime一直是iOS开发中非常重要的而且必须要理解的东西，最近在学习RunTime，有自己的一些心得，现在记录下来，便于以后查阅&lt;br&gt;
    
    </summary>
    
      <category term="Runtime" scheme="http://ppsheep.com/all-categories/Runtime/"/>
    
    
      <category term="Runtime" scheme="http://ppsheep.com/all-tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(三)</title>
    <link href="http://ppsheep.com/2016/07/05/KVC%E5%92%8CKVO-%E4%B8%89/"/>
    <id>http://ppsheep.com/2016/07/05/KVC和KVO-三/</id>
    <published>2016-07-05T02:04:32.000Z</published>
    <updated>2017-02-15T05:10:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续我们之前的KVC和KVO系列，这是这个系列的最后一篇，这两周都没怎么写东西，估计这一周过后，文章更新会正常了，手头上的事情多了，就不想写了，写出来的东西也是粗制滥造</p>
<a id="more"></a>
<h3 id="KVO和线程"><a href="#KVO和线程" class="headerlink" title="KVO和线程"></a>KVO和线程</h3><p>KVO 行为是同步的 并且发生与所观察的值发生变化的同样的线程上。这听起来有点拗口，简单点说，就是监听行为发生的线程和所观察的值发生变化的线程，肯定是同一个线程，这样我们使用的时候就需要注意了：</p>
<p>当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知</p>
<p>通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>最简单的 KVC 能让我们通过以下的形式访问属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *name;</div></pre></td></tr></table></figure>
<p>取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *n = [object valueForKey:@&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>设定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@&quot;Daniel&quot; forKey:@&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) CGFloat height;</div></pre></td></tr></table></figure>
<p>我们可以这样设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:@(20) forKey:@&quot;height&quot;]</div></pre></td></tr></table></figure>
<h3 id="键路径-key-path"><a href="#键路径-key-path" class="headerlink" title="键路径 (key path)"></a>键路径 (key path)</h3><p>KVC 同样允许我们通过关系来访问对象。假设 person 对象有属性 address，address 有属性 city，我们可以这样通过 person 来访问 city：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person valueForKeyPath:@&quot;address.city&quot;]</div></pre></td></tr></table></figure>
<p>值得注意的是这里我们调用 -valueForKeyPath: 而不是 -valueForKey:</p>
<h3 id="Key-Value-Coding-Without-property"><a href="#Key-Value-Coding-Without-property" class="headerlink" title="Key-Value Coding Without @property"></a>Key-Value Coding Without @property</h3><p>不需要 @property 的 KVC</p>
<p>我们可以实现一个支持 KVC 而不用 @property 和 @synthesize 或是自动 synthesize 的属性。最直接的方式是添加 -<key> 和 -set<key>: 方法。例如我们想要 name ，我们这样做：</key></key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name;</div><div class="line">- (void)setName:(NSString *)name;</div></pre></td></tr></table></figure>
<p>这完全等于 @property 的实现方式。</p>
<p>但是当标量和 struct 的值被传入 nil 的时候尤其需要注意。假设我们要 height 属性支持 KVC 我们写了以下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)height;</div><div class="line">- (void)setHeight:(CGFloat)height;</div></pre></td></tr></table></figure>
<p>然后我们这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[object setValue:nil forKey:@&quot;height&quot;]</div></pre></td></tr></table></figure>
<p>这会抛出一个 exception。要正确的处理 nil，我们要像这样 override -setNilValueForKey:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setNilValueForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;height&quot;]) &#123;</div><div class="line">        [self setValue:@0 forKey:key];</div><div class="line">    &#125; else</div><div class="line">        [super setNilValueForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>一个常常被忽视的 KVC 特性是它对集合操作的支持。举个例子，我们可以这样来获得一个数组中最大的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *a = @[@4, @84, @2];</div><div class="line">NSLog(@&quot;max = %@&quot;, [a valueForKeyPath:@&quot;@max.self&quot;]);</div></pre></td></tr></table></figure>
<p>或者说，我们有一个 Transaction 对象的数组，对象有属性 amount 的话，我们可以这样获得最大的 amount：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *a = @[transaction1, transaction2, transaction3];</div><div class="line">NSLog(@&quot;max = %@&quot;, [a valueForKeyPath:@&quot;@max.amount&quot;]);</div></pre></td></tr></table></figure>
<p>当我们调用 [a valueForKeyPath:@”@max.amount”] 的时候，它会在数组 a 的每个元素中调用 -valueForKey:@”amount” 然后返回最大的那个。</p>
<h3 id="常见的-KVO-错误"><a href="#常见的-KVO-错误" class="headerlink" title="常见的 KVO 错误"></a>常见的 KVO 错误</h3><p>首先，KVO 兼容是 API 的一部分。如果类的所有者不保证某个属性兼容 KVO，我们就不能保证 KVO 正常工作。苹果文档里有 KVO 兼容属性的文档。例如，NSProgress 类的大多数属性都是兼容 KVO 的。</p>
<p>当做出改变以后，有些人试着放空的 -willChange 和 -didChange 方法来强制 KVO 的触发。KVO 通知虽然会生效，但是这样做破坏了有依赖于 NSKeyValueObservingOld 选项的观察者。详细来说，这影响了 KVO 对观察键路径 (key path) 的原生支持。KVO 在观察键路径 (key path) 时依赖于 NSKeyValueObservingOld 属性。</p>
<p>我们也要指出有些集合是不能被观察的。KVO 旨在观察关系 (relationship) 而不是集合。我们不能观察 NSArray，我们只能观察一个对象的属性——而这个属性有可能是 NSArray。举例说，如果我们有一个 ContactList 对象，我们可以观察它的 contacts 属性。但是我们不能向要观察对象的 -addObserver:forKeyPath:… 传入一个 NSArray。</p>
<p>相似地，观察 self 不是永远都生效的。而且这不是一个好的设计。</p>
<h3 id="调试-KVO"><a href="#调试-KVO" class="headerlink" title="调试 KVO"></a>调试 KVO</h3><p>你可以在 lldb 里查看一个被观察对象的所有观察信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) po [observedObject observationInfo]</div></pre></td></tr></table></figure>
<p>这会打印出有关谁观察谁之类的很多信息。</p>
<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
<p>参考：</p>
<p><a href="https://www.objccn.io/issue-7-3/" target="_blank" rel="external">https://www.objccn.io/issue-7-3/</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续我们之前的KVC和KVO系列，这是这个系列的最后一篇，这两周都没怎么写东西，估计这一周过后，文章更新会正常了，手头上的事情多了，就不想写了，写出来的东西也是粗制滥造&lt;/p&gt;
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(二)</title>
    <link href="http://ppsheep.com/2016/06/28/KVC%E5%92%8CKVO-%E4%BA%8C/"/>
    <id>http://ppsheep.com/2016/06/28/KVC和KVO-二/</id>
    <published>2016-06-28T01:30:54.000Z</published>
    <updated>2017-02-15T05:10:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一周实在是手头上的事情太多，项目忙着出版本，都没怎么写点东西，估计这一周也不会轻松，感觉已经好久没动了，还是需要积累点东西的。上一篇文章，我们讲到了KVC和KVO，我们接着完成这个系列，这个系列是我在喵神的Objc上看到的，结合自己的一点理解，记录下来。</p>
<a id="more"></a>
<p>在上一篇文章中，我们讲到，通过键值观察，属性依赖，来讲解KVC，如果没有看过上一篇文章的，请移步<br><a href="http://ppsheep.com/2016/11/19/KVC和KVO(一)/">http://ppsheep.com/2016/11/19/KVC和KVO(一)/</a></p>
<h3 id="手动通知和自动通知"><a href="#手动通知和自动通知" class="headerlink" title="手动通知和自动通知"></a>手动通知和自动通知</h3><p>在OC中，消息通知扮演着很重要的角色，在我们在调用 LabColor 类的 -setLComponent:方法时，会触发以下方法的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)willChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)didChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>会在运行 -setLComponent: 中的代码之前以及之后被自动调用。</p>
<p>有些情况下当我们需要 override -setLComponent: 并且我们要控制是否发送键值改变的通知的时候，我们要做以下的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//是否自动发送通知</div><div class="line">+ (BOOL)automaticallyNotifiesObserversForLComponent;</div><div class="line">&#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setLComponent:(double)lComponent;</div><div class="line">&#123;</div><div class="line">    if (_lComponent == lComponent) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //手动调用</div><div class="line">    [self willChangeValueForKey:@&quot;lComponent&quot;];</div><div class="line">    _lComponent = lComponent;</div><div class="line">    [self didChangeValueForKey:@&quot;lComponent&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们关闭了 -willChangeValueForKey: 和 -didChangeValueForKey: 的自动调用，然后我们手动调用他们。我们只应该在关闭了自动调用的时候我们才需要在 setter 方法里手动调用 -willChangeValueForKey: 和 -didChangeValueForKey:。大多数情况下，我们都不会这样做，这样做，会让代码变得复杂，不容易理解</p>
<h3 id="KVO和context"><a href="#KVO和context" class="headerlink" title="KVO和context"></a>KVO和context</h3><p>有时我们会有理由不想用 KeyValueObserver 辅助类。创建另一个对象会有额外的性能开销。如果我们观察很多个键的话，这个开销可能会变得明显。</p>
<p>如果我们在实现一个类的时候把它自己注册为观察者的话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)anObserver</div><div class="line">         forKeyPath:(NSString *)keyPath</div><div class="line">            options:(NSKeyValueObservingOptions)options</div><div class="line">            context:(void *)context</div></pre></td></tr></table></figure>
<p>一个非常重要的点是我们要传入一个这个类唯一的 context。推荐把以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static int const PrivateKVOContext;</div></pre></td></tr></table></figure>
<p>写在这个类 .m 文件的顶端，然后我们像这样调用 API 并传入 PrivateKVOContext 的指针：</p>
<p>我们在LabColor类中定义一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//将自己设置为观察者</div><div class="line">- (void)setObserverWithSelf;</div></pre></td></tr></table></figure>
<p>在本类中实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)setObserverWithSelf&#123;</div><div class="line">    [self addObserver:self forKeyPath:@&quot;lComponent&quot; options:NSKeyValueObservingOptionInitial context:(void *)&amp;PrivateKVOContext];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们这样写 -observeValueForKeyPath:… 的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div><div class="line">&#123;</div><div class="line">    if (context == &amp;PrivateKVOContext) &#123;</div><div class="line">        // 这里写相关的观察代码</div><div class="line">    &#125; else &#123;</div><div class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将确保我们写的子类都是正确的。如此一来，子类和父类都能安全的观察同样的键值而不会冲突。否则我们将会碰到难以 debug 的奇怪行为。</p>
<h3 id="进阶KVO"><a href="#进阶KVO" class="headerlink" title="进阶KVO"></a>进阶KVO</h3><p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 NSKeyValueObservingOptionInitial 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 -addObserver:forKeyPath:… 到时候也被触发。</p>
<h4 id="之前和之后"><a href="#之前和之后" class="headerlink" title="之前和之后"></a>之前和之后</h4><p>如果我们注册通知的时候附加了 NSKeyValueObservingOptionPrior 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;</div><div class="line">    // 改变之前</div><div class="line">&#125; else &#123;</div><div class="line">    // 改变之后</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="值"><a href="#值" class="headerlink" title="值"></a>值</h4><p>如果我们需要改变前后的值，我们可以在 KVO 选项中加入 NSKeyValueObservingOptionNew 和/或 NSKeyValueObservingOptionOld。</p>
<p>更简单的办法是用 NSKeyValueObservingOptionPrior 选项，随后我们就可以用以下方式提取出改变前后的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id oldValue = change[NSKeyValueChangeOldKey];</div><div class="line">id newValue = change[NSKeyValueChangeNewKey];</div></pre></td></tr></table></figure>
<p>通常来说 KVO 会在 -willChangeValueForKey: 和 -didChangeValueForKey: 被调用的时候存储相应键的值。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>KVO 对一些集合类也有很强的支持，以下方法会返回集合对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-mutableArrayValueForKey:</div><div class="line">-mutableSetValueForKey:</div><div class="line">-mutableOrderedSetValueForKey:</div></pre></td></tr></table></figure>
<p>我将会详细解释这是怎么工作的。如果你使用这些方法，change 字典里会包含键值变化的类型（添加、删除和替换）。对于有序的集合，change 字典会包含受影响的 index。</p>
<p>集合代理对象和变化的通知在用于更新UI的时候非常有效，尤其是处理大集合的时候。但是它们需要花费你一些心思。</p>
<p>后面将会结合UI层面，来对KVC和KVO进行进一步讲解</p>
<p>参考:</p>
<p><a href="https://www.objccn.io" target="_blank" rel="external">https://www.objccn.io</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一周实在是手头上的事情太多，项目忙着出版本，都没怎么写点东西，估计这一周也不会轻松，感觉已经好久没动了，还是需要积累点东西的。上一篇文章，我们讲到了KVC和KVO，我们接着完成这个系列，这个系列是我在喵神的Objc上看到的，结合自己的一点理解，记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS sqlite简单封装使用</title>
    <link href="http://ppsheep.com/2016/06/17/iOS-sqlite%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://ppsheep.com/2016/06/17/iOS-sqlite简单封装使用/</id>
    <published>2016-06-17T08:38:49.000Z</published>
    <updated>2017-02-15T05:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite几乎在每个APP编码都会涉及到，它是一种轻量级的数据库，在手机端使用起来极其方便，因为SQLite原生的接口都是使用C写的，不是特别友好，所有有一个强大库就出现了FMDB，今天我们基于FMDB来进行二次封装</p>
<a id="more"></a>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>首先来看一下我的项目结构</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79jw1f9v75zwsfkj307d0gv0tu.jpg" alt=""></p>
<h3 id="封装思路"><a href="#封装思路" class="headerlink" title="封装思路"></a>封装思路</h3><p>数据层的基本封装思路是：</p>
<ul>
<li>首先我们需要一个数据库管理类，这个管理类主要是管理数据库文件，因为我们可能会有很多个数据库文件，需要这样一个管理类</li>
<li>一个基础的BaseDBStore，其中主要是我们需要执行的一些基本的操作，包括增、删、改、查，然后每个模块需要使用到数据库的时候，他们有单独的子模块，是从Base继承而来</li>
</ul>
<p>数据库管理类的实现代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;FMDB.h&quot;</div><div class="line"></div><div class="line">@interface PPSDBManager : NSObject</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *  DB队列  还可以定义其他的数据库 这里只是一个示例</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) FMDatabaseQueue *commonQueue;</div><div class="line"></div><div class="line">+ (PPSDBManager *)sharedInstance;</div><div class="line"></div><div class="line">/**</div><div class="line"> 创建数据库文件</div><div class="line"></div><div class="line"> @param userId 传入用户id</div><div class="line"> @return 数据库文件地址</div><div class="line"> */</div><div class="line">+ (NSString *)dbPath:(NSString *)userId;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里加入了用户思想，即每个用户是一个数据库文件，这样好区分，而且每个用户可以拥有不同的数据库文件，这里只创建了一个，当然还可以创建很多个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#import &quot;PPSDBManager.h&quot;</div><div class="line"></div><div class="line">static PPSDBManager *manager;</div><div class="line">@implementation PPSDBManager</div><div class="line"></div><div class="line">+(PPSDBManager *)sharedInstance&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSString *userID = @&quot;ppsheep&quot;;//随便写了一个id</div><div class="line">        manager = [[PPSDBManager alloc] initWithUserId:userID];</div><div class="line">    &#125;);</div><div class="line">    return manager;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 一般的，如果有用户的APP，这里就可以传入当前用户的id 用以区分数据库</div><div class="line"> 这里我就随便写了</div><div class="line"> @param userId 用户id</div><div class="line"> @return 实例</div><div class="line"> */</div><div class="line">- (instancetype)initWithUserId:(NSString *)userId&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        NSString *commonQueuePath = [PPSDBManager dbPath:userId];</div><div class="line">        self.commonQueue = [FMDatabaseQueue databaseQueueWithPath:commonQueuePath];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 数据库文件地址</div><div class="line"></div><div class="line"> @return 地址</div><div class="line"> */</div><div class="line">+ (NSString *)dbPath: (NSString *)userId&#123;</div><div class="line">     NSString *path = [NSString stringWithFormat:@&quot;%@/User/%@/Setting/DB/&quot;, NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0], userId];</div><div class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:path]) &#123;</div><div class="line">        //创建数据库文件</div><div class="line">        NSError *error;</div><div class="line">        [[NSFileManager defaultManager] createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&amp;error];</div><div class="line">        if (error) &#123;</div><div class="line">            NSLog(@&quot;创建数据库文件失败：%@&quot;,path);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [path stringByAppendingString:@&quot;common.sqlite3&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>BaseStore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;PPSDBManager.h&quot;</div><div class="line"></div><div class="line">@interface PPSDBBaseStore : NSObject</div><div class="line"></div><div class="line"></div><div class="line">// 数据库操作队列(从NADBManager中获取，默认使用commonQueue)</div><div class="line">@property (nonatomic, weak) FMDatabaseQueue *dbQueue;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  表创建</div><div class="line"> */</div><div class="line">- (BOOL)createTable:(NSString*)tableName withSQL:(NSString*)sqlString;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行带数组参数的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">-(BOOL)excuteSQL:(NSString*)sqlString withArrParameter:(NSArray*)arrParameter;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行带字典参数的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">-(BOOL)excuteSQL:(NSString*)sqlString withDicParameter:(NSDictionary*)dicParameter;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行格式化的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString,...;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  执行查询指令</div><div class="line"> */</div><div class="line">- (void)excuteQuerySQL:(NSString*)sqlStr resultBlock:(void (^)(FMResultSet * rsSet))resultBlock;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Base定义的一些基础的操作，注释都写的很清楚，我就不一一解释了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//查询语句</div><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString,...</div><div class="line">&#123;</div><div class="line">    __block BOOL ok = NO;</div><div class="line">    if (self.dbQueue) &#123;</div><div class="line">        va_list args;</div><div class="line">        va_list *p_args;</div><div class="line">        p_args = &amp;args;</div><div class="line">        va_start(args, sqlString);</div><div class="line">        [self.dbQueue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">            ok = [db executeUpdate:sqlString withVAList:*p_args];</div><div class="line">        &#125;];</div><div class="line">        va_end(args);</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>带参数的查询方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString withArrParameter:(NSArray *)arrParameter</div><div class="line">&#123;</div><div class="line">    __block BOOL ok = NO;</div><div class="line">    if (self.dbQueue) &#123;</div><div class="line">        [self.dbQueue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">            ok = [db executeUpdate:sqlString withArgumentsInArray:arrParameter];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Base里面的方法，都是调用FMDB</p>
<h3 id="User模块"><a href="#User模块" class="headerlink" title="User模块"></a>User模块</h3><p>现在，我们有一个User模块，需要实现用户的存取，首先，我们需要一个装SQL的文件，分离SQL</p>
<p>PPSDBUserSQL.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#ifndef PPSDBUserSQL_h</div><div class="line">#define PPSDBUserSQL_h</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#define     USER_TABLE_NAME              @&quot;user&quot;</div><div class="line">/**</div><div class="line"> *  建表</div><div class="line"> *</div><div class="line"> *  @param uid   当前用户Corp邮箱前缀</div><div class="line"> *  @param fid    好友Corp邮箱前缀</div><div class="line"> *  @param email   Corp邮箱</div><div class="line"> *</div><div class="line"> *  @return</div><div class="line"> */</div><div class="line">#define     SQL_CREATE_USER_TABLE        </div><div class="line">			@&quot;CREATE TABLE IF NOT EXISTS %@(\</div><div class="line">                    uid TEXT,\</div><div class="line">                    name TEXT,\</div><div class="line">                    email TEXT,\</div><div class="line">                    phoneNum TEXT,\</div><div class="line">                    ext1 TEXT,\</div><div class="line">                    ext2 TEXT,\</div><div class="line">                    ext3 TEXT,\</div><div class="line">                    ext4 INTEGER DEFAULT (0),\</div><div class="line">                    ext5 INTEGER DEFAULT (0),\</div><div class="line">                    ext6 INTEGER DEFAULT (0),\</div><div class="line">                    PRIMARY KEY(uid))&quot;</div><div class="line"></div><div class="line">#define     SQL_ADD_USER      @&quot;INSERT OR REPLACE INTO %@ ( uid, name, email, phoneNum, ext1, ext2, ext3, ext4, ext5, ext6) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;</div><div class="line"></div><div class="line">#define     SQL_SELECT_USER   @&quot;SELECT * FROM %@ WHERE uid = &apos;%@&apos;&quot;</div><div class="line"></div><div class="line">#define     SQL_GET_ALL_USER   @&quot;SELECT * FROM %@ &quot;</div><div class="line"></div><div class="line">#define     SQL_DELETE_USER    @&quot;DELETE FROM %@ WHERE uid = &apos;%@&apos;&quot;</div><div class="line"></div><div class="line">#define     SQL_UPDATE_USER    @&quot;UPDATE %@ SET name = ?, email = ?, phoneNum = ? WHERE uid = &apos;%@&apos; &quot;</div><div class="line"></div><div class="line"></div><div class="line">#endif /* PPSDBUserSQL_h */</div></pre></td></tr></table></figure>
<p>然后是具体的操作User的Store 包含了基本的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#import &quot;PPSDBBaseStore.h&quot;</div><div class="line"></div><div class="line">@class PPSUser;</div><div class="line">@interface PPSDBUserStore : PPSDBBaseStore</div><div class="line"></div><div class="line">//改</div><div class="line">- (BOOL)updateUserData:(NSArray *)users;</div><div class="line"></div><div class="line">//增</div><div class="line">- (BOOL)addUser:(NSArray *)users;</div><div class="line"></div><div class="line">//查</div><div class="line">- (NSMutableArray *)usersByUserIds:(NSArray *)userIds;</div><div class="line"></div><div class="line">//删</div><div class="line">- (BOOL)deleteUserByUid:(NSArray *)userIds;</div><div class="line"></div><div class="line">- (NSArray *)allUsers;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>批量查询用户，传入id数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">-(NSMutableArray *)usersByUserIds:(NSArray *)userIds&#123;</div><div class="line">    NSArray *ids = [userIds copy];</div><div class="line">    __block NSMutableArray *data = [[NSMutableArray alloc] init];</div><div class="line">    </div><div class="line">    for (NSString *userId in ids) &#123;</div><div class="line">      NSString *sqlString = [NSString stringWithFormat:SQL_SELECT_USER, USER_TABLE_NAME, userId];</div><div class="line">        [self excuteQuerySQL:sqlString resultBlock:^(FMResultSet *retSet) &#123;</div><div class="line">            while ([retSet next]) &#123;</div><div class="line">                NSDictionary *dic = @&#123;</div><div class="line">                                      @&quot;userId&quot; : [retSet stringForColumn:@&quot;uid&quot;],</div><div class="line">                                      @&quot;email&quot; : [retSet stringForColumn:@&quot;email&quot;],</div><div class="line">                                      @&quot;name&quot; : [retSet stringForColumn:@&quot;name&quot;],</div><div class="line">                                      @&quot;phoneNum&quot; : [retSet stringForColumn:@&quot;phoneNum&quot;],</div><div class="line">                                      &#125;;</div><div class="line">                PPSUser *user = [[PPSUser alloc] initWithDic:dic];</div><div class="line">                [data addObject:user];</div><div class="line">            &#125;</div><div class="line">            [retSet close];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>批量更新用户，传入用户数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(BOOL)updateUserData:(NSArray *)users&#123;</div><div class="line">    NSArray *userCopy = [users copy];</div><div class="line">    BOOL ok = YES;</div><div class="line">    for (PPSUser *user in userCopy) &#123;</div><div class="line">        NSString *sql = [NSString stringWithFormat:SQL_UPDATE_USER, USER_TABLE_NAME, user.userId];</div><div class="line">        NSArray *arrPara = [NSArray arrayWithObjects:</div><div class="line">                            PPSNoNilString(user.name),</div><div class="line">                            PPSNoNilString(user.email),</div><div class="line">                            PPSNoNilString(user.phoneNum),</div><div class="line">                            @&quot;&quot;, @&quot;&quot;, @&quot;&quot;, @0, @0, @0,  nil];</div><div class="line">        ok = [self excuteSQL:sql withArrParameter:arrPara];</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>为了方便，我就直接在ViewController中写了，在真正的开发中，一般都会在管理类中进行数据库操作</p>
<p>懒加载一个用户数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(PPSDBUserStore *)store&#123;</div><div class="line">    if (!_store) &#123;</div><div class="line">        _store = [[PPSDBUserStore alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化用户，直接插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)initUsers&#123;</div><div class="line">    NSMutableArray *arr = [NSMutableArray array];</div><div class="line">    for (int i=0; i&lt;10; i++) &#123;</div><div class="line">        PPSUser *user = [[PPSUser alloc] init];</div><div class="line">        user.userId = [NSString stringWithFormat:@&quot;%ld_userId&quot;,(long)i];</div><div class="line">        user.name = [NSString stringWithFormat:@&quot;%ld_userName&quot;,(long)i];</div><div class="line">        user.email = [NSString stringWithFormat:@&quot;%ld_email&quot;,(long)i];</div><div class="line">        user.phoneNum = [NSString stringWithFormat:@&quot;%ld_phoneNum&quot;,(long)i];</div><div class="line">        [arr addObject:user];</div><div class="line">    &#125;</div><div class="line">    [self.store addUser:arr];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我就不再贴代码出来了，项目工程，我放在了</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS%20sqlite使用" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS%20sqlite使用</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sqlite几乎在每个APP编码都会涉及到，它是一种轻量级的数据库，在手机端使用起来极其方便，因为SQLite原生的接口都是使用C写的，不是特别友好，所有有一个强大库就出现了FMDB，今天我们基于FMDB来进行二次封装&lt;/p&gt;
    
    </summary>
    
      <category term="sqlite数据库" scheme="http://ppsheep.com/all-categories/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sqlite" scheme="http://ppsheep.com/all-tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(一)</title>
    <link href="http://ppsheep.com/2016/06/08/KVC%E5%92%8CKVO(%E4%B8%80)/"/>
    <id>http://ppsheep.com/2016/06/08/KVC和KVO(一)/</id>
    <published>2016-06-08T08:08:32.000Z</published>
    <updated>2017-02-15T05:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。</p>
<a id="more"></a>
<h3 id="观察model对象的变化"><a href="#观察model对象的变化" class="headerlink" title="观察model对象的变化"></a>观察model对象的变化</h3><p>在 Cocoa 的模型-视图-控制器 (Model-view-controller)架构里，控制器负责让视图和模型同步。这一共有两步：当 model 对象改变的时候，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。</p>
<p>KVO 能帮助我们让视图和模型保持同步。控制器可以观察视图依赖的属性变化。</p>
<p>让我们看一个例子：我们的模型类 LabColor 代表一种 Lab色彩空间里的颜色。和 RGB 不同，这种色彩空间有三个元素 L, a, b。我们要做一个用来改变这些值的滑块和一个显示颜色的方块区域。</p>
<p>我们的模型类有以下三个用来代表颜色的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) double lComponent;</div><div class="line">@property (nonatomic) double aComponent;</div><div class="line">@property (nonatomic) double bComponent;</div></pre></td></tr></table></figure>
<h3 id="依赖的属性"><a href="#依赖的属性" class="headerlink" title="依赖的属性"></a>依赖的属性</h3><p>我们需要从这个类创建一个 UIColor 对象来显示出颜色。我们添加三个额外的属性，分别对应 R, G, B：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) double redComponent;</div><div class="line">@property (nonatomic, readonly) double greenComponent;</div><div class="line">@property (nonatomic, readonly) double blueComponent;</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) UIColor *color;</div></pre></td></tr></table></figure>
<p>有了这些以后，我们就可以创建这个类的接口了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface LabColor : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) double lComponent;</div><div class="line">@property (nonatomic) double aComponent;</div><div class="line">@property (nonatomic) double bComponent;</div><div class="line"></div><div class="line">@property (nonatomic, readonly) double redComponent;</div><div class="line">@property (nonatomic, readonly) double greenComponent;</div><div class="line">@property (nonatomic, readonly) double blueComponent;</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) UIColor *color;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>维基百科提供了转换 RGB 到 Lab 色彩空间的算法。写成方法之后如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (double)greenComponent;</div><div class="line">&#123;</div><div class="line">    return D65TristimulusValues[1] * inverseF(1./116. * (self.lComponent + 16) + 1./500. * self.aComponent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[...]</div><div class="line"></div><div class="line">- (UIColor *)color</div><div class="line">&#123;</div><div class="line">    return [UIColor colorWithRed:self.redComponent * 0.01 green:self.greenComponent * 0.01 blue:self.blueComponent * 0.01 alpha:1.];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码没什么令人激动的地方。有趣的是 greenComponent 属性依赖于 lComponent 和 aComponent。不论何时设置 lComponent 的值，我们需要让 RGB 三个 component 中与其相关的成员以及 color 属性都要得到通知以保持一致。这一点这在 KVO 中很重要。</p>
<p>Foundation 框架提供的表示属性依赖的机制如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>更详细的如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffecting&lt;键名&gt;</div></pre></td></tr></table></figure>
<p>在我们的例子中如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingRedComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObject:@&quot;lComponent&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;aComponent&quot;, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingBlueComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;bComponent&quot;, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;redComponent&quot;, @&quot;greenComponent&quot;, @&quot;blueComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>这里解释一下，可能有一些朋友对这里的对象依赖关系不是特别清楚。我们拿出一个来解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;aComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>重要</strong></p>
<p>在这个方法中，它代表的意思是当lComponent属性，或者aComponent属性改变时，需要通知到greenComponent，就相当于，lComponent或者aComponent中的任何一个作出改变时，可以认为greenComponent也发生了改变，如果这时，有一个监听对象，在监听greenComponent，那么当我们改变lComponent或aComponent，这个监听会被触发</p>
<p>至于这个方法怎么得来的，在peoperty中定义了该属性，你只要敲keyPath就会自动提示出来，有哪些可以设置依赖了</p>
<p>在我们的color中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;redComponent&quot;, @&quot;greenComponent&quot;, @&quot;blueComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>color是依赖于redComponent、greenComponent和blueComponent，这样 我们就能知道，改变lComponent、aComponent、bComponent任何一个，都会触发color的监听</p>
<p>现在我们完整的表达了属性之间的依赖关系。请注意，我们可以把这些属性链接起来。打个比方，如果我们写一个子类去 override redComponent 方法，这些依赖关系仍然能正常工作。</p>
<h3 id="观察变化"><a href="#观察变化" class="headerlink" title="观察变化"></a>观察变化</h3><p>现在让我们目光转向控制器。 UIViewController 的子类拥有 LabColor model 对象作为其属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) LabColor *labColor;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们把视图控制器注册为观察者来接收 KVO 的通知，这可以用以下 NSObject 的方法来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)anObserver</div><div class="line">         forKeyPath:(NSString *)keyPath</div><div class="line">            options:(NSKeyValueObservingOptions)options</div><div class="line">            context:(void *)context</div></pre></td></tr></table></figure>
<p>这会让以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div></pre></td></tr></table></figure>
<p>在当 keyPath 的值改变的时候在观察者 anObserver 上面被调用。这个 API 看起来有一点吓人。更糟糕的是，我们还得记得调用以下的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)removeObserver:(NSObject *)anObserver</div><div class="line">            forKeyPath:(NSString *)keyPath</div></pre></td></tr></table></figure>
<p>来移除观察者，否则我们我们的 app 会因为某些奇怪的原因崩溃。</p>
<p>对于大多数的应用来说，KVO 可以通过辅助类用一种更简单优雅的方式实现。我们在视图控制器添加以下的观察记号（Observation token）属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) id colorObserveToken;</div></pre></td></tr></table></figure>
<p>当 labColor 在视图控制器中被设置时，我们只要 override labColor 的 setter 方法就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)setLabColor:(LabColor *)labColor</div><div class="line">&#123;</div><div class="line">    _labColor = labColor;</div><div class="line">    self.colorObserveToken = [KeyValueObserver observeObject:labColor</div><div class="line">                                                     keyPath:@&quot;color&quot;</div><div class="line">                                                      target:self</div><div class="line">                                                    selector:@selector(colorDidChange:)</div><div class="line">                                                     options:NSKeyValueObservingOptionInitial];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)colorDidChange:(NSDictionary *)change;</div><div class="line">&#123;</div><div class="line">    self.colorView.backgroundColor = self.labColor.color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们封装一个KeyValueObserver辅助类</p>
<p>KeyValueObserver 辅助类 封装了 -addObserver:forKeyPath:options:context:，-observeValueForKeyPath:ofObject:change:context:和-removeObserverForKeyPath: 的调用，让视图控制器远离杂乱的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 其中__attribute__((warn_unused_result))这个的意思是，当调用这个方法时，必须要检查返回值，或者使用返回值，不然编译器直接报警告</div><div class="line"></div><div class="line">+ (NSObject *)observeObject:(id)object keyPath:(NSString*)keyPath target:(id)target selector:(SEL)selector __attribute__((warn_unused_result));</div><div class="line"></div><div class="line"></div><div class="line">+ (NSObject *)observeObject:(id)object keyPath:(NSString*)keyPath target:(id)target selector:(SEL)selector options:(NSKeyValueObservingOptions)options __attribute__((warn_unused_result));</div></pre></td></tr></table></figure>
<h3 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h3><p>视图控制器需要对 L，a，b 的滑块控制做出反应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)updateLComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.lComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateAComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.aComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateBComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.bComponent = sender.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-21-KVC%26KVO-%E4%B8%80-.gif" alt=""></p>
<p>源工程:</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS%20KVC和KVO(一" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS%20KVC和KVO(一</a>)</p>
<p>参考:<br>    <a href="https://www.objccn.io/issue-7-3/" target="_blank" rel="external">https://www.objccn.io/issue-7-3/</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/all-tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS每个ViewController一个NavigationBar</title>
    <link href="http://ppsheep.com/2016/05/29/iOS%E6%AF%8F%E4%B8%AAViewController%E4%B8%80%E4%B8%AANavigationBar/"/>
    <id>http://ppsheep.com/2016/05/29/iOS每个ViewController一个NavigationBar/</id>
    <published>2016-05-29T05:03:38.000Z</published>
    <updated>2017-02-15T05:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们经常会碰到一些关于导航栏的问题，例如视觉设计，经常性的改变NavigationBar的风格，虽然我们能够在viewwillApper中来进行处理，但是总是太麻烦，而且需要写很多多余的代码，今天就来讲讲这种效果，其实已经有很多APP都是使用这种效果</p>
<a id="more"></a>
<p>我们先来看看已经有的一些APP使用的这种效果</p>
<p>这是天猫APP的效果，注意观察他的导航栏</p>
<p><img src="http://i.imgur.com/Hz7Ixkj.gif" alt=""></p>
<p>这是网易新闻，注意看导航栏</p>
<p><img src="http://i.imgur.com/JClX4Z3.gif" alt=""></p>
<p>越来越多的APP采用这种样式来控制导航栏的不同风格，今天我们就来实现这一效果。</p>
<p>这里需要使用到一个第三方库</p>
<p><a href="https://github.com/rickytan/RTRootNavigationController" target="_blank" rel="external">https://github.com/rickytan/RTRootNavigationController</a></p>
<p>借助这个库我们能够轻松实现这一效果</p>
<p>新建一个工程，这里我们使用cocoapods来集成这个第三方库</p>
<h3 id="集成RTRootNavigationController"><a href="#集成RTRootNavigationController" class="headerlink" title="集成RTRootNavigationController"></a>集成RTRootNavigationController</h3><p>podfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">workspace ‘iOS每个VC单独的一个导航栏.xcworkspace’</div><div class="line"></div><div class="line">project ‘iOS每个VC单独的一个导航栏.xcodeproj’</div><div class="line"></div><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line"></div><div class="line">target &apos;iOS每个VC单独的一个导航栏&apos; do </div><div class="line"></div><div class="line">pod ‘RTRootNavigationController’</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="使用RTRootNavigationController当做当前的rootController"><a href="#使用RTRootNavigationController当做当前的rootController" class="headerlink" title="使用RTRootNavigationController当做当前的rootController"></a>使用RTRootNavigationController当做当前的rootController</h3><h4 id="创建BaseViewController"><a href="#创建BaseViewController" class="headerlink" title="创建BaseViewController"></a>创建BaseViewController</h4><p>我这里新建一个BaseViewController 主要是为了引入RTRootNavigationController，当然如果是OC项目的话，可以直接创建一个PCH文件，直接全局引用也行，不过我们一般都会有一个基类的ViewController，在这个基类中，没有做任何操作，只是引用了一个RTRootNavigationController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &quot;RTRootNavigationController.h&quot;</div><div class="line"></div><div class="line">@interface BaseViewController : UIViewController</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="设置根控制器"><a href="#设置根控制器" class="headerlink" title="设置根控制器"></a>设置根控制器</h4><p>在Appdelegate中，我们需要将我们的window的rootcontroller设置为RTRootNavigationController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">ViewController *viewController = [[ViewController alloc] init];</div><div class="line">RTRootNavigationController *rootViewController1 = [[RTRootNavigationController alloc] initWithRootViewController:viewController];</div><div class="line">_window.rootViewController = rootViewController1;</div><div class="line">_window.backgroundColor = [UIColor whiteColor];</div><div class="line">[_window makeKeyAndVisible];</div><div class="line">return YES;</div></pre></td></tr></table></figure>
<p>在ViewController中，我们需要push出去一个vc的时候，我们需要这样实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//注意这里push的时候需要使用rt_navigation push出去</div><div class="line">[self.rt_navigationController pushViewController:vc1 animated:YES complete:nil];</div></pre></td></tr></table></figure>
<p>看一下效果</p>
<p><img src="http://i.imgur.com/L89Z6fk.gif" alt=""></p>
<h4 id="设置返回NavigationBar按钮"><a href="#设置返回NavigationBar按钮" class="headerlink" title="设置返回NavigationBar按钮"></a>设置返回NavigationBar按钮</h4><p>在当前的vc中，我们设置返回按钮，或者其他的按钮，也很方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> UIButton *btn1 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn1 addTarget:self action:@selector(leftBar1Clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn1 setTitle:@&quot;返回1&quot; forState:UIControlStateNormal];</div><div class="line">[btn1 setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</div><div class="line">[btn1 sizeToFit];</div><div class="line">UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithCustomView:btn1];</div><div class="line">    </div><div class="line">UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn2 setTitle:@&quot;返回2&quot; forState:UIControlStateNormal];</div><div class="line">[btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">[btn2 addTarget:self action:@selector(leftBar2Clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn2 sizeToFit];</div><div class="line">UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithCustomView:btn2];</div><div class="line"></div><div class="line">self.navigationItem.leftBarButtonItems = @[item1,item2];</div><div class="line">    </div><div class="line">UIButton *btn3 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn3 setTitle:@&quot;右键&quot; forState:UIControlStateNormal];</div><div class="line">[btn3 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">[btn3 addTarget:self action:@selector(rightBarClicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn3 sizeToFit];</div><div class="line">UIBarButtonItem *rightItem = [[UIBarButtonItem alloc] initWithCustomView:btn3];</div><div class="line">    </div><div class="line">self.navigationItem.rightBarButtonItem = rightItem;</div><div class="line">    </div><div class="line">[self.view addSubview:label];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/zOrrJZW.jpg" alt=""></p>
<p>多个按钮定义也是很方便的</p>
<p>如果只是需要一个左边的返回按钮，这个按钮需要自定义样式，那么可以直接在当前VC冲下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 如果对于返回事件不需要做任何处理，</div><div class="line"> 但是有想要自定义返回按钮的样式，</div><div class="line"> 可以直接重写这个方法</div><div class="line"></div><div class="line"> @param target 监听对象</div><div class="line"> @param action 返回事件</div><div class="line"> @return 自定义的返回按钮</div><div class="line"> */</div><div class="line">-(UIBarButtonItem *)customBackItemWithTarget:(id)target action:(SEL)action&#123;</div><div class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</div><div class="line">    [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">    [btn sizeToFit];</div><div class="line">    [btn addTarget:target action:action forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithCustomView:btn];</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，就不要去单独设置左上角的返回按钮了</p>
<p><img src="http://i.imgur.com/I5tVOEx.gif" alt=""></p>
<h4 id="跳到最开始的VC"><a href="#跳到最开始的VC" class="headerlink" title="跳到最开始的VC"></a>跳到最开始的VC</h4><p>在我们pop的时候，可以直接pop在栈顶的VC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.rt_navigationController popToRootViewControllerAnimated:YES complete:nil];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/tQ2vyPz.gif" alt=""></p>
<h4 id="push到另外一个VC-销毁当前的VC"><a href="#push到另外一个VC-销毁当前的VC" class="headerlink" title="push到另外一个VC 销毁当前的VC"></a>push到另外一个VC 销毁当前的VC</h4><p>有时我们想要实现这样一种效果，当当前的VCpush出去过后，希望销毁当前的VC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ViewController4 *vc4 = [[ViewController4 alloc] init];</div><div class="line">[self.rt_navigationController pushViewController:vc4 animated:vc4 complete:^(BOOL finished) &#123;</div><div class="line">     [self.rt_navigationController removeViewController:self];</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/8ABurCG.gif" alt=""></p>
<h4 id="更改导航栏颜色"><a href="#更改导航栏颜色" class="headerlink" title="更改导航栏颜色"></a>更改导航栏颜色</h4><p>之前忘记更改导航栏的颜色了，这里看一下，更改导航栏的颜色，只需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.navigationController.navigationBar.barTintColor = [UIColor greenColor];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/mFby2bB.gif" alt=""></p>
<p><strong>总结</strong></p>
<p>如果你的APP在导航栏有多种样式的话，你完全可以使用这种方法，使用起来很方便</p>
<p>感谢:<br>    rickyTan开源<br>    <a href="https://github.com/rickytan/RTRootNavigationController" target="_blank" rel="external">https://github.com/rickytan/RTRootNavigationController</a></p>
<p>项目的源码我放在了：<br>    <a href="https://github.com/yangqian111/blog/tree/master/iOS每个VC单独的一个导航栏" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS每个VC单独的一个导航栏</a></p>
<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，我们经常会碰到一些关于导航栏的问题，例如视觉设计，经常性的改变NavigationBar的风格，虽然我们能够在viewwillApper中来进行处理，但是总是太麻烦，而且需要写很多多余的代码，今天就来讲讲这种效果，其实已经有很多APP都是使用这种效果&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
