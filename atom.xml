<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ppsheep</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ppsheep.com/"/>
  <updated>2017-01-03T07:01:20.000Z</updated>
  <id>http://ppsheep.com/</id>
  
  <author>
    <name>ppsheep</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS ping网络小工具</title>
    <link href="http://ppsheep.com/2017/01/03/iOS-ping%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://ppsheep.com/2017/01/03/iOS-ping网络小工具/</id>
    <published>2017-01-03T05:30:44.000Z</published>
    <updated>2017-01-03T07:01:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apple官方有一个SimplePing的demo，用于对网络进行检测，就跟我们电脑端的ping效果相同，在一些情况下，我们可以用来进行网络速度的检测，这里将官方给出的demo进行封装，便于我们的使用，源码我会放在文章末尾。</p>
<a id="more"></a>
<h3 id="SimplePing"><a href="#SimplePing" class="headerlink" title="SimplePing"></a>SimplePing</h3><p>首先，我们需要到苹果的开发者网站，下载demo </p>
<p><a href="https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html" target="_blank" rel="external">https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html</a></p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-03-053734.jpg" alt=""></p>
<h3 id="PPSPingItem"><a href="#PPSPingItem" class="headerlink" title="PPSPingItem"></a>PPSPingItem</h3><p>新建一个我们的自己的工程，将刚才下载的例子中的SimplePing 头文件和实现文件 两个文件拷贝到我们的工程中</p>
<p>首先，我们新建一个model PPSPingItem  用来封装我们在网络ping过程中，返回的一些数据，便于数据展示</p>
<p>我们来看一张电脑的终端ping的样式：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-03-054734.jpg" alt=""></p>
<p>我们在手机端要实现的也是这种效果</p>
<p>PPSPingItem：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">typedef NS_ENUM(NSUInteger, PPSPingStatus)&#123;</div><div class="line">    PPSPingStatusDidStart,//开始</div><div class="line">    PPSPingStatusDidFailToSendPacket,//发送数据包失败</div><div class="line">    PPSPingStatusDidReceivePacket,//收到数据包</div><div class="line">    PPSPingStatusDidReceiveUnexpectedPacket,//数据包数据错误</div><div class="line">    PPSPingStatusDidTimeout,//超时</div><div class="line">    PPSPingStatusError,//错误</div><div class="line">    PPSPingStatusFinished,//完成</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">@interface PPSPingItem : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> </div><div class="line"> ping www.163.com</div><div class="line"> </div><div class="line"> PING 163.xdwscache.ourglb0.com (183.134.24.71): 56 data bytes</div><div class="line"> </div><div class="line"> 64 bytes from 183.134.24.71: icmp_seq=0 ttl=53 time=12.914 ms</div><div class="line"> 64 bytes from 183.134.24.71: icmp_seq=1 ttl=53 time=15.136 ms</div><div class="line"> </div><div class="line"> --- 163.xdwscache.ourglb0.com ping statistics ---</div><div class="line"> 2 packets transmitted, 2 packets received, 0.0% packet loss</div><div class="line"> </div><div class="line"> */</div><div class="line"></div><div class="line">/**</div><div class="line"> 对应上面的一个ping解释属性</div><div class="line"> */</div><div class="line"></div><div class="line">@property(nonatomic) NSString *originalAddress; // 163.xdwscache.ourglb0.com</div><div class="line"></div><div class="line">@property(nonatomic, copy) NSString *IPAddress;// 183.134.24.71</div><div class="line"></div><div class="line">@property(nonatomic) NSUInteger dateBytesLength;// 64</div><div class="line"></div><div class="line">@property(nonatomic) double     timeMilliseconds;//time</div><div class="line"></div><div class="line">@property(nonatomic) NSInteger  timeToLive;//ttl</div><div class="line"></div><div class="line">@property(nonatomic) NSInteger  ICMPSequence;//icmp_seq</div><div class="line"></div><div class="line">@property(nonatomic) PPSPingStatus status;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>PPSPingItem中的属性，在我们ping网络过程中，返回数据时需要用到。</p>
<h3 id="PPSPingServices"><a href="#PPSPingServices" class="headerlink" title="PPSPingServices"></a>PPSPingServices</h3><p>PPSPingServices是一个服务类，用作ping的入口，一个管理类，供外部调用，在PPSPingServices类中，我将发起网络ping的接口做成了block，当然，如果你更喜欢delegate，也可以使用delegate实现</p>
<p>首先，一个类方法，调起Ping服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> 开始收集Ping网络消息</div><div class="line"> </div><div class="line"> @param address 域名</div><div class="line"> @param handler 回调包信息 每次收到的网络信息</div><div class="line"> @return PPSPingServices</div><div class="line"> */</div><div class="line">+ (PPSPingServices *)startPingAddress:(NSString *)address</div><div class="line">                      callbackHandler:(void(^)(PPSPingItem *pingItem, NSArray *pingItems))handler;</div></pre></td></tr></table></figure>
<p>在实现文件中，我们需要实现SimplePingDelegate，delegate中一共有6个方法，分别对应这ping的不同状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//开始进行网络检测</div><div class="line">- (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address;</div><div class="line">//网络检测失败</div><div class="line">- (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error;</div><div class="line">//发送网络包成功</div><div class="line">- (void)simplePing:(SimplePing *)pinger didSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;</div><div class="line">//发送网络包失败</div><div class="line">- (void)simplePing:(SimplePing *)pinger didFailToSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber error:(NSError *)error;</div><div class="line">//收到网络包回应</div><div class="line">- (void)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber;</div><div class="line">//收到错误的网络包</div><div class="line">- (void)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(NSData *)packet;</div></pre></td></tr></table></figure>
<p>开始ping网络数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> 开始网络ping网络</div><div class="line"></div><div class="line"> @param sender 按钮</div><div class="line"> */</div><div class="line">- (IBAction)startPing:(id)sender &#123;</div><div class="line"> self.pingService = [PPSPingServices startPingAddress:_domainTextFiled.text callbackHandler:^(PPSPingItem *pingItem, NSArray *pingItems) &#123;</div><div class="line">     NSLog(@&quot;%@&quot;,pingItem);</div><div class="line"> &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在服务类中，我们开始ping网络，会在6个delegate方法中，分别获得ping网络的返回值，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apple官方有一个SimplePing的demo，用于对网络进行检测，就跟我们电脑端的ping效果相同，在一些情况下，我们可以用来进行网络速度的检测，这里将官方给出的demo进行封装，便于我们的使用，源码我会放在文章末尾。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS基础 网络组件" scheme="http://ppsheep.com/categories/iOS%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="ping工具" scheme="http://ppsheep.com/tags/ping%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Swift教程(一)—基础部分、基本运算符</title>
    <link href="http://ppsheep.com/2016/12/28/Swift%E6%95%99%E7%A8%8B(%E4%B8%80)%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E3%80%81%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://ppsheep.com/2016/12/28/Swift教程(一)—基础部分、基本运算符/</id>
    <published>2016-12-28T11:13:10.000Z</published>
    <updated>2017-01-09T01:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift  该来的还是要来的，Swift使用范围越来越广，你不用，大家都会用，然后呢。。。你又落后了。。</p>
<a id="more"></a>
<h3 id="常量变量"><a href="#常量变量" class="headerlink" title="常量变量"></a>常量变量</h3><p>首先呢，每门语言都是从常量变量讲起，Swift当然也不例外</p>
<p>在Swift中常量  使用 let声明   变量使用var声明<br>不像OC或者Java 我们在声明常量变量时，可以不加类型，编译器能够帮助我们推断出类型，像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let myName = &quot;Yang Qian&quot;</div><div class="line"></div><div class="line">var myAge = 23</div></pre></td></tr></table></figure>
<p>在上面两行中，并没有指明 myAge 和  myName 的类型，编译器也没有报错，当然，我们也是可以声明他们的类型的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let myName: String = &quot;Yang Qian&quot;</div><div class="line"></div><div class="line">let myAge: Int  = 23</div><div class="line"></div><div class="line">let 🐶🐮 = &quot;dogcow&quot;</div></pre></td></tr></table></figure>
<p><em>注意</em>这里有一个书写规范，苹果在文档中特意提醒了，在声明类型的时候，需要在冒号后面空一格，保持格式一致。</p>
<blockquote>
<p><strong>常量(let)一旦声明，便不可更改。变量(var)可进行更改</strong></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// This is a comment. 这是一行注释</div><div class="line"></div><div class="line">/*</div><div class="line"> 这是多行注释</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>关于分号呢，在Swift中，每个语句结束是不用写分号的，当然也可以写，但是我们推荐呢，还是不要写了，苹果都说不用写了，你还写干嘛，而且现在看一些开源的Swift代码，大神都没写分号。</p>
<p>但是存在一种情况，就是如果你想在一行写多个语句，那每个语句之间你就需要用分号隔开了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//这样就会报错了</div><div class="line">let myName: String = &quot;Yang Qian&quot; let myAge: Int  = 23</div><div class="line">//要这样写</div><div class="line">let myName: String = &quot;Yang Qian&quot; ; let myAge: Int  = 23</div></pre></td></tr></table></figure>
<p>这样的代码也太丑了吧，还是一行一个语句吧，养成良好的代码习惯</p>
<h3 id="整数Int"><a href="#整数Int" class="headerlink" title="整数Int"></a>整数Int</h3><p>在Swift上，提供了一个特殊的整数类型Int，在32位的机器上运行，那这个整数的长度就是和Int32相同，如果实在64为机器上运行，那这个整数的长度就是Int64的，一般来说  我们直接使用Int就已经OK了。</p>
<h3 id="无类型UInt"><a href="#无类型UInt" class="headerlink" title="无类型UInt"></a>无类型UInt</h3><p>无符号类型，一般呢我们不使用，为什么呢？  苹果文档上讲的</p>
<blockquote>
<p>Use UInt only when you specifically need an unsigned integer type with the same size as the platform’s native word size. If this is not the case, Int is preferred, even when the values to be stored are known to be non-negative</p>
</blockquote>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名  就是给现有的类型加上一个我们自己自定义的名称  使用关键字 typealias定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//这样，我们就将UInt16定义成了 AudioSample</div><div class="line">typealias AudioSample = UInt16</div><div class="line"></div><div class="line">var maxAmplitudeFound = AudioSample.min</div><div class="line">// 等价于  var maxAmplitudeFound = UInt16.min</div></pre></td></tr></table></figure>
<h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>现在我们的布尔值  不再是OC 中的  Yes 和  No 了  需要使用  true  false</p>
<p>而且 现在呢，我们也不能再使用int的  0  1 来表示  true 或者false 了  之前呢  OC是可以这样使用的  但是在swift中，编译器就会报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let i = 1</div><div class="line">if i &#123;</div><div class="line">    // this example will not compile, and will report an error</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，苹果讲了，是会报错的</p>
<h3 id="Tuples-元组"><a href="#Tuples-元组" class="headerlink" title="Tuples 元组"></a>Tuples 元组</h3><p>元组，这个厉害了，这个可以把多个值组合成一个复合值，就是一个元组，而且这个元组里的各个值，不用类型相同，这下厉害了，这样一来，我们传参数，还有函数返回值，都可以多个了  想想 挺激动的  虽然还没用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let http404Error = (404, &quot;Not Found&quot;)</div></pre></td></tr></table></figure>
<p>上面，就是一个表示404 的一个元组，看到了，是一个404 Int 和  一个  String</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">let http404Code = (404, &quot;Not Found&quot;)</div><div class="line"></div><div class="line">let (statusCode, statusString) = http404Code</div><div class="line"></div><div class="line">print(&quot;the code is \(statusCode)&quot;)</div><div class="line"></div><div class="line">print(&quot;the message is \(statusString)&quot;)</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">the code is 404</div><div class="line">the message is Not Found</div></pre></td></tr></table></figure>
<p> 如果呢，我们只关心我们需要的数据，不关心其他的，比如在上面的例子中，我们只关心code 那么我们就可以这样写</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> </div><div class="line">let http404Code = (404, &quot;Not Found&quot;)</div><div class="line"></div><div class="line">let (statusCode, _) = http404Code</div><div class="line"></div><div class="line">print(&quot;the code is \(statusCode)&quot;)</div><div class="line"></div><div class="line">//print(&quot;the message is \(statusString)&quot;)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">the code is 404</div></pre></td></tr></table></figure>
<p>能少写一点是一点</p>
<p>还可以呢，像数组一样，输出元组的第几位:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let http404Code = (404, &quot;Not Found&quot;)</div><div class="line"></div><div class="line">print(&quot;the code is \(http404Code.0)&quot;)</div><div class="line"></div><div class="line">print(&quot;the message is \(http404Code.1)&quot;)</div></pre></td></tr></table></figure>
<p>输出呢,一样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">the code is 404</div><div class="line">the message is Not Found</div></pre></td></tr></table></figure>
<p>别急 还有写法呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let http200Status = (statusCode: 200, description: &quot;OK&quot;)</div></pre></td></tr></table></figure>
<p>然后我们来输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">print(&quot;The status code is \(http200Status.statusCode)&quot;)</div><div class="line">// Prints &quot;The status code is 200</div></pre></td></tr></table></figure>
<p>简直太强大了，我个人最喜欢 那种点语法</p>
<h3 id="Optionals-可选类型"><a href="#Optionals-可选类型" class="headerlink" title="Optionals 可选类型"></a>Optionals 可选类型</h3><p>使用可选类型，用来处理值可能缺失的情况，这样一来，我们的代码安全性能够提升很多</p>
<p>一般来说，这个可选类型就两种情况</p>
<ul>
<li>有值  就是x</li>
<li>无值  就是nil</li>
</ul>
<!--more-->
<blockquote>
<p>我们知道在OC中，是没有这个概念的，在OC中，比如我们有一个方法，有返回值，如果是返回的是对象，要么就是返回对象实例，要么返回nil表示值缺失。但是我们遇到需要返回枚举，我们就没办法了，一般我们会定义一个NotFound这种类型，但是在Swift我们就不需要了</p>
</blockquote>
<p>我们举个例子</p>
<p>如果我们想讲一个字符串，强转成一个Int整形，我们知道，不可能每个字符串都能转成整数，像”123”这种可以转成整形，但是”ni hao”这种，能转成整形吗？你在逗我</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let testString = &quot;123&quot;</div><div class="line">let testString1 = &quot;ni hao&quot;</div><div class="line"></div><div class="line">let testInt1 = Int(testString1)</div><div class="line">let testInt2 = Int(testString)</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-29-055540.jpg" alt=""></p>
<p>这样代码并不会报错</p>
<p>我们可以手动来设置optional值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var serverResponseCode: Int? = 404</div><div class="line">// serverResponseCode contains an actual Int value of 404</div><div class="line">serverResponseCode = nil</div><div class="line">// serverResponseCode now contains no value</div></pre></td></tr></table></figure>
<p><strong>注意，在Swift中，nil的定义和Objective-C中的nil定义不相同，在Swift中，nil只是用来表示值缺失，不管是对象，还是Int之类的基础类型，都可以使用nil来表示值缺失，但是在OC中就只有对象可以使用，因为在OC中是表示一个指向不存在对象的指针</strong></p>
<p>如果你像下面这样定义了一个变量，不需要你声明他为nil，编译器会自动为他赋值nil，这根OC中  还是有较大的差别的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var surveyAnswer: String?</div></pre></td></tr></table></figure>
<p>同样的，我们还是和OC一样，可以使用==或者!=来判断是否是nil</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if surveyAnswer != nil&#123;</div><div class="line">	//做什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果，我们能够确定，这个变量，肯定是有值的，那么我们就可以使用强制解包，在其后面加上一个!</p>
<p>像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if surveyAnswer != nil&#123;</div><div class="line">	//我们已经知道surveyAnswer是肯定有值的</div><div class="line">	print(surveyAnswer!)//强制解包 输出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在我们强制解包的时候，一定要确保这个值是有的，不然，会出现错误，导致程序崩溃</strong></p>
<h3 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h3><p>这个  厉害了，很好用的</p>
<p>我们可以在if 和 while 语句中使用 我就直接上代码了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if let actualNumber = Int(possibleNumber) &#123;</div><div class="line">    print(&quot;\&quot;\(possibleNumber)\&quot; has an integer value of \(actualNumber)&quot;)</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;\&quot;\(possibleNumber)\&quot; could not be converted to an integer&quot;)</div><div class="line">&#125;</div><div class="line">// Prints &quot;&quot;123&quot; has an integer value of 123”</div></pre></td></tr></table></figure>
<p>我们上面讲过，这个强转，转出来是一个optional值，我们在if语句中判断这个值，如果存在，则将这个值赋给actualNumber常量，在判断语句中需要使用到，如果转出来是一个nil，那么就跳到另外的语句中</p>
<p>还有更强大的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if let firstNumber = Int(&quot;4&quot;), </div><div class="line">	let secondNumber = Int(&quot;42&quot;), </div><div class="line">	firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 </div><div class="line">&#123;</div><div class="line">    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">&#125;</div><div class="line">// Prints &quot;4 &lt; 42 &lt; 100&quot;</div><div class="line"> </div><div class="line">if let firstNumber = Int(&quot;4&quot;)</div><div class="line"> &#123;</div><div class="line">    if let secondNumber = Int(&quot;42&quot;) </div><div class="line">    &#123;</div><div class="line">        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 </div><div class="line">        &#123;</div><div class="line">            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// Prints &quot;4 &lt; 42 &lt; 100”</div></pre></td></tr></table></figure>
<p>这么强大 的  if语句</p>
<h3 id="隐式解析"><a href="#隐式解析" class="headerlink" title="隐式解析"></a>隐式解析</h3><p>有时候，我们很确定，一些变量或者常量，肯定是有值的，不需要声明为optional，不然我们每次使用的时候，都需要加上!来进行解包</p>
<p>Swift为我们提供了隐式声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let absolutString: String! = &quot;我肯定是有值的&quot;</div><div class="line"></div><div class="line">print(absolutString)//可以直接使用，不需要解包</div></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果之前有写过Java的同学肯定对try catch很熟悉  在Swift中，使用try catch来进行错误的捕获和处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">func makeASandwich() throws &#123;</div><div class="line">    // 这个函数可能会抛出错误异常</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">do &#123;</div><div class="line">    try makeASandwich()//开始做三明治</div><div class="line">    eatASandwich()//开始吃三明治</div><div class="line">&#125; catch SandwichError.outOfCleanDishes &#123;//这里捕获到了异常，没有干净的盘子</div><div class="line">    washDishes()</div><div class="line">&#125; catch SandwichError.missingIngredients(let ingredients) &#123;//又捕获到了异常，没有原材料</div><div class="line">    buyGroceries(ingredients)//买原材料</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言是很好用的一个东西，而且鼓励大家使用断言。</p>
<p>断言是什么意思呢？就是我们在运行一个函数时，有事我们需要某个参数，比如一个Int一定要是一个大于0的数，如果不大于0，我们的函数就无法运行了，这时候，我们就可以使用断言了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let age = -3</div><div class="line"></div><div class="line">assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)</div></pre></td></tr></table></figure>
<p>这样程序就会检查age是否是大于等于0 的  如果不符合，程序就会终止，并且我们能够很快知道 为什么程序会终止</p>
<p>那我们什么时候需要用到断言呢？</p>
<ul>
<li>当传入一个int的下标时，比如传入数组的索引，这个整数的值可能会太大或者太小</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是nil，但是后面的代码运行需要一个非nil值</li>
</ul>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><p>很简单，就是一个加号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let a = 10</div><div class="line">let b = 5</div><div class="line">b = a</div><div class="line">print(b)</div><div class="line">//b输出 10</div></pre></td></tr></table></figure>
<p>元组赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let (x,y) = (1,2)</div><div class="line">//好了赋值好了 x = 1 y = 2</div></pre></td></tr></table></figure>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p>加减乘除我就不讲了吧</p>
<p>这里有一个还是要讲一下，字符串的加法  这个在Swift中是特有的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let a = &quot;我是&quot;</div><div class="line">let b = &quot;程序员&quot;</div><div class="line">let c = a + b</div><div class="line">print(c)</div><div class="line">//我是程序员</div></pre></td></tr></table></figure>
<h3 id="取余运算"><a href="#取余运算" class="headerlink" title="取余运算"></a>取余运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">9%2 = 1  等价于  (4*2)+1  余下一个1</div><div class="line"></div><div class="line">-9%2 = -1 等价于  (-4*2)+ -1  余下一个 -1</div></pre></td></tr></table></figure>
<h3 id="负号的使用"><a href="#负号的使用" class="headerlink" title="负号的使用"></a>负号的使用</h3><p>负负得正 这个我们都知道的哦 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let a = -1</div><div class="line">let b = -a</div><div class="line">//b现在是1</div><div class="line">let c = -b</div><div class="line">//现在c是-1</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="+=使用"></a>+=使用</h3><p>这个  大家也在其他的语言中见过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let a = 10</div><div class="line">a+=2  //a = a+2</div><div class="line">print(a)//输出12</div></pre></td></tr></table></figure>
<p>但是需要注意的是  我们没有这样的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let b = a+=2 //这种用法是错误的</div></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>==  等于</p>
<p>!=  不等于</p>
<p>></p>
<p>&lt;</p>
<p>>=</p>
<p>&lt;=</p>
<p>这里还有一个字符串的比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let a = &quot;world&quot;</div><div class="line">let b = &quot;world&quot;</div><div class="line">if a == b &#123;</div><div class="line">	//这里是能够执行到的  这为真， 这里需要注意下</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元组的比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(2,&quot;abc&quot;)&gt;(1,&quot;bca&quot;)  //2&gt;1  </div><div class="line">(1,&quot;abc&quot;)&lt;(1,&quot;bca&quot;)  //1相同 比较abc和bca 先比较第一个字母  </div><div class="line">(1,&quot;abc&quot;) == (1,&quot;abc&quot;)</div></pre></td></tr></table></figure>
<h3 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let contentHeight = 40</div><div class="line">let hasHeader = true</div><div class="line">let rowHeight = contentHeight + (hasHeader ? 50 : 20)</div><div class="line">// rowHeight is equal to 90</div></pre></td></tr></table></figure>
<h3 id="空合运算"><a href="#空合运算" class="headerlink" title="空合运算"></a>空合运算</h3><p>这个空合运算时针对值为nil的时候来做的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let defaultColorName = &quot;red&quot;</div><div class="line">var userDefinedColorName: String?   // defaults to nil</div><div class="line"> </div><div class="line">var colorNameToUse = userDefinedColorName ?? defaultColorName</div></pre></td></tr></table></figure>
<p>这里如果userDefinedColorName不是nil的话colorNameToUse的值就是userDefinedColorName的值，如果userDefinedColorName是nil 那么colorNameToUse的值，就是defaultColorName的值</p>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><p>闭合运算，包含两端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for index in 1...5 &#123;</div><div class="line">    print(&quot;\(index) times 5 is \(index * 5)&quot;)</div><div class="line">&#125;</div><div class="line">// 1 times 5 is 5</div><div class="line">// 2 times 5 is 10</div><div class="line">// 3 times 5 is 15</div><div class="line">// 4 times 5 is 20</div><div class="line">// 5 times 5 is 25</div></pre></td></tr></table></figure>
<p>半开合运算  包含左端 不包含右端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]</div><div class="line">let count = names.count</div><div class="line">for i in 0..&lt;count &#123;</div><div class="line">    print(&quot;Person \(i + 1) is called \(names[i])&quot;)</div><div class="line">&#125;</div><div class="line">// Person 1 is called Anna</div><div class="line">// Person 2 is called Alex</div><div class="line">// Person 3 is called Brian</div><div class="line">// Person 4 is called Jack</div></pre></td></tr></table></figure>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算  包括 </p>
<p>!非<br>&amp;&amp; 且<br>|| 或</p>
<p>基础的运算符完成了，接下来我们就开始学习String了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift  该来的还是要来的，Swift使用范围越来越广，你不用，大家都会用，然后呢。。。你又落后了。。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift官方教程学习笔记" scheme="http://ppsheep.com/categories/Swift%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift官方教程学习笔记" scheme="http://ppsheep.com/tags/Swift%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS-有效编写高质量Objective-C方法(五)</title>
    <link href="http://ppsheep.com/2016/12/28/iOS-%E6%9C%89%E6%95%88%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FObjective-C%E6%96%B9%E6%B3%95-%E4%BA%94/"/>
    <id>http://ppsheep.com/2016/12/28/iOS-有效编写高质量Objective-C方法-五/</id>
    <published>2016-12-28T09:41:04.000Z</published>
    <updated>2017-01-05T08:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们前面的4篇文章，已经将Effective OC 的前两章节讲完了，接下来几篇文章，主要会讲我们在平时编码中的一些习惯，一些细节问题的处理，包括接口和API的设计，协议delegate和分类的使用等。<br><a id="more"></a></p>
<h4 id="用前缀避免命名空间的冲突"><a href="#用前缀避免命名空间的冲突" class="headerlink" title="用前缀避免命名空间的冲突"></a>用前缀避免命名空间的冲突</h4><p>因为OC和其他语言不同，没有命名空间这一说法，因此，我们在给类起名时，要设法避免潜在的命名冲突。发生命名冲突时，我们经常会看到这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">duplicate symbol _OBJC_METACLASS_$_XXXXX in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div><div class="line">duplicate symbol _OBJC_CLASS_$_XXXXX in:</div><div class="line">	build/something.o</div><div class="line">	build/something_else.o</div></pre></td></tr></table></figure>
<p>上面的情况，意思为有两个地方都实现了名为XXXXX的类，这种情况，往往出现在，我们引用多个第三方库，第三方库之间命名冲突、或者是我们自己工程中的命名与第三方库冲突。</p>
<p>所以我们在编写类名时，一般都会加上跟自己工程相关的一些前缀，而且在xcode中是有一个功能，让我们在新建类时，自动给我们加上前缀：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-05-064844.jpg" alt=""></p>
<p>这样在我们新建类时，默认就会有一个PPS的前缀：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-05-065009.jpg" alt=""></p>
<p><strong>注意:</strong></p>
<p>如果你正在编写第三方库，供别人使用，那么请一定要为你的所有类名加上你自定义的前缀，这样，别人用你的SDK才不会出现上面的冲突情况，这一点非常重要。</p>
<h4 id="提供“全能初始化方法”"><a href="#提供“全能初始化方法”" class="headerlink" title="提供“全能初始化方法”"></a>提供“全能初始化方法”</h4><p>首先，我们来解释一下什么是全能初始化方法：</p>
<p>举个例子吧</p>
<p>在NSDate类中，初始化方法有下面这几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (instancetype)init;</div><div class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;</div><div class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</div></pre></td></tr></table></figure>
<p>在上面的几个初始化方法中，(instancetype)initWithTimeIntervalSinceReferenceDate:是全能初始化方法，意思就是</p>
<p>其他的初始化方法，都是最终都是调用它，生成了NSDate类。</p>
<p>为什么要引入全能初始化方法这个概念呢？在我们平时编码中，经常在生成一个类时，传入一些参数，才能使这个类进行正常的工作，如果我们设计时，这个类有很多的初始化方法，然而进行一段时间编码过后，我们发觉需要修改这个类的底层数据，就是生成这个类必须要使用到的一些数据，那么，这么多的初始化方法，我们都得修改，如果我们有一个全能初始化方法，那么我们只需要改动这个全能初始化方法，底层数据就已经改变。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>这里还是引入一个例子：</p>
<p>比如我们要编写一个表示矩形的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCRectangle : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign, readonly) float width;</div><div class="line">@property (nonatomic, assign, readonly) float height;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里，为什么将长宽设置成readonly，我们在后面一篇文章中讲，这样一来，我们就需要提供一个初始方法来设置这两个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (instancetype)initWithWidth:(float)width</div><div class="line">                    andHeight:(float)height;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)initWithWidth:(float)width andHeight:(float)height&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们会碰到一个问题，如果有人直接用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[EOCRectangle alloc] init];</div></pre></td></tr></table></figure>
<p>这个方法来初始化，我们 的长宽不是没办法设置了，那这个类肯定不能正常工作，我们不希望看到这种情况发生，通常，我们有两种方法处理：</p>
<p>第一，在init方法中，传入默认的值，就是讲类必须的参数的默认值传入，形成一个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)init&#123;</div><div class="line">    return [self initWithWidth:5.0f andHeight:10.0f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种方法，是我们不希望开发者调用init方法，这样类就不能正常工作，我们可以在init方法中，抛出异常，但是一般我们不这样处理，在OC中，只有发生严重错误时，我们才抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)init&#123;</div><div class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;不允许调用这个初始化方法，请调用initWithWidth:andHeight:方法&quot; userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="在继承中处理全能初始化方法"><a href="#在继承中处理全能初始化方法" class="headerlink" title="在继承中处理全能初始化方法"></a>在继承中处理全能初始化方法</h5><p>如果我们现在需要创建一个正方形类EOCSquare类，让他继承自EOCRectangle类，这很正常，正方形的长宽必须相等。那么我们需要提供一个传入边长的初始化方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (instancetype)initWithDimension:(float)dimension;</div></pre></td></tr></table></figure>
<p>在实现中：调用父类的方法，传入相同的长宽，即是一个正方形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (instancetype)initWithDimension:(float)dimension&#123;</div><div class="line">    return [super initWithWidth:dimension andHeight:dimension];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，即使我们提供了传入边长的初始化，方法，调用者还是可能会调用initWithWidth:andHeight:或者init方法来初始化，这是我们不愿意看到的，于是就有一个重要的结论：</p>
<p><strong>如果子类的全能初始化方法和父类的全能初始化方法不同，那么总是应该覆写父类的全能初始化方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)initWithWidth:(float)width andHeight:(float)height&#123;</div><div class="line">    float dimension = MAX(width, height);</div><div class="line">    return [self initWithDimension:dimension];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时，我们发现，不管调用者调用了initWithWidth:andHeight:还是init方法，都能够正常初始化EOCSquare了，因为如果开发者调用initWithWidth:andHeight:，那么因为我们EOCSquare覆写了，所以调用的是EOCSquare的方法，如果调用者调用了init方法，那么最终调用到的还是EOCSquare的全能初始化方法。</p>
<p>但是，我们一般不覆写父类的全能初始化方法，这样显得毫不合理，改变父类的全能初始化方法逻辑，所以我们一般这样处理，在子类中，覆盖父类的全能初始化方法，并且抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)initWithWidth:(float)width andHeight:(float)height&#123;</div><div class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;不允许调用这个初始化方法，请调用initWithDimension:方法&quot; userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，我们还需要覆写init方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(instancetype)init&#123;</div><div class="line">    return [self initWithDimension:5.0f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就认为，开发者在初始化正方形时，只能传入相应的边长，如果传入长宽，那么认为是调用者自己犯了错误。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>在类中提供一个全能初始化方法，并指明其他初始化方法都需要调用全能初始化方法</li>
<li>若全能初始化方法不同，则子类应该覆写超类的全能初始化方法</li>
<li>如果超类的全能初始化方法不适用于子类，那么应该在子类中覆写超类的全能初始化方法,并且在其中抛出异常</li>
</ul>
<h4 id="实现description"><a href="#实现description" class="headerlink" title="实现description"></a>实现description</h4><p>在调试程序时，我们经常需要将对象的信息打印出来，最常用到的方式就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSLog(@&quot;object = %@&quot;,object);</div></pre></td></tr></table></figure>
<p>在打印数组或者字典上，这样是很好用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSArray *arr = @[@&quot;111&quot;,@&quot;222&quot;];</div><div class="line">NSLog(@&quot;arr = %@&quot;,arr);</div><div class="line"></div><div class="line">//打印出</div><div class="line">arr = (</div><div class="line">    111,</div><div class="line">    222</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是如我们在自定义的类中，就不会像刚才那样输出了，输出的往往是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">EOCRectangle *rectangle = [[EOCRectangle alloc] initWithWidth:10 andHeight:5];</div><div class="line">NSLog(@&quot;rectangle = %@&quot;, rectangle);</div><div class="line"></div><div class="line">//打印输出</div><div class="line">rectangle = &lt;EOCRectangle: 0x1740068f0&gt;</div></pre></td></tr></table></figure>
<p>输出的是一堆内存地址</p>
<p>这样一点也不好调试，要想输出对象的信息，我们需要在类中，重写description方法，在写的时候，我们可以借助NSDictionary的输出格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(NSString *)description&#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@:%p,%@&quot;,</div><div class="line">            [self class],</div><div class="line">            self,</div><div class="line">          @&#123;</div><div class="line">            @&quot;width&quot;:@(_width),</div><div class="line">            @&quot;height&quot;:@(_height),</div><div class="line">            &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们的输出就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">rectangle = EOCRectangle:0x17000b2b0, &#123;</div><div class="line">    height = 5;</div><div class="line">    width = 10;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单明了</p>
<p>还有一个方法:debugDescription</p>
<p>这个方法，是我们在调试的时候，打断点，在xcode的控制台输出的时候，需要打印的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(NSString *)debugDescription&#123;</div><div class="line">    return @&quot;po 的时候打印我&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在类EOCRectangle重写了debugDescription方法，然后再控制台打印</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2017-01-05-082705.jpg" alt=""></p>
<p>这下明白了吧，好，今天先到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们前面的4篇文章，已经将Effective OC 的前两章节讲完了，接下来几篇文章，主要会讲我们在平时编码中的一些习惯，一些细节问题的处理，包括接口和API的设计，协议delegate和分类的使用等。&lt;br&gt;
    
    </summary>
    
      <category term="iOS 编写高质量代码的方法" scheme="http://ppsheep.com/categories/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="iOS 编写高质量代码" scheme="http://ppsheep.com/tags/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS-有效编写高质量Objective-C方法(四)</title>
    <link href="http://ppsheep.com/2016/12/28/iOS-%E6%9C%89%E6%95%88%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FObjective-C%E6%96%B9%E6%B3%95-%E5%9B%9B/"/>
    <id>http://ppsheep.com/2016/12/28/iOS-有效编写高质量Objective-C方法-四/</id>
    <published>2016-12-28T07:45:28.000Z</published>
    <updated>2016-12-29T03:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到上一次发这个系列的文章，已经是一个月之前了，我的妈呀，这个时间过得挺快的，一下一个来月过去了，到现在才来更，真是对不起大家了，当时我记得是说重新来读一遍Effective Objective-C 确实呢，书有在读，就完成了第二章节，现在呢，我们继续。。。</p>
<a id="more"></a>
<h3 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h3><p>在对象上调用方法是Objective-C常用的功能。用Objc的术语来讲，叫做“传递消息”。消息有“名称(name)”或“选择子(selector)”，可以接受参数，而且可以有返回值。</p>
<p>由于OC是C的超集，所以最好先理解C语言的函数调用方式。C语言使用“静态绑定”，也就是说，在编译期间，就能够知道所应该调用的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void printHello()&#123;</div><div class="line">    printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printGoodBye()&#123;</div><div class="line">    printf(&quot;Goodbye world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doTheThing(int type)&#123;</div><div class="line">    if (type == 0) &#123;</div><div class="line">        printHello();</div><div class="line">    &#125;else&#123;</div><div class="line">        printGoodBye();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不考虑内联关系，那么编译器在编译代码的时候就已经知道了程序中有printHello和printGoodBye这两个函数了，如果我们将编写的方式改变一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void printHello()&#123;</div><div class="line">    printf(&quot;Hello world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printGoodBye()&#123;</div><div class="line">    printf(&quot;Goodbye world\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doTheThing(int type)&#123;</div><div class="line">    void (*fnc)();</div><div class="line">    if (type == 0) &#123;</div><div class="line">        fnc = printHello;</div><div class="line">    &#125;else&#123;</div><div class="line">        fnc = printGoodBye;</div><div class="line">    &#125;</div><div class="line">    fnc();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下，就必须要使用动态绑定了，因为需要调用的函数，在运行期间才能够知道。在objc中，要向对象传递消息，就必须要使用到动态绑定的机制来决定需要调用的方法。</p>
<p>给对象传递消息，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<p>在上面代码中，someObject叫做接收者，messageName叫做选择子，选择子和参数合起来叫做消息。编译器在看到该消息后，将其转化成为一条标准的C语言函数调用，所调用的函数叫做objc_msgSend，其原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void objc_msgSend(id self,SEL cmd,...)</div></pre></td></tr></table></figure>
<p>这是一个参数可变的函数，其中第一个参数代表的是接收者，第二个代表的是选择子，第三个以及后面的代表的是参数，编译器会把上面的传递消息的例子改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id returnValue = objc_msgSend(someObject,@selector(messageName:),</div><div class="line">									parameter);</div></pre></td></tr></table></figure>
<p>objc_msgSend函数会根据接收者和选择子来选择调用的方法，改函数会在接收者的类中寻找方法列表，如果能找到与选择子名称相符的方法，就跳至其，实现代码，如果找不到，那就继续沿着继承体系往上找，如果最终还是找不到方法，那么就会执行”消息转发“操作</p>
<p>这样看来，好像我们调用一个方法需要很多步骤，所幸的是，objc_msgSend会将匹配结果缓存子啊一张快速映射表中，这样一来，每个类都会有一个缓存，这样虽然第一次执行起来会稍慢，但是后面就会很迅速了。</p>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><p>上面我们讲了消息传递机制，接下来我们继续讲另外一个重要的问题，就是对象在接收到无法解读的消息时，会发生什么？</p>
<p>如果我们想让类理解某条消息，我们必须以程序代码的形式实现出对应的方法才行，但是在编译期间，向类发送了无法解读的方法并不会报错，因为在运行期间可以继续向类中添加方法，所以编译器在编译时还无法确定类中是否有某个方法的实现。当对象接收到无法解读的方法时，就会启动消息转发机制，我们可以经此告诉对象应该如何处置这条消息。</p>
<p>我们之前在编码过程中肯定有遇到过下面这种错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-[__NSCFNumber lowercaseString] : unrecognized selector sen to instance 0x87</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>上面这一段消息是由NSObject的 “doesNotRecognizeSelector:” 方法跑出的，此异常表明：消息接收者的类型是 __NSCFNumber，而该接收者无法理解名为lowercaseString的选择子。因为NSNumver中本就没有这个方法。</p>
<p>消息转发分为两大阶段：</p>
<ul>
<li>第一阶段 先征询接收者，所属的类，看其是否能动态添加方法，用以处理当前这个“未知的选择子”，这叫做“动态方法解析”。</li>
<li>第二阶段 涉及到了完整的消息转发机制，如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法来响应包含选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这里又可分为两步：<br>  首先，请接收者看看有没有其他的对象能够处理这条消息，若有，运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。若没有，备援的接收者则会启动完整的消息转发机制，运行期系统会把与消息相关的所有细节全部封装到NSInvocation对象中，再给接收者一次机会，令其处理。</li>
</ul>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>在对象收到无法解析的消息后，首先会调用其所属类的下列方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (Bool)resolveInstanceMethod:(SEL)selector</div></pre></td></tr></table></figure>
<p>该方法的参数就是那个未知的选择子，返回的值表示该类是否能够新增一个方法来处理当前的选择子</p>
<p>假设未实现的方法不是实例方法，而是类方法，那么运行期系统会调用另外一个方法 叫做 resolveClassMethod:</p>
<p>使用动态方法解析的前提是：相关的代码已经写好了，只等运行的时候动态插入到类中即可。<br>这种方案常用来实现@dynamic属性，这个属性之前我们已经讲过，有疑问的同学翻看一下我前面的博客。</p>
<p>比如说我们要访问CoreData框架中的NSManagerObjects对象的属性时，就可以这样做，因为这些属性所需要的存取方法在编译器就可以确定。</p>
<p>我们模拟一下，使用resolveInstanceMethod方法，来实现@dynamic属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id autoDictionaryGetter(id self, SEL _cmd);</div><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value);</div><div class="line"></div><div class="line">+ (Bool)resolveInstanceMethod:(SEL)selector&#123;</div><div class="line">	NSString *selectorString = NSStringFromSelector(selector);</div><div class="line">	if(/* selector is from a @dynamic property */)&#123;//这里的意思是判断属性是声明成了@dynamic</div><div class="line">	if([selectorString hasPrefix:@&quot;set&quot;])&#123;</div><div class="line">		class_addMethod(self, </div><div class="line">						   selector, </div><div class="line">						   (IMP)autoDictionarySetter),</div><div class="line">						   &quot;v@:@&quot;);</div><div class="line">	&#125;else&#123;</div><div class="line">		class_addMethod(self, </div><div class="line">						   selector, </div><div class="line">						   (IMP) autoDictionaryGetter),</div><div class="line">						   &quot;@:@&quot;);</div><div class="line">	&#125;</div><div class="line">	return YES;</div><div class="line">	&#125;</div><div class="line">	return [super resolveInstanceMethod:selector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们已经在代码中处理了 set方法和get方法</p>
<h5 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h5><p>当前的接收者除了resolveInstanceMethod，还有第二次机会处理未知的选择子。在这一步中，运行系统会询问，能否将这一消息转发给其他的接收者来处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (id)forwardingTargetSelector:(SEL)selector;</div></pre></td></tr></table></figure>
<p>如果找到当前的备援者，则将其直接返回，如果找不到，则返回Nil</p>
<p>为什么会存在备援者呢？在一个对象内部，可能还有其他一系列对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，就像是自己处理的一样。</p>
<h5 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h5><p>如果备援者还找不到，那么就需要执行完整的消息转发机制。首先创建NSInvocation对象，将尚未处理的消息相关的所有细节，全部封装。在触发NSInvocation对象时，”消息派发系统”将亲自将消息指派给目标对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)invocation;</div></pre></td></tr></table></figure>
<p>这个方法很简单，只需要改变调用目标，是消息在新目标上调用，但是这样就和备援者差不多了，我们一般这样处理：<br>在触发消息之前，先以某种方式改变消息的内容，比如改参数或者改选择子</p>
<p>实现此方法时，若发现某调用操作不应该由本类实现，那么就由其超类同名方法实现，直至NSObject</p>
<h5 id="消息转发全过程"><a href="#消息转发全过程" class="headerlink" title="消息转发全过程"></a>消息转发全过程</h5><p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-29-032256.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到上一次发这个系列的文章，已经是一个月之前了，我的妈呀，这个时间过得挺快的，一下一个来月过去了，到现在才来更，真是对不起大家了，当时我记得是说重新来读一遍Effective Objective-C 确实呢，书有在读，就完成了第二章节，现在呢，我们继续。。。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 编写高质量代码的方法" scheme="http://ppsheep.com/categories/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="iOS 编写高质量代码" scheme="http://ppsheep.com/tags/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Swift谈一谈</title>
    <link href="http://ppsheep.com/2016/12/28/swift%E8%B0%88%E4%B8%80%E8%B0%88/"/>
    <id>http://ppsheep.com/2016/12/28/swift谈一谈/</id>
    <published>2016-12-28T03:48:07.000Z</published>
    <updated>2016-12-28T07:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift你爱不爱"><a href="#Swift你爱不爱" class="headerlink" title="Swift你爱不爱"></a>Swift你爱不爱</h3><p>Swift 3发布已经有一段时间了，如果已经有同学在使用Swift，那么从2.3迁移到3.0，我想肯定是极其痛苦的，在ABI稳定性方面，2.x和3.0相比，有较大的改动。不过，苹果官方宣布，在将来的Swift 3到Swift 4，会保持ABI稳定，那么也就是意味着，Swift的ABI相对稳定了，那此时是否就是正式投入Swift的时间了，其实呢，这个还是看自己。 在我自己的平时工作中，主要还是使用的OC，因为毕竟需要合作，不能说你用，大家都要跟着你用，不过这也是一个大的趋势，使用Swift的开发者越来越多，称赞Swift的开发者也是越来越多，那我自己内心也是想开搞的，虽说不会及时使用到工作中，自己玩玩也是可以的。其实现在开始已经相对较晚了。</p>
<a id="more"></a>
<h3 id="我对Swift的爱"><a href="#我对Swift的爱" class="headerlink" title="我对Swift的爱"></a>我对Swift的爱</h3><p>Swift 我一直在尝试，但是却因为工作上，没有将它考虑在内，所以一直都停止在尝试。结合到我现在的工作环境，我觉得在将来很长的一段时间内，它还是不会加入到我的工作中来，但是我在想，我需要改变我对他的态度的。如果不作出改变的话，我将一直停留在  只知道他的拼写而已，其他的一无所知。</p>
<p>在Swift 3发布之时，苹果宣布，将在2017年春节之时发布3.x , 4.0也将在2017年秋季发布，我们看到了苹果对于Swift所作出的努力，那我们作为开发者，是否也应该作出一些努力。</p>
<h3 id="我对Swift的学习规划"><a href="#我对Swift的学习规划" class="headerlink" title="我对Swift的学习规划"></a>我对Swift的学习规划</h3><p>之前我大致浏览过swift2.0 官方教程的  中译版<br><a href="http://www.swiftguide.cn" target="_blank" rel="external">http://www.swiftguide.cn</a></p>
<p>至于我还记得多少，嘿嘿嘿。。。你猜。。。</p>
<p>所以我打算呢，还是再过一遍官方的教程，这次呢，我不打算看中译版了，我还是去iBook上看原版吧。顺便提一句，现在国内iBook已经不可用了，你需要上美国的商店，才能找到官方的教程，这个嘛，可以申请一个美国的账号咯，至于方法，Google一下，或者 国内某大型搜索引擎网站，搜索一下。不过好像之前我有同事去搜过，好像现在不行了，一定要求绑定支付方式，最后他一怒之下，某宝了一个，哈哈哈哈，笑死我了。。。</p>
<p>如果你们又需要，可以联系我，我直接发你们一份，我就不直接放上来了。。。我的联系方式，我放了微信上来的，我记得，在关于我里面。</p>
<h3 id="Swift-你来吗？"><a href="#Swift-你来吗？" class="headerlink" title="Swift 你来吗？"></a>Swift 你来吗？</h3><p>后面我也将会把我的学习过程放到博客上来，你要一起来吗? 对了，我还在Objc中国上面买了几本Swift的书，那些书可真是不错，为什么说不错，因为我现在看不懂，看不懂，我就觉得他们写的很好，要是我现在就看得懂，那还学个屁！！！建议呢，这些书，可以在看完官方教程后，再来阅读，喵神维护的网站，还是很不错的，上面还有很多之前从objc.io翻译过来的博客，质量都很高的，有时间也可以阅读。</p>
<h3 id="关于之前博客停更的说明"><a href="#关于之前博客停更的说明" class="headerlink" title="关于之前博客停更的说明"></a>关于之前博客停更的说明</h3><p>最近几周，博客更新都很慢，主要原因呢，是要赶两个SDK，说来话长，某一天，我的领导不想跟我讲话，并向我扔出了2个SDK，然后我就傻逼了，并且还甩出了多少天拿出来，这样的话，期间呢，还到广州出差了一周，是的，你没听错，我，一个程序员，也出差了！！！我是昨天刚回到杭州，在出差期间呢，也是能挤出一点时间来更新一下，但是呢，你知道吗？广州的茶点心，真是不错，剩余时间，全部拿出来，去吃了，真是不好意思，可惜没有怎么拍照片，下次去了，一定拍几张照片发上来。</p>
<p>废话讲完了，一不小心，打了这么多字！！！！尴尬</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Swift你爱不爱&quot;&gt;&lt;a href=&quot;#Swift你爱不爱&quot; class=&quot;headerlink&quot; title=&quot;Swift你爱不爱&quot;&gt;&lt;/a&gt;Swift你爱不爱&lt;/h3&gt;&lt;p&gt;Swift 3发布已经有一段时间了，如果已经有同学在使用Swift，那么从2.3迁移到3.0，我想肯定是极其痛苦的，在ABI稳定性方面，2.x和3.0相比，有较大的改动。不过，苹果官方宣布，在将来的Swift 3到Swift 4，会保持ABI稳定，那么也就是意味着，Swift的ABI相对稳定了，那此时是否就是正式投入Swift的时间了，其实呢，这个还是看自己。 在我自己的平时工作中，主要还是使用的OC，因为毕竟需要合作，不能说你用，大家都要跟着你用，不过这也是一个大的趋势，使用Swift的开发者越来越多，称赞Swift的开发者也是越来越多，那我自己内心也是想开搞的，虽说不会及时使用到工作中，自己玩玩也是可以的。其实现在开始已经相对较晚了。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://ppsheep.com/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://ppsheep.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS获取当前设备的信息-网络相关</title>
    <link href="http://ppsheep.com/2016/12/16/iOS%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%A1%E6%81%AF-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    <id>http://ppsheep.com/2016/12/16/iOS获取当前设备的信息-网络相关/</id>
    <published>2016-12-16T06:57:18.000Z</published>
    <updated>2017-01-03T05:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="获取当前设备的IP地址"><a href="#获取当前设备的IP地址" class="headerlink" title="获取当前设备的IP地址"></a>获取当前设备的IP地址</h3><p>对于公网的IP当然，在我们本地设备上是不能够获取到的，至少我没有找到方法获取到出口IP地址，但是局域网的IP还是能够获取到的，这里ipv4和ipv6 都能够获取出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSString *)deviceIPAdress</div><div class="line">&#123;</div><div class="line">    NSString *address = @&quot;&quot;;</div><div class="line">    struct ifaddrs *interfaces = NULL;</div><div class="line">    struct ifaddrs *temp_addr = NULL;</div><div class="line">    int success = 0;</div><div class="line">    </div><div class="line">    success = getifaddrs(&amp;interfaces);</div><div class="line">    </div><div class="line">    if (success == 0) &#123;  // 0 表示获取成功</div><div class="line">        </div><div class="line">        temp_addr = interfaces;</div><div class="line">        while (temp_addr != NULL) &#123;</div><div class="line">            </div><div class="line">            if ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;] || [[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;pdp_ip0&quot;])</div><div class="line">                &#123;</div><div class="line">                //如果是IPV4地址，直接转化</div><div class="line">                if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET)&#123;</div><div class="line">                    </div><div class="line">                    // Get NSString from C String</div><div class="line">                    address = [self formatIPV4Address:((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                //如果是IPV6地址</div><div class="line">                else if (temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET6)&#123;</div><div class="line">                    address = [self formatIPV6Address:((struct sockaddr_in6 *)temp_addr-&gt;ifa_addr)-&gt;sin6_addr];</div><div class="line">                    if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) break;</div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            temp_addr = temp_addr-&gt;ifa_next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    freeifaddrs(interfaces);</div><div class="line">    </div><div class="line">    //以FE80开始的地址是单播地址</div><div class="line">    if (address &amp;&amp; ![address isEqualToString:@&quot;&quot;] &amp;&amp; ![address.uppercaseString hasPrefix:@&quot;FE80&quot;]) &#123;</div><div class="line">        return address;</div><div class="line">    &#125; else &#123;</div><div class="line">        return @&quot;127.0.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前设备网关地址"><a href="#获取当前设备网关地址" class="headerlink" title="获取当前设备网关地址"></a>获取当前设备网关地址</h3><p>网关地址，通俗点  就是路由器的地址，也是相对于局域网 这里需要区分一下ipv4和ipv6，两种获取网关地址的方法是不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//ipv4网关地址</div><div class="line">+ (NSString *)getGatewayIPV4Address</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    /* net.route.0.inet.flags.gateway */</div><div class="line">    int mib[] = &#123;CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_GATEWAY&#125;;</div><div class="line">    </div><div class="line">    size_t l;</div><div class="line">    char *buf, *p;</div><div class="line">    struct rt_msghdr *rt;</div><div class="line">    struct sockaddr *sa;</div><div class="line">    struct sockaddr *sa_tab[RTAX_MAX];</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">        address = @&quot;192.168.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (l &gt; 0) &#123;</div><div class="line">        buf = malloc(l);</div><div class="line">        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">            address = @&quot;192.168.0.1&quot;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (p = buf; p &lt; buf + l; p += rt-&gt;rtm_msglen) &#123;</div><div class="line">            rt = (struct rt_msghdr *)p;</div><div class="line">            sa = (struct sockaddr *)(rt + 1);</div><div class="line">            for (i = 0; i &lt; RTAX_MAX; i++) &#123;</div><div class="line">                if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) &#123;</div><div class="line">                    sa_tab[i] = sa;</div><div class="line">                    sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa-&gt;sa_len));</div><div class="line">                &#125; else &#123;</div><div class="line">                    sa_tab[i] = NULL;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (((rt-&gt;rtm_addrs &amp; (RTA_DST | RTA_GATEWAY)) == (RTA_DST | RTA_GATEWAY)) &amp;&amp;</div><div class="line">                sa_tab[RTAX_DST]-&gt;sa_family == AF_INET &amp;&amp;</div><div class="line">                sa_tab[RTAX_GATEWAY]-&gt;sa_family == AF_INET) &#123;</div><div class="line">                unsigned char octet[4] = &#123;0, 0, 0, 0&#125;;</div><div class="line">                int i;</div><div class="line">                for (i = 0; i &lt; 4; i++) &#123;</div><div class="line">                    octet[i] = (((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))-&gt;sin_addr.s_addr &gt;&gt;</div><div class="line">                                (i * 8)) &amp;</div><div class="line">                    0xFF;</div><div class="line">                &#125;</div><div class="line">                if (((struct sockaddr_in *)sa_tab[RTAX_DST])-&gt;sin_addr.s_addr == 0) &#123;</div><div class="line">                    in_addr_t addr =</div><div class="line">                    ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))-&gt;sin_addr.s_addr;</div><div class="line">                    address = [self formatIPV4Address:*((struct in_addr *)&amp;addr)];</div><div class="line">                    //                    NSLog(@&quot;IPV4address%@&quot;, address);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(buf);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//ipv6网关地址</div><div class="line">+ (NSString *)getGatewayIPV6Address</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    /* net.route.0.inet.flags.gateway */</div><div class="line">    int mib[] = &#123;CTL_NET, PF_ROUTE, 0, AF_INET6, NET_RT_FLAGS, RTF_GATEWAY&#125;;</div><div class="line">    </div><div class="line">    size_t l;</div><div class="line">    char *buf, *p;</div><div class="line">    struct rt_msghdr *rt;</div><div class="line">    struct sockaddr_in6 *sa;</div><div class="line">    struct sockaddr_in6 *sa_tab[RTAX_MAX];</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">        address = @&quot;192.168.0.1&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (l &gt; 0) &#123;</div><div class="line">        buf = malloc(l);</div><div class="line">        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &amp;l, 0, 0) &lt; 0) &#123;</div><div class="line">            address = @&quot;192.168.0.1&quot;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (p = buf; p &lt; buf + l; p += rt-&gt;rtm_msglen) &#123;</div><div class="line">            rt = (struct rt_msghdr *)p;</div><div class="line">            sa = (struct sockaddr_in6 *)(rt + 1);</div><div class="line">            for (i = 0; i &lt; RTAX_MAX; i++) &#123;</div><div class="line">                if (rt-&gt;rtm_addrs &amp; (1 &lt;&lt; i)) &#123;</div><div class="line">                    sa_tab[i] = sa;</div><div class="line">                    sa = (struct sockaddr_in6 *)((char *)sa + sa-&gt;sin6_len);</div><div class="line">                &#125; else &#123;</div><div class="line">                    sa_tab[i] = NULL;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if( ((rt-&gt;rtm_addrs &amp; (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))</div><div class="line">               &amp;&amp; sa_tab[RTAX_DST]-&gt;sin6_family == AF_INET6</div><div class="line">               &amp;&amp; sa_tab[RTAX_GATEWAY]-&gt;sin6_family == AF_INET6)</div><div class="line">                &#123;</div><div class="line">                address = [self formatIPV6Address:((struct sockaddr_in6 *)(sa_tab[RTAX_GATEWAY]))-&gt;sin6_addr];</div><div class="line">                //                NSLog(@&quot;IPV6address%@&quot;, address);</div><div class="line">                break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        free(buf);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在获取的时候判断一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*!</div><div class="line"> * 获取当前设备网关地址</div><div class="line"> */</div><div class="line">+ (NSString *)getGatewayIPAddress&#123;</div><div class="line">    NSString *address = nil;</div><div class="line">    </div><div class="line">    NSString *gatewayIPV4 = [self getGatewayIPV4Address];</div><div class="line">    NSString *gatewayIPV6 = [self getGatewayIPV6Address];</div><div class="line">    </div><div class="line">    if (gatewayIPV6 != nil) &#123;</div><div class="line">        address = gatewayIPV6;</div><div class="line">    &#125; else &#123;</div><div class="line">        address = gatewayIPV4;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return address;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过域名拿到域名对应的IP地址-CDN"><a href="#通过域名拿到域名对应的IP地址-CDN" class="headerlink" title="通过域名拿到域名对应的IP地址(CDN)"></a>通过域名拿到域名对应的IP地址(CDN)</h3><p>通过域名拿到的IP地址，一般来说，如果买了CDN的话，拿到的Ip都会是多个IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/*!</div><div class="line"> * 通过hostname获取ip列表 DNS解析地址</div><div class="line"> */</div><div class="line">+ (NSArray *)getDNSsWithDormain:(NSString *)hostName&#123;</div><div class="line">    NSMutableArray *result = [[NSMutableArray alloc] init];</div><div class="line">    NSArray *IPDNSs = [self getDNSWithHostName:hostName];</div><div class="line">    if (IPDNSs &amp;&amp; IPDNSs.count &gt; 0) &#123;</div><div class="line">        [result addObjectsFromArray:IPDNSs];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [NSArray arrayWithArray:result];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (NSArray *)getDNSWithHostName:(NSString *)hostName</div><div class="line">&#123;</div><div class="line">    const char *hostN = [hostName UTF8String];</div><div class="line">    Boolean result = false;</div><div class="line">    Boolean bResolved = false;</div><div class="line">    CFHostRef hostRef;</div><div class="line">    CFArrayRef addresses = NULL;</div><div class="line">    </div><div class="line">    CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, hostN, kCFStringEncodingASCII);</div><div class="line">    </div><div class="line">    hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);</div><div class="line">    if (hostRef) &#123;</div><div class="line">        result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);</div><div class="line">        if (result == true) &#123;</div><div class="line">            addresses = CFHostGetAddressing(hostRef, &amp;result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    bResolved = result;</div><div class="line">    NSMutableArray *ipAddresses = [NSMutableArray array];</div><div class="line">    if(bResolved)</div><div class="line">        &#123;</div><div class="line">        struct sockaddr_in* remoteAddr;</div><div class="line">        </div><div class="line">        for(int i = 0; i &lt; CFArrayGetCount(addresses); i++)</div><div class="line">            &#123;</div><div class="line">            CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i);</div><div class="line">            remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData);</div><div class="line">            </div><div class="line">            if(remoteAddr != NULL)</div><div class="line">                &#123;</div><div class="line">                //获取IP地址</div><div class="line">                const char *strIP41 = inet_ntoa(remoteAddr-&gt;sin_addr);</div><div class="line">                NSString *strDNS =[NSString stringWithCString:strIP41 encoding:NSASCIIStringEncoding];</div><div class="line">                [ipAddresses addObject:strDNS];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    CFRelease(hostNameRef);</div><div class="line">    if (hostRef) &#123;</div><div class="line">        CFRelease(hostRef);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [NSArray arrayWithArray:ipAddresses];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前的网络状况"><a href="#获取当前的网络状况" class="headerlink" title="获取当前的网络状况"></a>获取当前的网络状况</h3><p>如果是WIFI环境，直接返回wifi  如果是蜂窝网络环境，那么还可以区分到底是那个运营商，还可以区分是使用的什么网络，4G 3G 2G等  运营商暂时区分了国内的三大运营商，如果还需要区分国外的，可以维基百科上查对应的code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">+(NSString *)currentNetInfo&#123;</div><div class="line">    </div><div class="line">    NSString *returnName = nil;</div><div class="line">    </div><div class="line">    PPSNetWorkType type = [PPSGetAppEnvironment getNetworkTypeFromStatusBar];</div><div class="line">    if (type == PPSNetWorkTypeWiFi) &#123;</div><div class="line">        returnName = @&quot;WIFI&quot;;</div><div class="line">        return returnName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString *carrierName = nil;</div><div class="line">    CTTelephonyNetworkInfo *netInfo = [[CTTelephonyNetworkInfo alloc] init];</div><div class="line">    CTCarrier *carrier = [netInfo subscriberCellularProvider];</div><div class="line">    if (carrier != NULL) &#123;</div><div class="line">        NSArray *chinaMobileMics = @[@&quot;0&quot;,@&quot;2&quot;,@&quot;7&quot;];//移动code</div><div class="line">        NSArray *chinaTelecomMics = @[@&quot;3&quot;,@&quot;5&quot;,@&quot;11&quot;];//电信code</div><div class="line">        NSArray *chinaUnicomMics = @[@&quot;1&quot;,@&quot;6&quot;];//联通code</div><div class="line">        NSString *mobileNetworkCode = [carrier mobileNetworkCode];</div><div class="line">        if ([chinaMobileMics containsObject:mobileNetworkCode]) &#123;</div><div class="line">            carrierName = @&quot;chinamobile&quot;;</div><div class="line">        &#125;else if ([chinaTelecomMics containsObject:mobileNetworkCode])&#123;</div><div class="line">            carrierName = @&quot;chinatelecom&quot;;</div><div class="line">        &#125;else if ([chinaUnicomMics containsObject:mobileNetworkCode])&#123;</div><div class="line">            carrierName = @&quot;chinaunicom&quot;;</div><div class="line">        &#125;else&#123;</div><div class="line">            carrierName = @&quot;unknown&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        carrierName = @&quot;unknown&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    switch (type) &#123;</div><div class="line">        case PPSNetWorkType2G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;2G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType3G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;3G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType4G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;4G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkType5G:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;5G&quot;];</div><div class="line">            break;</div><div class="line">        case PPSNetWorkTypeNone:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;unknown&quot;];</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            returnName = [NSString stringWithFormat:@&quot;%@_%@&quot;,carrierName,@&quot;unknown&quot;];</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return returnName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取当前的设备信息"><a href="#获取当前的设备信息" class="headerlink" title="获取当前的设备信息"></a>获取当前的设备信息</h3><p>获取当前设备的信息，是iPhone 4 5 6 7还是 等等  还有系统的版本号  手机、平板<br>之类的都能够去区分出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> 获取设备的类型</div><div class="line"> </div><div class="line"> @return 设备类型</div><div class="line"> */</div><div class="line">+ (NSString *)deviceInfo &#123;</div><div class="line">    struct utsname systemInfo;</div><div class="line">    </div><div class="line">    uname(&amp;systemInfo);</div><div class="line">    </div><div class="line">    NSString* code = [NSString stringWithCString:systemInfo.machine</div><div class="line">                                        encoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    static NSDictionary* deviceNamesByCode = nil;</div><div class="line">    </div><div class="line">    if (!deviceNamesByCode) &#123;</div><div class="line">        </div><div class="line">        deviceNamesByCode = @&#123;@&quot;i386&quot;      :@&quot;Simulator&quot;,</div><div class="line">                              @&quot;x86_64&quot;    :@&quot;Simulator&quot;,</div><div class="line">                              @&quot;iPod1,1&quot;   :@&quot;iPod Touch&quot;,        // (Original)</div><div class="line">                              @&quot;iPod2,1&quot;   :@&quot;iPod Touch&quot;,        // (Second Generation)</div><div class="line">                              @&quot;iPod3,1&quot;   :@&quot;iPod Touch&quot;,        // (Third Generation)</div><div class="line">                              @&quot;iPod4,1&quot;   :@&quot;iPod Touch&quot;,        // (Fourth Generation)</div><div class="line">                              @&quot;iPod7,1&quot;   :@&quot;iPod Touch&quot;,        // (6th Generation)</div><div class="line">                              @&quot;iPhone1,1&quot; :@&quot;iPhone&quot;,            // (Original)</div><div class="line">                              @&quot;iPhone1,2&quot; :@&quot;iPhone&quot;,            // (3G)</div><div class="line">                              @&quot;iPhone2,1&quot; :@&quot;iPhone&quot;,            // (3GS)</div><div class="line">                              @&quot;iPad1,1&quot;   :@&quot;iPad&quot;,              // (Original)</div><div class="line">                              @&quot;iPad2,1&quot;   :@&quot;iPad 2&quot;,            //</div><div class="line">                              @&quot;iPad3,1&quot;   :@&quot;iPad&quot;,              // (3rd Generation)</div><div class="line">                              @&quot;iPhone3,1&quot; :@&quot;iPhone 4&quot;,          // (GSM)</div><div class="line">                              @&quot;iPhone3,3&quot; :@&quot;iPhone 4&quot;,          // (CDMA/Verizon/Sprint)</div><div class="line">                              @&quot;iPhone4,1&quot; :@&quot;iPhone 4S&quot;,         //</div><div class="line">                              @&quot;iPhone5,1&quot; :@&quot;iPhone 5&quot;,          // (model A1428, AT&amp;T/Canada)</div><div class="line">                              @&quot;iPhone5,2&quot; :@&quot;iPhone 5&quot;,          // (model A1429, everything else)</div><div class="line">                              @&quot;iPad3,4&quot;   :@&quot;iPad&quot;,              // (4th Generation)</div><div class="line">                              @&quot;iPad2,5&quot;   :@&quot;iPad Mini&quot;,         // (Original)</div><div class="line">                              @&quot;iPhone5,3&quot; :@&quot;iPhone 5c&quot;,         // (model A1456, A1532 | GSM)</div><div class="line">                              @&quot;iPhone5,4&quot; :@&quot;iPhone 5c&quot;,         // (model A1507, A1516, A1526 (China), A1529 | Global)</div><div class="line">                              @&quot;iPhone6,1&quot; :@&quot;iPhone 5s&quot;,         // (model A1433, A1533 | GSM)</div><div class="line">                              @&quot;iPhone6,2&quot; :@&quot;iPhone 5s&quot;,         // (model A1457, A1518, A1528 (China), A1530 | Global)</div><div class="line">                              @&quot;iPhone7,1&quot; :@&quot;iPhone 6 Plus&quot;,     //</div><div class="line">                              @&quot;iPhone7,2&quot; :@&quot;iPhone 6&quot;,          //</div><div class="line">                              @&quot;iPhone8,1&quot; :@&quot;iPhone 6S&quot;,         //</div><div class="line">                              @&quot;iPhone8,2&quot; :@&quot;iPhone 6S Plus&quot;,    //</div><div class="line">                              @&quot;iPhone8,4&quot; :@&quot;iPhone SE&quot;,         //</div><div class="line">                              @&quot;iPhone9,1&quot; :@&quot;iPhone 7&quot;,          //</div><div class="line">                              @&quot;iPhone9,3&quot; :@&quot;iPhone 7&quot;,          //</div><div class="line">                              @&quot;iPhone9,2&quot; :@&quot;iPhone 7 Plus&quot;,     //</div><div class="line">                              @&quot;iPhone9,4&quot; :@&quot;iPhone 7 Plus&quot;,     //</div><div class="line">                              </div><div class="line">                              @&quot;iPad4,1&quot;   :@&quot;iPad Air&quot;,          // 5th Generation iPad (iPad Air) - Wifi</div><div class="line">                              @&quot;iPad4,2&quot;   :@&quot;iPad Air&quot;,          // 5th Generation iPad (iPad Air) - Cellular</div><div class="line">                              @&quot;iPad4,4&quot;   :@&quot;iPad Mini&quot;,         // (2nd Generation iPad Mini - Wifi)</div><div class="line">                              @&quot;iPad4,5&quot;   :@&quot;iPad Mini&quot;,         // (2nd Generation iPad Mini - Cellular)</div><div class="line">                              @&quot;iPad4,7&quot;   :@&quot;iPad Mini&quot;,         // (3rd Generation iPad Mini - Wifi (model A1599))</div><div class="line">                              @&quot;iPad6,7&quot;   :@&quot;iPad Pro (12.9\&quot;)&quot;, // iPad Pro 12.9 inches - (model A1584)</div><div class="line">                              @&quot;iPad6,8&quot;   :@&quot;iPad Pro (12.9\&quot;)&quot;, // iPad Pro 12.9 inches - (model A1652)</div><div class="line">                              @&quot;iPad6,3&quot;   :@&quot;iPad Pro (9.7\&quot;)&quot;,  // iPad Pro 9.7 inches - (model A1673)</div><div class="line">                              @&quot;iPad6,4&quot;   :@&quot;iPad Pro (9.7\&quot;)&quot;   // iPad Pro 9.7 inches - (models A1674 and A1675)</div><div class="line">                              &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString* deviceName = [deviceNamesByCode objectForKey:code];</div><div class="line">    </div><div class="line">    if (!deviceName) &#123;</div><div class="line">        // Not found on database. At least guess main device type from string contents:</div><div class="line">        </div><div class="line">        if ([code rangeOfString:@&quot;iPod&quot;].location != NSNotFound) &#123;</div><div class="line">            deviceName = @&quot;iPod Touch&quot;;</div><div class="line">        &#125;</div><div class="line">        else if([code rangeOfString:@&quot;iPad&quot;].location != NSNotFound) &#123;</div><div class="line">            deviceName = @&quot;iPad&quot;;</div><div class="line">        &#125;</div><div class="line">        else if([code rangeOfString:@&quot;iPhone&quot;].location != NSNotFound)&#123;</div><div class="line">            deviceName = @&quot;iPhone&quot;;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            deviceName = @&quot;Unknown&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    UIDevice *device = [UIDevice currentDevice];</div><div class="line">    NSString *systemVersion = [device systemVersion];</div><div class="line">    </div><div class="line">    return [NSString stringWithFormat:@&quot;iOS#%@#%@&quot;,deviceName,systemVersion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取的信息：</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-16-081639.jpg" alt=""></p>
<p>原项目地址：</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS获取当前设备的信息-网络相关" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS获取当前设备的信息-网络相关</a></p>
]]></content>
    
    <summary type="html">
    
      最近在搞网络相关的SDK，将自己在项目中能够开放出来的，记录下来，其中很多用到了C，相当于一个工具。后期还会选择开放一些ping网络的工具，找链路节点的工具，最近就在搞这个。
    
    </summary>
    
      <category term="iOS基础 网络组件" scheme="http://ppsheep.com/categories/iOS%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="域名解析 网络判断" scheme="http://ppsheep.com/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的并发编程</title>
    <link href="http://ppsheep.com/2016/12/14/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
    <id>http://ppsheep.com/2016/12/14/iOS中的并发编程-一/</id>
    <published>2016-12-14T07:09:03.000Z</published>
    <updated>2016-12-29T09:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="OS-X和iOS中的并发编程"><a href="#OS-X和iOS中的并发编程" class="headerlink" title="OS X和iOS中的并发编程"></a>OS X和iOS中的并发编程</h3><p>在OS X和iOS中，Apple都为我们提供了相同的并发编程API。pthread 、 NSThread 、GCD 、NSOperationQueue。</p>
<h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><p>pthread是比较底层的并发API，这个用起来并不是那么容易，而且在我们日常的编码过程中，我们也应该抛弃掉这种效率极低的并发编程方式。这里就不对这种并发做过多详细的介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p>NSThread这个我们听起来就很熟悉了，实际上，这是Apple对pthread的一个封装，封装成了Objectivc-C的接口API，在cocoa环境中，我们能够轻易使用NSThread来进行并发编程。</p>
<p>例如我们现在有这样一个场景，需要计算100万个数字中的最大数和最小数，首先我们可以定义一个NSThread的子类，专门来进行这个运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@interface FindMinMaxThread : NSThread</div><div class="line">@property (nonatomic) NSUInteger min;</div><div class="line">@property (nonatomic) NSUInteger max;</div><div class="line">- (instancetype)initWithNumbers:(NSArray *)numbers;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation FindMinMaxThread &#123;</div><div class="line">    NSArray *_numbers;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithNumbers:(NSArray *)numbers</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _numbers = numbers;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)main</div><div class="line">&#123;</div><div class="line">    NSUInteger min;</div><div class="line">    NSUInteger max;</div><div class="line">    // 进行相关数据的处理</div><div class="line">    self.min = min;</div><div class="line">    self.max = max;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的 start 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSMutableSet *threads = [NSMutableSet set];</div><div class="line">NSUInteger numberCount = self.numbers.count;</div><div class="line">NSUInteger threadCount = 4;</div><div class="line">for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;</div><div class="line">    NSUInteger offset = (count / threadCount) * i;</div><div class="line">    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);</div><div class="line">    NSRange range = NSMakeRange(offset, count);</div><div class="line">    NSArray *subset = [self.numbers subarrayWithRange:range];</div><div class="line">    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</div><div class="line">    [threads addObject:thread];</div><div class="line">    [thread start];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然，看起来这个多线程实现起来比较简单，但是呢，在实际的编码中，我们并不会采用这种方式来进行，并发编程。</p>
<p>这种方式，其实是我们自己来操作线程，进行并发编程，这样就涉及到一个问题，例如，我们在使用到AFNetworking 进行网络访问的时候，本身AF中已经对网络访问进行了异步的线程处理，如果我们在调用AF的时候，再次进行并发线程处理，那么我们使用NSThread这种方式进行并发编程的时候，就回造成线程的指数级增长，因为我们操作的都是单个的线程。开了这么多的线程，当然会造成内存和CPU的高度浪费，而且会造成其他的一些不必要的bug。</p>
<p>那正确的并发编程 的姿势 是什么，当然是  GCD 和 operation queue ——基于队列的并发编程。这两种方式，通过管理一个被大家协同使用的线程池，来解决上面的问题。</p>
<h4 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch(GCD)"></a>Grand Central Dispatch(GCD)</h4><p>通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个线程池。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p>
<p>GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</p>
<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-14-gcd-queues.png" alt=""></p>
<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p>
<p><strong>稍后我们将详细介绍GCD的使用</strong></p>
<h4 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h4><p>操作队列是Apple在GCD之上，实现了一些更方便的功能，更高级的AP，这些功能对于开发者来讲通常来说，是最安全的最好的选择。</p>
<p>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。</p>
<p>你可以通过重写 main 或者 start 方法 来定义自己的 operations 。前一种方法非常简单，开发者不需要管理一些状态属性（例如 isExecuting 和 isFinished），当 main 方法返回的时候，这个 operation 就结束了。这种方式使用起来非常简单，但是灵活性相对重写 start 来说要少一些。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@implementation YourOperation</div><div class="line">    - (void)main</div><div class="line">    &#123;</div><div class="line">        // 进行处理 ...</div><div class="line">    &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你希望拥有更多的控制权，以及在一个操作中可以执行异步任务，那么就重写 start 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@implementation YourOperation</div><div class="line">    - (void)start</div><div class="line">    &#123;</div><div class="line">        self.isExecuting = YES;</div><div class="line">        self.isFinished = NO;</div><div class="line">        // 开始处理，在结束时应该调用 finished ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    - (void)finished</div><div class="line">    &#123;</div><div class="line">        self.isExecuting = NO;</div><div class="line">        self.isFinished = YES;</div><div class="line">    &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。</p>
<p>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 isCancelled 属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)main</div><div class="line">&#123;</div><div class="line">    while (notDone &amp;&amp; !self.isCancelled) &#123;</div><div class="line">        // 进行处理</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">YourOperation *operation = [[YourOperation alloc] init];</div><div class="line">[queue  addOperation:operation];</div></pre></td></tr></table></figure>
<p>另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</div><div class="line">    // 代码...</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>虽然通过这种的方式在队列中添加操作会非常方便，但是定义你自己的 NSOperation 子类会在调试时很有帮助。如果你重写 operation 的description 方法，就可以很容易的标示出在某个队列中当前被调度的所有操作 。</p>
<p>除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。</p>
<p>另外还有一个方便的功能就是根据队列中 operation 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[intermediateOperation addDependency:operation1];</div><div class="line">[intermediateOperation addDependency:operation2];</div><div class="line">[finishedOperation addDependency:intermediateOperation];</div></pre></td></tr></table></figure>
<p>这些简单的代码可以确保 operation1 和 operation2 在 intermediateOperation 之前执行，当然，也会在 finishOperation 之前被执行。对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。</p>
<p>从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。</p>
<p>参考：</p>
<p><a href="https://www.objccn.io/issue-2-1/" target="_blank" rel="external">https://www.objccn.io/issue-2-1/</a></p>
]]></content>
    
    <summary type="html">
    
      并发编程，这个我们听起来再熟悉不过了，我们在代码编写过程中也经常会做这样一些操作，但是我发现，在实际的编写过程中，很多实用并发编程的方式，其实是错误使用的，当然这也包括我自己，对一些并发编程也是糊里糊涂，今天的工作中涉及到了许多的并发方面的问题，专门抽时间去学习了一下，现在记录下来。
    
    </summary>
    
      <category term="iOS中的并发编程" scheme="http://ppsheep.com/categories/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS中的并发编程" scheme="http://ppsheep.com/tags/iOS%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ViewControllers瘦身计划(二)</title>
    <link href="http://ppsheep.com/2016/12/14/ViewControllers%E7%98%A6%E8%BA%AB%E8%AE%A1%E5%88%92-%E4%BA%8C/"/>
    <id>http://ppsheep.com/2016/12/14/ViewControllers瘦身计划-二/</id>
    <published>2016-12-14T02:24:25.000Z</published>
    <updated>2016-12-14T03:58:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="UITableViewController的使用"><a href="#UITableViewController的使用" class="headerlink" title="UITableViewController的使用"></a>UITableViewController的使用</h3><p>TableView在iOS应用程序中是非常通用的组件，Apple为我们提供了tableview专属的view controller类UITableViewController。Table view controller实现了一些非常有用的特性，来避免一遍又一遍的写那些死板的代码！</p>
<p>但是，我们经常会遇到这样一个问题，table view controller 只限于管理一个全屏展示的table view。大多数情况下，我们想达到的效果就是这样，但是如果不是呢，我们就只能使用通常的控制器，其实还有其他的方法来达到使用table view controller 的目的。</p>
<h4 id="UITableViewController的特性"><a href="#UITableViewController的特性" class="headerlink" title="UITableViewController的特性"></a>UITableViewController的特性</h4><p>Table view controllers 会在第一次显示 table view 的时候帮你加载其数据。另外，它还会帮你切换 table view 的编辑模式、响应键盘通知、以及一些小任务，比如闪现侧边的滑动提示条和清除选中时的背景色。为了让这些特性生效，当你在子类中覆写类似 viewWillAppear: 或者 viewDidAppear: 等事件方法时，需要调用 super 版本。</p>
<p>Table view controllers 相对于标准 view controllers 的一个特别的好处是它支持 Apple 实现的“下拉刷新”。目前，文档中唯一的使用 UIRefreshControl 的方式就是通过 table view controller ，虽然通过努力在其他地方也能让它工作（例如直接将UIRefreshControl直接addSubView到tableview），但很可能在下一次 iOS 更新的时候就不行了。</p>
<p>这些要素加一起，为我们提供了大部分 Apple 所定义的标准 table view 交互行为，如果你的应用恰好符合这些标准，那么直接使用 table view controllers 来避免写那些死板的代码是个很好的方法。</p>
<h4 id="UITableViewController的限制"><a href="#UITableViewController的限制" class="headerlink" title="UITableViewController的限制"></a>UITableViewController的限制</h4><p>Table view controllers 的 view 属性永远都是一个 table view。如果你稍后决定在 table view 旁边显示一些东西（比如一个地图，一个小的按钮），如果不依赖于那些奇怪的 hacks，估计就没什么办法了。</p>
<p>如果你是用代码或 .xib 文件来定义的界面，那么迁移到一个标准 view controller 将会非常简单。但是如果你使用了 storyboards，那么这个过程要多包含几个步骤。除非重新创建，否则你并不能在 storyboards 中将 table view controller 改成一个标准的 view controller。这意味着你必须将所有内容拷贝到新的 view controller，然后再重新连接一遍。</p>
<p>最后，你需要把迁移后丢失的 table view controller 的特性给补回来。大多数都是 viewWillAppear: 或 viewDidAppear: 中简单的一条语句。切换编辑模式需要实现一个 action 方法，用来切换 table view 的 editing 属性。大多数工作来自重新创建对键盘的支持。</p>
<p>在选择这条路之前，其实还有一个更轻松的选择，它可以通过分离我们需要关心的功能（关注点分离），让你获得额外的好处：</p>
<h4 id="使用-Child-View-Controllers"><a href="#使用-Child-View-Controllers" class="headerlink" title="使用 Child View Controllers"></a>使用 Child View Controllers</h4><p>和完全抛弃 table view controller 不同，你还可以将它作为 child view controller 添加到其他 view controller 中。这样，parent view controller 在管理其他的你需要的新加的界面元素的同时，table view controller 还可以继续管理它的 table view。</p>
<p>我们来看代码：</p>
<p>我有一个UITableViewController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">@interface MyTableViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyTableViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;cell&quot;];</div><div class="line">    self.refreshControl = [[UIRefreshControl alloc] initWithFrame:CGRectMake(0, 0, 20, 20)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Table view data source</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line"></div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line"></div><div class="line">    return 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    cell.textLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row];</div><div class="line">    </div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想要使用这个UITableViewController来管理我的tableview</p>
<p>然后  我还有一个view controller，在这个view controller中  我既要包含这个table view  还要有其他的view  用上面的加自controller来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self addMyTableViewController];</div><div class="line">    [self addOtherView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//添加zicontroller</div><div class="line">- (void)addMyTableViewController&#123;</div><div class="line">    MyTableViewController *vc = [[MyTableViewController alloc] init];</div><div class="line">    [self addChildViewController:vc];</div><div class="line">    CGRect frame = self.view.bounds;</div><div class="line">    frame.size.height = 300;</div><div class="line">    vc.view.frame = frame;</div><div class="line">    [self.view addSubview:vc.view];</div><div class="line">    [vc didMoveToParentViewController:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addOtherView&#123;</div><div class="line">    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(20, 400, 100, 30)];</div><div class="line">    btn.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:btn];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-12-14-032856.jpg" alt=""></p>
<p>如果我们使用了这种方法，那么我们就需要在子controller 和 父 controller之间建立起通信渠道，因为，如果点击了cell，在父类中我需要知道，虽然这样看起来是额外的开销，但是我们的代码变得非常清晰，复用性也更高</p>
<p>我们怎样建立起通信呢，当然最简单的就是使用delegate，这个就比较简单的了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@protocol MyTableViewControllerDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)didSelectCell;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@interface MyTableViewController : UITableViewController</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;MyTableViewControllerDelegate&gt; delegate;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>传递点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    if ([self.delegate respondsToSelector:@selector(didSelectCell)]) &#123;</div><div class="line">        [self.delegate didSelectCell];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在父controller中捕获点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MyTableViewController *vc = [[MyTableViewController alloc] init];</div><div class="line">vc.delegate = self;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(void)didSelectCell&#123;</div><div class="line">    NSLog(@&quot;点击&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在cell内部控制cell的状态"><a href="#在cell内部控制cell的状态" class="headerlink" title="在cell内部控制cell的状态"></a>在cell内部控制cell的状态</h3><p>如果我们想自定义cell内部的状态，在点击cell的时候  自定义高亮样式 我们知道有这样的delegate方法，让我们在view controller中操作，但是我们要讲的就是减少view controller的代码</p>
<p>首先我们来看看在view controller 中 怎样来改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView</div><div class="line">        didHighlightRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">   //高亮时</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tableView:(UITableView *)tableView</div><div class="line">        didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    //非高亮</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View 的实现细节和 delegate 的实现交织在一起了。我们应该把这些细节移到 cell 自身中去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123;</div><div class="line">    [super setHighlighted:highlighted animated:animated];</div><div class="line">    if (highlighted) &#123;</div><div class="line">        //高亮时改变cell的状态</div><div class="line">    &#125;else&#123;</div><div class="line">        //非高亮时改变</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Table view controllers（以及其他的 controller 对象！）应该在 model 和 view 对象之间扮演协调者和调解者的角色。它不应该关心明显属于 view 层或 model 层的任务。你应该始终记住这点，这样 delegate 和 data source 方法会变得更小巧，最多包含一些简单的样板代码。</p>
<p>这不仅减少了 table view controllers 那样的大小和复杂性，而且还把业务逻辑和 view 的逻辑放到了更合适的地方。Controller 层的里里外外的实现细节都被封装成了简单的 API，最终，它变得更加容易理解，也更利于团队协作。</p>
<p>参考:</p>
<p><a href="https://www.objccn.io/issue-1-2/" target="_blank" rel="external">https://www.objccn.io/issue-1-2/</a></p>
]]></content>
    
    <summary type="html">
    
      在上一篇文章中  我们讲了通过整合tableview的代理，来达到代码复用，减少控制器代码量的效果，今天我们接着来讲另外的一些方法来减轻控制器代码量，整合封装，提高代码的可读性。
    
    </summary>
    
      <category term="iOS进阶" scheme="http://ppsheep.com/categories/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="更轻量级的ViewController" scheme="http://ppsheep.com/tags/%E6%9B%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84ViewController/"/>
    
  </entry>
  
  <entry>
    <title>ViewControllers瘦身计划(一)</title>
    <link href="http://ppsheep.com/2016/12/05/ViewControllers%E7%98%A6%E8%BA%AB%E8%AE%A1%E5%88%92-%E4%B8%80/"/>
    <id>http://ppsheep.com/2016/12/05/ViewControllers瘦身计划-一/</id>
    <published>2016-12-05T14:29:37.000Z</published>
    <updated>2016-12-06T01:58:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="把-Data-Source-和其他-Protocols-分离出来"><a href="#把-Data-Source-和其他-Protocols-分离出来" class="headerlink" title="把 Data Source 和其他 Protocols 分离出来"></a>把 Data Source 和其他 Protocols 分离出来</h3><p>我们在平时的编码中，最经常使用到的一个控件就是UITableView了，那我们每次需要使用到tableview的时候，都需要写一些重复的代码，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#pragma mark - tableview datasource</div><div class="line"></div><div class="line">#pragma mark - tableview datasource</div><div class="line"></div><div class="line">- (PPSFriend *)friendAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    return self.friends[indexPath.row];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">    return self.friends.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    PPSFriendCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;friendCell&quot; forIndexPath:indexPath];</div><div class="line">    PPSFriend *friend = [self friendAtIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = friend.name;</div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像上面一些代码，我们每天都在写，每次用到UITableView都需要重写这些毫无技术可言的代码，那我们试想一下能否写一个封装类，将这些重复的方法全部封起来，多次使用呢？答案当然是，可以的。</p>
<p>上面的代码，其实都是在围绕着friends这个数组做一系列的事情，我们可以独立出来一个类，使用一个block或者delegate来设置cell，当然这取决于你的习惯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#pragma mark - tableview config cell</div><div class="line">- (void)configCell&#123;</div><div class="line">    void (^configCell)(PPSFriendCell *, PPSFriend *) = ^(PPSFriendCell *cell, PPSFriend *friend)&#123;</div><div class="line">        cell.textLabel.text = friend.name;</div><div class="line">    &#125;;</div><div class="line">    PPSArrayDatasource *datasources = [[PPSArrayDatasource alloc] initWithItems:self.friends cellIdentifier:@&quot;friendCell&quot; configureCellBlock:configCell];</div><div class="line">    self.tableView.dataSource = datasources;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，你可以把 view controller 中的这 3 个方法去掉了，取而代之，你可以创建一个 PPSArrayDatasource 类的实例作为 table view 的 data source。</p>
<p>现在你不用担心把一个 index path 映射到数组中的位置了，每次你想把这个数组显示到一个 table view 中时，你都可以复用这些代码。你也可以实现一些额外的方法，比如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tableView:commitEditingStyle:forRowAtIndexPath:</div></pre></td></tr></table></figure>
<h4 id="多个section"><a href="#多个section" class="headerlink" title="多个section"></a>多个section</h4><p>还有一种情况，如果是多个section的情况下，我们还可以再扩展一下，将block定义为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef void(^TableViewCellConfigureBlock)(id cell, id item, NSIndexPath *indexPath);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#pragma mark - tableview config cell</div><div class="line">- (void)configCell&#123;</div><div class="line">    void (^configCell)(PPSFriendCell *, PPSFriend *, NSIndexPath *) = ^(PPSFriendCell *cell, PPSFriend *friend, NSIndexPath *indexPath)&#123;</div><div class="line">        cell.textLabel.text = friend.name;</div><div class="line">    &#125;;</div><div class="line">    PPSArrayDatasource *datasources = [[PPSArrayDatasource alloc] initWithItems:self.friends cellIdentifier:@&quot;friendCell&quot; configureCellBlock:configCell];</div><div class="line">    self.tableView.dataSource = datasources;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么在PPSArrayDatasource的items中装的应该就是一个一个的数组了，分别对应的每个section，这里我只是针对这种情况说明一下，不管是多个section还是单个section都可以使用这种方法，来瘦身</p>
<p>在 table view controllers 之间共享。</p>
<p>这样的好处在于，你可以单独测试这个类，再也不用写第二遍。该原则同样适用于数组之外的其他对象。</p>
<h3 id="将业务逻辑移到model中"><a href="#将业务逻辑移到model中" class="headerlink" title="将业务逻辑移到model中"></a>将业务逻辑移到model中</h3><p>下面是在viewcontroller中写的用来查找一个用户的目前的优先事项的列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)loadPriorities &#123;</div><div class="line">    NSDate* now = [NSDate date];</div><div class="line">    NSString* formatString = @&quot;startDate = %@&quot;;</div><div class="line">    NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];</div><div class="line">    NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate];</div><div class="line">    self.priorities = [priorities allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把这些代码移动到 User 类的 category 中会变得更加清晰，处理之后，在 View Controller.m 中看起来就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)loadPriorities &#123;</div><div class="line">    self.priorities = [user currentPriorities];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 User+Extensions.m 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (NSArray*)currentPriorities &#123;</div><div class="line">    NSDate* now = [NSDate date];</div><div class="line">    NSString* formatString = @&quot;startDate = %@&quot;;</div><div class="line">    NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];</div><div class="line">    return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些代码不能被轻松地移动到 model 对象中，但明显和 model 代码紧密联系，对于这种情况，我们可以使用一个 Store：</p>
<h3 id="创建store类"><a href="#创建store类" class="headerlink" title="创建store类"></a>创建store类</h3><p>在一些情况下中，我们需要加载文件并解析它。下面就是 view controller 中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)readArchive &#123;</div><div class="line">    NSBundle* bundle = [NSBundle bundleForClass:[self class]];</div><div class="line">    NSURL *archiveURL = [bundle URLForResource:@&quot;photodata&quot;</div><div class="line">                                 withExtension:@&quot;bin&quot;];</div><div class="line">    NSAssert(archiveURL != nil, @&quot;Unable to find archive in bundle.&quot;);</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:archiveURL</div><div class="line">                                         options:0</div><div class="line">                                           error:NULL];</div><div class="line">    NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</div><div class="line">    _users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;users&quot;];</div><div class="line">    _photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@&quot;photos&quot;];</div><div class="line">    [unarchiver finishDecoding];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是 view controller 没必要知道这些，所以我们可以创建了一个 Store 对象来做这些事。通过分离，我们就可以复用这些代码，单独测试他们，并且让 view controller 保持小巧。Store 对象会关心数据加载、缓存和设置数据栈。它也经常被称为服务层或者仓库。</p>
<h3 id="把网络层请求逻辑移到model层"><a href="#把网络层请求逻辑移到model层" class="headerlink" title="把网络层请求逻辑移到model层"></a>把网络层请求逻辑移到model层</h3><p>和上面的主题相似：不要在 view controller 中做网络请求的逻辑。取而代之，你应该将它们封装到另一个类中。这样，你的 view controller 就可以在之后通过使用回调（比如一个 completion 的 block）来请求网络了。这样的好处是，缓存和错误控制也可以在这个类里面完成。</p>
<h3 id="把View移到View层"><a href="#把View移到View层" class="headerlink" title="把View移到View层"></a>把View移到View层</h3><p>不应该在 view controller 中构建复杂的 view 层次结构。你可以使用 Interface Builder 或者把 views 封装到一个 UIView 子类当中。例如，如果你要创建一个选择日期的控件，把它放到一个名为 DatePickerView 的类中会比把所有的事情都在 view controller 中做好好得多。再一次，这样增加了可复用性并保持了简单。</p>
<p>简单来说，就是将一个viewcontroller中复杂的view构造，放到一个单独的view类中，然在viewcontroller中，只需要构建一个这个类就行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们已经看到一些用来创建更小巧的 view controllers 的技术。我们并不是想把这些技术应用到每一个可能的角落，只是我们有一个目标：写可维护的代码。知道这些模式后，我们就更有可能把那些笨重的 view controllers 变得更整洁。</p>
]]></content>
    
    <summary type="html">
    
      View controllers 通常是 iOS 项目中最大的文件，并且它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率最低的。接下来我将结合一些我自己看到的东西和平时在使用的方法，来节省ViewController中的代码量。
    
    </summary>
    
      <category term="iOS进阶" scheme="http://ppsheep.com/categories/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="更轻量级的ViewController" scheme="http://ppsheep.com/tags/%E6%9B%B4%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84ViewController/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(三)</title>
    <link href="http://ppsheep.com/2016/12/05/KVC%E5%92%8CKVO-%E4%B8%89/"/>
    <id>http://ppsheep.com/2016/12/05/KVC和KVO-三/</id>
    <published>2016-12-05T02:04:32.000Z</published>
    <updated>2016-12-05T02:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="KVO和线程"><a href="#KVO和线程" class="headerlink" title="KVO和线程"></a>KVO和线程</h3><p>KVO 行为是同步的 并且发生与所观察的值发生变化的同样的线程上。这听起来有点拗口，简单点说，就是监听行为发生的线程和所观察的值发生变化的线程，肯定是同一个线程，这样我们使用的时候就需要注意了：</p>
<p>当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知</p>
<p>通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>最简单的 KVC 能让我们通过以下的形式访问属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *name;</div></pre></td></tr></table></figure>
<p>取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSString *n = [object valueForKey:@&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>设定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[object setValue:@&quot;Daniel&quot; forKey:@&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property (nonatomic) CGFloat height;</div></pre></td></tr></table></figure>
<p>我们可以这样设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[object setValue:@(20) forKey:@&quot;height&quot;]</div></pre></td></tr></table></figure>
<h3 id="键路径-key-path"><a href="#键路径-key-path" class="headerlink" title="键路径 (key path)"></a>键路径 (key path)</h3><p>KVC 同样允许我们通过关系来访问对象。假设 person 对象有属性 address，address 有属性 city，我们可以这样通过 person 来访问 city：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[person valueForKeyPath:@&quot;address.city&quot;]</div></pre></td></tr></table></figure>
<p>值得注意的是这里我们调用 -valueForKeyPath: 而不是 -valueForKey:</p>
<h3 id="Key-Value-Coding-Without-property"><a href="#Key-Value-Coding-Without-property" class="headerlink" title="Key-Value Coding Without @property"></a>Key-Value Coding Without @property</h3><p>不需要 @property 的 KVC</p>
<p>我们可以实现一个支持 KVC 而不用 @property 和 @synthesize 或是自动 synthesize 的属性。最直接的方式是添加 -<key> 和 -set<key>: 方法。例如我们想要 name ，我们这样做：</key></key></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (NSString *)name;</div><div class="line">- (void)setName:(NSString *)name;</div></pre></td></tr></table></figure>
<p>这完全等于 @property 的实现方式。</p>
<p>但是当标量和 struct 的值被传入 nil 的时候尤其需要注意。假设我们要 height 属性支持 KVC 我们写了以下的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (CGFloat)height;</div><div class="line">- (void)setHeight:(CGFloat)height;</div></pre></td></tr></table></figure>
<p>然后我们这样调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[object setValue:nil forKey:@&quot;height&quot;]</div></pre></td></tr></table></figure>
<p>这会抛出一个 exception。要正确的处理 nil，我们要像这样 override -setNilValueForKey:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)setNilValueForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToString:@&quot;height&quot;]) &#123;</div><div class="line">        [self setValue:@0 forKey:key];</div><div class="line">    &#125; else</div><div class="line">        [super setNilValueForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>一个常常被忽视的 KVC 特性是它对集合操作的支持。举个例子，我们可以这样来获得一个数组中最大的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSArray *a = @[@4, @84, @2];</div><div class="line">NSLog(@&quot;max = %@&quot;, [a valueForKeyPath:@&quot;@max.self&quot;]);</div></pre></td></tr></table></figure>
<p>或者说，我们有一个 Transaction 对象的数组，对象有属性 amount 的话，我们可以这样获得最大的 amount：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSArray *a = @[transaction1, transaction2, transaction3];</div><div class="line">NSLog(@&quot;max = %@&quot;, [a valueForKeyPath:@&quot;@max.amount&quot;]);</div></pre></td></tr></table></figure>
<p>当我们调用 [a valueForKeyPath:@”@max.amount”] 的时候，它会在数组 a 的每个元素中调用 -valueForKey:@”amount” 然后返回最大的那个。</p>
<h3 id="常见的-KVO-错误"><a href="#常见的-KVO-错误" class="headerlink" title="常见的 KVO 错误"></a>常见的 KVO 错误</h3><p>首先，KVO 兼容是 API 的一部分。如果类的所有者不保证某个属性兼容 KVO，我们就不能保证 KVO 正常工作。苹果文档里有 KVO 兼容属性的文档。例如，NSProgress 类的大多数属性都是兼容 KVO 的。</p>
<p>当做出改变以后，有些人试着放空的 -willChange 和 -didChange 方法来强制 KVO 的触发。KVO 通知虽然会生效，但是这样做破坏了有依赖于 NSKeyValueObservingOld 选项的观察者。详细来说，这影响了 KVO 对观察键路径 (key path) 的原生支持。KVO 在观察键路径 (key path) 时依赖于 NSKeyValueObservingOld 属性。</p>
<p>我们也要指出有些集合是不能被观察的。KVO 旨在观察关系 (relationship) 而不是集合。我们不能观察 NSArray，我们只能观察一个对象的属性——而这个属性有可能是 NSArray。举例说，如果我们有一个 ContactList 对象，我们可以观察它的 contacts 属性。但是我们不能向要观察对象的 -addObserver:forKeyPath:… 传入一个 NSArray。</p>
<p>相似地，观察 self 不是永远都生效的。而且这不是一个好的设计。</p>
<h3 id="调试-KVO"><a href="#调试-KVO" class="headerlink" title="调试 KVO"></a>调试 KVO</h3><p>你可以在 lldb 里查看一个被观察对象的所有观察信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(lldb) po [observedObject observationInfo]</div></pre></td></tr></table></figure>
<p>这会打印出有关谁观察谁之类的很多信息。</p>
<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
<p>参考：</p>
<p><a href="https://www.objccn.io/issue-7-3/" target="_blank" rel="external">https://www.objccn.io/issue-7-3/</a></p>
]]></content>
    
    <summary type="html">
    
      继续我们之前的KVC和KVO系列，这是这个系列的最后一篇，这两周都没怎么写东西，估计这一周过后，文章更新会正常了，手头上的事情多了，就不想写了，写出来的东西也是粗制滥造
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(二)</title>
    <link href="http://ppsheep.com/2016/11/28/KVC%E5%92%8CKVO-%E4%BA%8C/"/>
    <id>http://ppsheep.com/2016/11/28/KVC和KVO-二/</id>
    <published>2016-11-28T01:30:54.000Z</published>
    <updated>2016-11-28T02:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<p>在上一篇文章中，我们讲到，通过键值观察，属性依赖，来讲解KVC，如果没有看过上一篇文章的，请移步<br><a href="http://ppsheep.com/2016/11/19/KVC和KVO(一)/">http://ppsheep.com/2016/11/19/KVC和KVO(一)/</a></p>
<h3 id="手动通知和自动通知"><a href="#手动通知和自动通知" class="headerlink" title="手动通知和自动通知"></a>手动通知和自动通知</h3><p>在OC中，消息通知扮演着很重要的角色，在我们在调用 LabColor 类的 -setLComponent:方法时，会触发以下方法的调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)willChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)didChangeValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>会在运行 -setLComponent: 中的代码之前以及之后被自动调用。</p>
<p>有些情况下当我们需要 override -setLComponent: 并且我们要控制是否发送键值改变的通知的时候，我们要做以下的事情：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//是否自动发送通知</div><div class="line">+ (BOOL)automaticallyNotifiesObserversForLComponent;</div><div class="line">&#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setLComponent:(double)lComponent;</div><div class="line">&#123;</div><div class="line">    if (_lComponent == lComponent) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //手动调用</div><div class="line">    [self willChangeValueForKey:@&quot;lComponent&quot;];</div><div class="line">    _lComponent = lComponent;</div><div class="line">    [self didChangeValueForKey:@&quot;lComponent&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们关闭了 -willChangeValueForKey: 和 -didChangeValueForKey: 的自动调用，然后我们手动调用他们。我们只应该在关闭了自动调用的时候我们才需要在 setter 方法里手动调用 -willChangeValueForKey: 和 -didChangeValueForKey:。大多数情况下，我们都不会这样做，这样做，会让代码变得复杂，不容易理解</p>
<h3 id="KVO和context"><a href="#KVO和context" class="headerlink" title="KVO和context"></a>KVO和context</h3><p>有时我们会有理由不想用 KeyValueObserver 辅助类。创建另一个对象会有额外的性能开销。如果我们观察很多个键的话，这个开销可能会变得明显。</p>
<p>如果我们在实现一个类的时候把它自己注册为观察者的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)anObserver</div><div class="line">         forKeyPath:(NSString *)keyPath</div><div class="line">            options:(NSKeyValueObservingOptions)options</div><div class="line">            context:(void *)context</div></pre></td></tr></table></figure>
<p>一个非常重要的点是我们要传入一个这个类唯一的 context。推荐把以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static int const PrivateKVOContext;</div></pre></td></tr></table></figure>
<p>写在这个类 .m 文件的顶端，然后我们像这样调用 API 并传入 PrivateKVOContext 的指针：</p>
<p>我们在LabColor类中定义一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//将自己设置为观察者</div><div class="line">- (void)setObserverWithSelf;</div></pre></td></tr></table></figure>
<p>在本类中实现方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(void)setObserverWithSelf&#123;</div><div class="line">    [self addObserver:self forKeyPath:@&quot;lComponent&quot; options:NSKeyValueObservingOptionInitial context:(void *)&amp;PrivateKVOContext];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们这样写 -observeValueForKeyPath:… 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div><div class="line">&#123;</div><div class="line">    if (context == &amp;PrivateKVOContext) &#123;</div><div class="line">        // 这里写相关的观察代码</div><div class="line">    &#125; else &#123;</div><div class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将确保我们写的子类都是正确的。如此一来，子类和父类都能安全的观察同样的键值而不会冲突。否则我们将会碰到难以 debug 的奇怪行为。</p>
<h3 id="进阶KVO"><a href="#进阶KVO" class="headerlink" title="进阶KVO"></a>进阶KVO</h3><p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 NSKeyValueObservingOptionInitial 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 -addObserver:forKeyPath:… 到时候也被触发。</p>
<h4 id="之前和之后"><a href="#之前和之后" class="headerlink" title="之前和之后"></a>之前和之后</h4><p>如果我们注册通知的时候附加了 NSKeyValueObservingOptionPrior 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;</div><div class="line">    // 改变之前</div><div class="line">&#125; else &#123;</div><div class="line">    // 改变之后</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="值"><a href="#值" class="headerlink" title="值"></a>值</h4><p>如果我们需要改变前后的值，我们可以在 KVO 选项中加入 NSKeyValueObservingOptionNew 和/或 NSKeyValueObservingOptionOld。</p>
<p>更简单的办法是用 NSKeyValueObservingOptionPrior 选项，随后我们就可以用以下方式提取出改变前后的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id oldValue = change[NSKeyValueChangeOldKey];</div><div class="line">id newValue = change[NSKeyValueChangeNewKey];</div></pre></td></tr></table></figure>
<p>通常来说 KVO 会在 -willChangeValueForKey: 和 -didChangeValueForKey: 被调用的时候存储相应键的值。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>KVO 对一些集合类也有很强的支持，以下方法会返回集合对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-mutableArrayValueForKey:</div><div class="line">-mutableSetValueForKey:</div><div class="line">-mutableOrderedSetValueForKey:</div></pre></td></tr></table></figure>
<p>我将会详细解释这是怎么工作的。如果你使用这些方法，change 字典里会包含键值变化的类型（添加、删除和替换）。对于有序的集合，change 字典会包含受影响的 index。</p>
<p>集合代理对象和变化的通知在用于更新UI的时候非常有效，尤其是处理大集合的时候。但是它们需要花费你一些心思。</p>
<p>后面将会结合UI层面，来对KVC和KVO进行进一步讲解</p>
<p>参考:</p>
<p><a href="https://www.objccn.io" target="_blank" rel="external">https://www.objccn.io</a></p>
]]></content>
    
    <summary type="html">
    
      上一周实在是手头上的事情太多，项目忙着出版本，都没怎么写点东西，估计这一周也不会轻松，感觉已经好久没动了，还是需要积累点东西的。上一篇文章，我们讲到了KVC和KVO，我们接着完成这个系列，这个系列是我在喵神的Objc上看到的，结合自己的一点理解，记录下来。
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>KVC和KVO(一)</title>
    <link href="http://ppsheep.com/2016/11/19/KVC%E5%92%8CKVO(%E4%B8%80)/"/>
    <id>http://ppsheep.com/2016/11/19/KVC和KVO(一)/</id>
    <published>2016-11-19T08:08:32.000Z</published>
    <updated>2016-11-21T03:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="观察model对象的变化"><a href="#观察model对象的变化" class="headerlink" title="观察model对象的变化"></a>观察model对象的变化</h3><p>在 Cocoa 的模型-视图-控制器 (Model-view-controller)架构里，控制器负责让视图和模型同步。这一共有两步：当 model 对象改变的时候，视图应该随之改变以反映模型的变化；当用户和控制器交互的时候，模型也应该做出相应的改变。</p>
<p>KVO 能帮助我们让视图和模型保持同步。控制器可以观察视图依赖的属性变化。</p>
<p>让我们看一个例子：我们的模型类 LabColor 代表一种 Lab色彩空间里的颜色。和 RGB 不同，这种色彩空间有三个元素 L, a, b。我们要做一个用来改变这些值的滑块和一个显示颜色的方块区域。</p>
<p>我们的模型类有以下三个用来代表颜色的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property (nonatomic) double lComponent;</div><div class="line">@property (nonatomic) double aComponent;</div><div class="line">@property (nonatomic) double bComponent;</div></pre></td></tr></table></figure>
<h3 id="依赖的属性"><a href="#依赖的属性" class="headerlink" title="依赖的属性"></a>依赖的属性</h3><p>我们需要从这个类创建一个 UIColor 对象来显示出颜色。我们添加三个额外的属性，分别对应 R, G, B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property (nonatomic, readonly) double redComponent;</div><div class="line">@property (nonatomic, readonly) double greenComponent;</div><div class="line">@property (nonatomic, readonly) double blueComponent;</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) UIColor *color;</div></pre></td></tr></table></figure>
<p>有了这些以后，我们就可以创建这个类的接口了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@interface LabColor : NSObject</div><div class="line"></div><div class="line">@property (nonatomic) double lComponent;</div><div class="line">@property (nonatomic) double aComponent;</div><div class="line">@property (nonatomic) double bComponent;</div><div class="line"></div><div class="line">@property (nonatomic, readonly) double redComponent;</div><div class="line">@property (nonatomic, readonly) double greenComponent;</div><div class="line">@property (nonatomic, readonly) double blueComponent;</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) UIColor *color;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>维基百科提供了转换 RGB 到 Lab 色彩空间的算法。写成方法之后如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (double)greenComponent;</div><div class="line">&#123;</div><div class="line">    return D65TristimulusValues[1] * inverseF(1./116. * (self.lComponent + 16) + 1./500. * self.aComponent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[...]</div><div class="line"></div><div class="line">- (UIColor *)color</div><div class="line">&#123;</div><div class="line">    return [UIColor colorWithRed:self.redComponent * 0.01 green:self.greenComponent * 0.01 blue:self.blueComponent * 0.01 alpha:1.];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码没什么令人激动的地方。有趣的是 greenComponent 属性依赖于 lComponent 和 aComponent。不论何时设置 lComponent 的值，我们需要让 RGB 三个 component 中与其相关的成员以及 color 属性都要得到通知以保持一致。这一点这在 KVO 中很重要。</p>
<p>Foundation 框架提供的表示属性依赖的机制如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key</div></pre></td></tr></table></figure>
<p>更详细的如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffecting&lt;键名&gt;</div></pre></td></tr></table></figure>
<p>在我们的例子中如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingRedComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObject:@&quot;lComponent&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;aComponent&quot;, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingBlueComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;bComponent&quot;, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSSet *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;redComponent&quot;, @&quot;greenComponent&quot;, @&quot;blueComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>这里解释一下，可能有一些朋友对这里的对象依赖关系不是特别清楚。我们拿出一个来解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingGreenComponent</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;lComponent&quot;, @&quot;aComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>重要</strong></p>
<p>在这个方法中，它代表的意思是当lComponent属性，或者aComponent属性改变时，需要通知到greenComponent，就相当于，lComponent或者aComponent中的任何一个作出改变时，可以认为greenComponent也发生了改变，如果这时，有一个监听对象，在监听greenComponent，那么当我们改变lComponent或aComponent，这个监听会被触发</p>
<p>至于这个方法怎么得来的，在peoperty中定义了该属性，你只要敲keyPath就会自动提示出来，有哪些可以设置依赖了</p>
<p>在我们的color中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (NSSet *)keyPathsForValuesAffectingColor</div><div class="line">&#123;</div><div class="line">    return [NSSet setWithObjects:@&quot;redComponent&quot;, @&quot;greenComponent&quot;, @&quot;blueComponent&quot;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>color是依赖于redComponent、greenComponent和blueComponent，这样 我们就能知道，改变lComponent、aComponent、bComponent任何一个，都会触发color的监听</p>
<p>现在我们完整的表达了属性之间的依赖关系。请注意，我们可以把这些属性链接起来。打个比方，如果我们写一个子类去 override redComponent 方法，这些依赖关系仍然能正常工作。</p>
<h3 id="观察变化"><a href="#观察变化" class="headerlink" title="观察变化"></a>观察变化</h3><p>现在让我们目光转向控制器。 UIViewController 的子类拥有 LabColor model 对象作为其属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) LabColor *labColor;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们把视图控制器注册为观察者来接收 KVO 的通知，这可以用以下 NSObject 的方法来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)anObserver</div><div class="line">         forKeyPath:(NSString *)keyPath</div><div class="line">            options:(NSKeyValueObservingOptions)options</div><div class="line">            context:(void *)context</div></pre></td></tr></table></figure>
<p>这会让以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(NSDictionary *)change</div><div class="line">                       context:(void *)context</div></pre></td></tr></table></figure>
<p>在当 keyPath 的值改变的时候在观察者 anObserver 上面被调用。这个 API 看起来有一点吓人。更糟糕的是，我们还得记得调用以下的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)removeObserver:(NSObject *)anObserver</div><div class="line">            forKeyPath:(NSString *)keyPath</div></pre></td></tr></table></figure>
<p>来移除观察者，否则我们我们的 app 会因为某些奇怪的原因崩溃。</p>
<p>对于大多数的应用来说，KVO 可以通过辅助类用一种更简单优雅的方式实现。我们在视图控制器添加以下的观察记号（Observation token）属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property (nonatomic, strong) id colorObserveToken;</div></pre></td></tr></table></figure>
<p>当 labColor 在视图控制器中被设置时，我们只要 override labColor 的 setter 方法就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)setLabColor:(LabColor *)labColor</div><div class="line">&#123;</div><div class="line">    _labColor = labColor;</div><div class="line">    self.colorObserveToken = [KeyValueObserver observeObject:labColor</div><div class="line">                                                     keyPath:@&quot;color&quot;</div><div class="line">                                                      target:self</div><div class="line">                                                    selector:@selector(colorDidChange:)</div><div class="line">                                                     options:NSKeyValueObservingOptionInitial];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)colorDidChange:(NSDictionary *)change;</div><div class="line">&#123;</div><div class="line">    self.colorView.backgroundColor = self.labColor.color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们封装一个KeyValueObserver辅助类</p>
<p>KeyValueObserver 辅助类 封装了 -addObserver:forKeyPath:options:context:，-observeValueForKeyPath:ofObject:change:context:和-removeObserverForKeyPath: 的调用，让视图控制器远离杂乱的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 其中__attribute__((warn_unused_result))这个的意思是，当调用这个方法时，必须要检查返回值，或者使用返回值，不然编译器直接报警告</div><div class="line"></div><div class="line">+ (NSObject *)observeObject:(id)object keyPath:(NSString*)keyPath target:(id)target selector:(SEL)selector __attribute__((warn_unused_result));</div><div class="line"></div><div class="line"></div><div class="line">+ (NSObject *)observeObject:(id)object keyPath:(NSString*)keyPath target:(id)target selector:(SEL)selector options:(NSKeyValueObservingOptions)options __attribute__((warn_unused_result));</div></pre></td></tr></table></figure>
<h3 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h3><p>视图控制器需要对 L，a，b 的滑块控制做出反应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)updateLComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.lComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateAComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.aComponent = sender.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateBComponent:(UISlider *)sender;</div><div class="line">&#123;</div><div class="line">    self.labColor.bComponent = sender.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-21-KVC%26KVO-%E4%B8%80-.gif" alt=""></p>
<p>源工程:</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS%20KVC和KVO(一" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS%20KVC和KVO(一</a>)</p>
<p>参考:<br>    <a href="https://www.objccn.io/issue-7-3/" target="_blank" rel="external">https://www.objccn.io/issue-7-3/</a></p>
]]></content>
    
    <summary type="html">
    
      Key-value coding (KVC) 和 key-value observing (KVO) 是两种能让我们驾驭 Objective-C 动态特性并简化代码的机制。在这篇文章里，我们将接触一些如何利用这些特性的例子。
    
    </summary>
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/categories/KVC%E5%92%8CKVO/"/>
    
    
      <category term="KVC和KVO" scheme="http://ppsheep.com/tags/KVC%E5%92%8CKVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS图形几何学基础-动画基础之二</title>
    <link href="http://ppsheep.com/2016/11/18/iOS%E5%9B%BE%E5%BD%A2%E5%87%A0%E4%BD%95%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C/"/>
    <id>http://ppsheep.com/2016/11/18/iOS图形几何学基础-动画基础之二/</id>
    <published>2016-11-18T05:58:09.000Z</published>
    <updated>2016-11-19T07:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>UIView有三个比较重要的布局属性：</p>
<ul>
<li>frame    (代表了图层的外部坐标，也就是相对于父视图的位置)</li>
<li>bounds    (代表了内部坐标，其参照的是自己，左上角的左边永远是{0,0})</li>
<li>center    (代表了相对于父图层的anchorPoint所在的位置，这个我们后面会介绍，现在将他想象成中心点就行)</li>
</ul>
<p>而在CALayr中也有三个与之相对的属性：</p>
<ul>
<li>frame</li>
<li>bounds</li>
<li>position</li>
</ul>
<p>他们一一对应</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.1.jpeg" alt=""></p>
<p>从上面这张图中我们可以看出，frame的左上角坐标，是相对于父图层的位置</p>
<p><strong>注意</strong><br>我们通常修改视图的frame、bounds、center其实都只是存取方法，实质上修改的还是位于视图下的CALayer的frame、bounds和center</p>
<p>在我们日常的做图层变换中，经常做一些旋转或者缩放，这时候，frame和bounds的就不再一致了</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.2.jpeg" alt=""></p>
<p>在这幅图中，我们将图层做了一个旋转，我们可以看到，frame是整个图层占据的外层的那个大矩形的区域，而bounds是图层的内部坐标，所以bounds依然没有改变</p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>之前我们提到过anchorPoint，视图的center和图层的position属性，指定的anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame位置，其实就是通过anchorPoint来移动图层</p>
<p>默认anchorPoint位于图层的中点，但是anchorPoint是属性并没有被UIView暴露出来，这也是视图的属性被叫做center的原因。</p>
<p><strong>接下来，我要讲的都是跟图层相关，需要抛开视图的概念，不然，就比较难以理解了</strong></p>
<p>因为图层的anchorPoint可以被移动，我们之前说过图层的anchorPoint通过position来控制它的frame的位置，那么如果我们将图层的anchorPoint置于图层的frame的左上角，那么图层将会怎么移动呢，图层将会向右下角移动</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.3.jpeg" alt=""></p>
<p>这里需要大家好好理解一下，position属性为什么没有变，而frame却改变了</p>
<p>anchorPoint的坐标 也是使用的相对坐标来表示，当然也可以指定他是小于0或者大于1，来将图层内容放在图层范围之外</p>
<p>那我们在想，我们可以通过图层的frame随意改变图层的位置，为什么还要通过anchorPoint来改变图层的位置，而且这个这么难以理解</p>
<p>我们来举一个例子：</p>
<p>我们需要模拟一个闹钟，闹钟的钟面由四张图片组成，为了简单，我们还是使用传统的四个UIImgaeView来加载，当然你也可以使用contents属性</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.5.jpeg" alt=""></p>
<p>我们使用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">                  ￼</div><div class="line">    //set initial hand positions</div><div class="line">    [self tick];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//convert time to hours, minutes </div><div class="line"></div><div class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">//calculate hour hand angle //calculate minute hand angle</div><div class="line">CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">//calculate second hand angle</div><div class="line">CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">//rotate hands</div><div class="line">self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.6.jpeg" alt=""></p>
<p>这样看起来有点怪，我们可以看到，明显的时针分针的转动，都是通过中心位置转动，为什么呢？<br>因为默认的anchorPoint在中心位置，图片的旋转，都是围绕anchorPoint转动的，这时候我们就需要移动anchorPoint的位置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); </div><div class="line">self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); </div><div class="line">self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div></pre></td></tr></table></figure>
<p>将每个指针的anchorPoint移动到需要他围绕旋转的位置</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-3.7.jpeg" alt=""></p>
<h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><p>圆角是iOS的一个标志性美学效果，我们想要实现圆角效果其实很简单</p>
<p>CALayer有一个属性叫做conrnerRadius控制着图层的角的曲率，默认情况下，他为0表示<br>矩形，但是我们将他设置成任意的值</p>
<p>我们在当前的VC中添加一个UIImageView,并设置他的cornerRadius为20个点，我们来看看效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImageView *imagView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;timg&quot;]];</div><div class="line">imagView.frame = CGRectMake(50, 100, 150, 200);</div><div class="line">imagView.layer.cornerRadius = 20;</div><div class="line">[self.view addSubview:imagView];</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-Snip20161119_1.png" alt=""></p>
<p>我们看到这个视图并没有显示出圆角，这是什么原因？</p>
<p>这是因为</p>
<p><strong>默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层</strong></p>
<p>不过，如果我们将masksToBounds设置为yes，那么图层里面的所有东西都会被截取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">imagView.layer.masksToBounds = YES;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-070020.jpg" alt=""></p>
<p>这样效果就出来了</p>
<p>再来试一个例子，我们在这个图层的左上角加上一个超出了图片边界的一个view</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImageView *imagView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;timg&quot;]];</div><div class="line">imagView.frame = CGRectMake(50, 100, 150, 200);</div><div class="line">//    imagView.layer.masksToBounds = YES;</div><div class="line">imagView.layer.cornerRadius = 20;</div><div class="line">[self.view addSubview:imagView];</div><div class="line">    </div><div class="line">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(-10, -10, 20, 20)];</div><div class="line">view.backgroundColor = [UIColor redColor];</div><div class="line">[imagView addSubview:view];</div></pre></td></tr></table></figure>
<p>如果我们未将图层的masksToBounds设置为yes，那么我们得到的效果是这样的</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-070343.jpg" alt=""></p>
<p>我们之前讲过，不管是图层还是视图，都会默认渲染超出父图层的视图或者图层</p>
<p>如果我们将masksToBounds设置成了yes，按照我们之前讲的，这个红色的区域应该会被裁剪，那我们来看看效果</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-070514.jpg" alt=""></p>
<p>这样就完全将图层裁剪</p>
<h3 id="图层边框"><a href="#图层边框" class="headerlink" title="图层边框"></a>图层边框</h3><p>CALayer还有两个非常有用的属性，borderWidth和borderColor，这两个可以用来设置图层边的样式</p>
<p>我们设置一下图片的边框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImageView *imagView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;timg&quot;]];</div><div class="line">imagView.frame = CGRectMake(50, 100, 150, 200);</div><div class="line">//    imagView.layer.masksToBounds = YES;</div><div class="line">imagView.layer.cornerRadius = 20;</div><div class="line">[self.view addSubview:imagView];</div><div class="line">    </div><div class="line">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(-10, -10, 20, 20)];</div><div class="line">view.backgroundColor = [UIColor redColor];</div><div class="line">[imagView addSubview:view];</div><div class="line">    </div><div class="line">imagView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class="line">imagView.layer.borderWidth = 4;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-070912.jpg" alt=""></p>
<p>大家不要奇怪，为什么我们的边框会是这样的，那是因为图层的边框是跟着边界走的，和图层的内容并不相关，我们之前设置了图层的圆角，那么图层的边框就已经成为了有圆角的，但是图层内容，因为我们没有设置masksToBounds，所以图层的内容没有被裁剪</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-071146.jpg" alt=""></p>
<p>设置一下masksToBounds就可以了</p>
<p><strong>所以设置圆角的时候不要忘记了masksToBounds属性</strong></p>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>接下来，我们来介绍阴影，我们可以通过shadowOpacity来设置图层的阴影，<strong><em>shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数</em></strong></p>
<p>如果我们要改变阴影的表现，有三个属性，可以通过他们来改变阴影的表现</p>
<ul>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowRadius</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImageView *imagView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;1&quot;]];</div><div class="line">imagView.frame = CGRectMake(50, 100, 150, 200);</div><div class="line">[self.view addSubview:imagView];</div><div class="line">    </div><div class="line">imagView.layer.shadowColor = [UIColor redColor].CGColor;</div><div class="line">imagView.layer.shadowOffset = CGSizeMake(10, 20);</div><div class="line">imagView.layer.shadowRadius = 10;</div><div class="line">imagView.layer.shadowOpacity = 0.5;</div></pre></td></tr></table></figure>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-19-072737.jpg" alt=""></p>
<p><strong>shadowColor</strong>肯定是控制阴影颜色的，这个不用讲<br><strong>shadowOffset</strong>控制着阴影的方向和距离，他是一个CGSize，宽度控制这阴影横向的位移，高度控制着纵向的位移<br><strong>shadowRadius</strong>控制着阴影的模糊度</p>
<p>我们通过阴影可以将我们的视图的立体感增强</p>
]]></content>
    
    <summary type="html">
    
      之前我们介绍了CALayer的一些重要的属性，在本章中，我将继续介绍关于CALayer的一些属性的使用，在本章结束之后，我们将来实现一些动画效果
    
    </summary>
    
      <category term="iOS动画基础" scheme="http://ppsheep.com/categories/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="动画基础" scheme="http://ppsheep.com/tags/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS sqlite简单封装使用</title>
    <link href="http://ppsheep.com/2016/11/17/iOS-sqlite%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://ppsheep.com/2016/11/17/iOS-sqlite简单封装使用/</id>
    <published>2016-11-17T08:38:49.000Z</published>
    <updated>2016-11-17T09:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>首先来看一下我的项目结构</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79jw1f9v75zwsfkj307d0gv0tu.jpg" alt=""></p>
<h3 id="封装思路"><a href="#封装思路" class="headerlink" title="封装思路"></a>封装思路</h3><p>数据层的基本封装思路是：</p>
<ul>
<li>首先我们需要一个数据库管理类，这个管理类主要是管理数据库文件，因为我们可能会有很多个数据库文件，需要这样一个管理类</li>
<li>一个基础的BaseDBStore，其中主要是我们需要执行的一些基本的操作，包括增、删、改、查，然后每个模块需要使用到数据库的时候，他们有单独的子模块，是从Base继承而来</li>
</ul>
<p>数据库管理类的实现代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;FMDB.h&quot;</div><div class="line"></div><div class="line">@interface PPSDBManager : NSObject</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> *  DB队列  还可以定义其他的数据库 这里只是一个示例</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) FMDatabaseQueue *commonQueue;</div><div class="line"></div><div class="line">+ (PPSDBManager *)sharedInstance;</div><div class="line"></div><div class="line">/**</div><div class="line"> 创建数据库文件</div><div class="line"></div><div class="line"> @param userId 传入用户id</div><div class="line"> @return 数据库文件地址</div><div class="line"> */</div><div class="line">+ (NSString *)dbPath:(NSString *)userId;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里加入了用户思想，即每个用户是一个数据库文件，这样好区分，而且每个用户可以拥有不同的数据库文件，这里只创建了一个，当然还可以创建很多个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &quot;PPSDBManager.h&quot;</div><div class="line"></div><div class="line">static PPSDBManager *manager;</div><div class="line">@implementation PPSDBManager</div><div class="line"></div><div class="line">+(PPSDBManager *)sharedInstance&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        NSString *userID = @&quot;ppsheep&quot;;//随便写了一个id</div><div class="line">        manager = [[PPSDBManager alloc] initWithUserId:userID];</div><div class="line">    &#125;);</div><div class="line">    return manager;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 一般的，如果有用户的APP，这里就可以传入当前用户的id 用以区分数据库</div><div class="line"> 这里我就随便写了</div><div class="line"> @param userId 用户id</div><div class="line"> @return 实例</div><div class="line"> */</div><div class="line">- (instancetype)initWithUserId:(NSString *)userId&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        NSString *commonQueuePath = [PPSDBManager dbPath:userId];</div><div class="line">        self.commonQueue = [FMDatabaseQueue databaseQueueWithPath:commonQueuePath];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> 数据库文件地址</div><div class="line"></div><div class="line"> @return 地址</div><div class="line"> */</div><div class="line">+ (NSString *)dbPath: (NSString *)userId&#123;</div><div class="line">     NSString *path = [NSString stringWithFormat:@&quot;%@/User/%@/Setting/DB/&quot;, NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0], userId];</div><div class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:path]) &#123;</div><div class="line">        //创建数据库文件</div><div class="line">        NSError *error;</div><div class="line">        [[NSFileManager defaultManager] createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&amp;error];</div><div class="line">        if (error) &#123;</div><div class="line">            NSLog(@&quot;创建数据库文件失败：%@&quot;,path);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [path stringByAppendingString:@&quot;common.sqlite3&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>BaseStore</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;PPSDBManager.h&quot;</div><div class="line"></div><div class="line">@interface PPSDBBaseStore : NSObject</div><div class="line"></div><div class="line"></div><div class="line">// 数据库操作队列(从NADBManager中获取，默认使用commonQueue)</div><div class="line">@property (nonatomic, weak) FMDatabaseQueue *dbQueue;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  表创建</div><div class="line"> */</div><div class="line">- (BOOL)createTable:(NSString*)tableName withSQL:(NSString*)sqlString;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行带数组参数的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">-(BOOL)excuteSQL:(NSString*)sqlString withArrParameter:(NSArray*)arrParameter;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行带字典参数的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">-(BOOL)excuteSQL:(NSString*)sqlString withDicParameter:(NSDictionary*)dicParameter;</div><div class="line"></div><div class="line">/*</div><div class="line"> *  执行格式化的sql语句 (增，删，改)</div><div class="line"> */</div><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString,...;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  执行查询指令</div><div class="line"> */</div><div class="line">- (void)excuteQuerySQL:(NSString*)sqlStr resultBlock:(void (^)(FMResultSet * rsSet))resultBlock;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Base定义的一些基础的操作，注释都写的很清楚，我就不一一解释了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//查询语句</div><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString,...</div><div class="line">&#123;</div><div class="line">    __block BOOL ok = NO;</div><div class="line">    if (self.dbQueue) &#123;</div><div class="line">        va_list args;</div><div class="line">        va_list *p_args;</div><div class="line">        p_args = &amp;args;</div><div class="line">        va_start(args, sqlString);</div><div class="line">        [self.dbQueue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">            ok = [db executeUpdate:sqlString withVAList:*p_args];</div><div class="line">        &#125;];</div><div class="line">        va_end(args);</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>带参数的查询方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (BOOL)excuteSQL:(NSString *)sqlString withArrParameter:(NSArray *)arrParameter</div><div class="line">&#123;</div><div class="line">    __block BOOL ok = NO;</div><div class="line">    if (self.dbQueue) &#123;</div><div class="line">        [self.dbQueue inDatabase:^(FMDatabase *db) &#123;</div><div class="line">            ok = [db executeUpdate:sqlString withArgumentsInArray:arrParameter];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Base里面的方法，都是调用FMDB</p>
<h3 id="User模块"><a href="#User模块" class="headerlink" title="User模块"></a>User模块</h3><p>现在，我们有一个User模块，需要实现用户的存取，首先，我们需要一个装SQL的文件，分离SQL</p>
<p>PPSDBUserSQL.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#ifndef PPSDBUserSQL_h</div><div class="line">#define PPSDBUserSQL_h</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#define     USER_TABLE_NAME              @&quot;user&quot;</div><div class="line">/**</div><div class="line"> *  建表</div><div class="line"> *</div><div class="line"> *  @param uid   当前用户Corp邮箱前缀</div><div class="line"> *  @param fid    好友Corp邮箱前缀</div><div class="line"> *  @param email   Corp邮箱</div><div class="line"> *</div><div class="line"> *  @return</div><div class="line"> */</div><div class="line">#define     SQL_CREATE_USER_TABLE        </div><div class="line">			@&quot;CREATE TABLE IF NOT EXISTS %@(\</div><div class="line">                    uid TEXT,\</div><div class="line">                    name TEXT,\</div><div class="line">                    email TEXT,\</div><div class="line">                    phoneNum TEXT,\</div><div class="line">                    ext1 TEXT,\</div><div class="line">                    ext2 TEXT,\</div><div class="line">                    ext3 TEXT,\</div><div class="line">                    ext4 INTEGER DEFAULT (0),\</div><div class="line">                    ext5 INTEGER DEFAULT (0),\</div><div class="line">                    ext6 INTEGER DEFAULT (0),\</div><div class="line">                    PRIMARY KEY(uid))&quot;</div><div class="line"></div><div class="line">#define     SQL_ADD_USER      @&quot;INSERT OR REPLACE INTO %@ ( uid, name, email, phoneNum, ext1, ext2, ext3, ext4, ext5, ext6) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;</div><div class="line"></div><div class="line">#define     SQL_SELECT_USER   @&quot;SELECT * FROM %@ WHERE uid = &apos;%@&apos;&quot;</div><div class="line"></div><div class="line">#define     SQL_GET_ALL_USER   @&quot;SELECT * FROM %@ &quot;</div><div class="line"></div><div class="line">#define     SQL_DELETE_USER    @&quot;DELETE FROM %@ WHERE uid = &apos;%@&apos;&quot;</div><div class="line"></div><div class="line">#define     SQL_UPDATE_USER    @&quot;UPDATE %@ SET name = ?, email = ?, phoneNum = ? WHERE uid = &apos;%@&apos; &quot;</div><div class="line"></div><div class="line"></div><div class="line">#endif /* PPSDBUserSQL_h */</div></pre></td></tr></table></figure>
<p>然后是具体的操作User的Store 包含了基本的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &quot;PPSDBBaseStore.h&quot;</div><div class="line"></div><div class="line">@class PPSUser;</div><div class="line">@interface PPSDBUserStore : PPSDBBaseStore</div><div class="line"></div><div class="line">//改</div><div class="line">- (BOOL)updateUserData:(NSArray *)users;</div><div class="line"></div><div class="line">//增</div><div class="line">- (BOOL)addUser:(NSArray *)users;</div><div class="line"></div><div class="line">//查</div><div class="line">- (NSMutableArray *)usersByUserIds:(NSArray *)userIds;</div><div class="line"></div><div class="line">//删</div><div class="line">- (BOOL)deleteUserByUid:(NSArray *)userIds;</div><div class="line"></div><div class="line">- (NSArray *)allUsers;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>批量查询用户，传入id数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(NSMutableArray *)usersByUserIds:(NSArray *)userIds&#123;</div><div class="line">    NSArray *ids = [userIds copy];</div><div class="line">    __block NSMutableArray *data = [[NSMutableArray alloc] init];</div><div class="line">    </div><div class="line">    for (NSString *userId in ids) &#123;</div><div class="line">      NSString *sqlString = [NSString stringWithFormat:SQL_SELECT_USER, USER_TABLE_NAME, userId];</div><div class="line">        [self excuteQuerySQL:sqlString resultBlock:^(FMResultSet *retSet) &#123;</div><div class="line">            while ([retSet next]) &#123;</div><div class="line">                NSDictionary *dic = @&#123;</div><div class="line">                                      @&quot;userId&quot; : [retSet stringForColumn:@&quot;uid&quot;],</div><div class="line">                                      @&quot;email&quot; : [retSet stringForColumn:@&quot;email&quot;],</div><div class="line">                                      @&quot;name&quot; : [retSet stringForColumn:@&quot;name&quot;],</div><div class="line">                                      @&quot;phoneNum&quot; : [retSet stringForColumn:@&quot;phoneNum&quot;],</div><div class="line">                                      &#125;;</div><div class="line">                PPSUser *user = [[PPSUser alloc] initWithDic:dic];</div><div class="line">                [data addObject:user];</div><div class="line">            &#125;</div><div class="line">            [retSet close];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>批量更新用户，传入用户数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(BOOL)updateUserData:(NSArray *)users&#123;</div><div class="line">    NSArray *userCopy = [users copy];</div><div class="line">    BOOL ok = YES;</div><div class="line">    for (PPSUser *user in userCopy) &#123;</div><div class="line">        NSString *sql = [NSString stringWithFormat:SQL_UPDATE_USER, USER_TABLE_NAME, user.userId];</div><div class="line">        NSArray *arrPara = [NSArray arrayWithObjects:</div><div class="line">                            PPSNoNilString(user.name),</div><div class="line">                            PPSNoNilString(user.email),</div><div class="line">                            PPSNoNilString(user.phoneNum),</div><div class="line">                            @&quot;&quot;, @&quot;&quot;, @&quot;&quot;, @0, @0, @0,  nil];</div><div class="line">        ok = [self excuteSQL:sql withArrParameter:arrPara];</div><div class="line">    &#125;</div><div class="line">    return ok;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>为了方便，我就直接在ViewController中写了，在真正的开发中，一般都会在管理类中进行数据库操作</p>
<p>懒加载一个用户数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(PPSDBUserStore *)store&#123;</div><div class="line">    if (!_store) &#123;</div><div class="line">        _store = [[PPSDBUserStore alloc] init];</div><div class="line">    &#125;</div><div class="line">    return _store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化用户，直接插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)initUsers&#123;</div><div class="line">    NSMutableArray *arr = [NSMutableArray array];</div><div class="line">    for (int i=0; i&lt;10; i++) &#123;</div><div class="line">        PPSUser *user = [[PPSUser alloc] init];</div><div class="line">        user.userId = [NSString stringWithFormat:@&quot;%ld_userId&quot;,(long)i];</div><div class="line">        user.name = [NSString stringWithFormat:@&quot;%ld_userName&quot;,(long)i];</div><div class="line">        user.email = [NSString stringWithFormat:@&quot;%ld_email&quot;,(long)i];</div><div class="line">        user.phoneNum = [NSString stringWithFormat:@&quot;%ld_phoneNum&quot;,(long)i];</div><div class="line">        [arr addObject:user];</div><div class="line">    &#125;</div><div class="line">    [self.store addUser:arr];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我就不再贴代码出来了，项目工程，我放在了</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/iOS%20sqlite使用" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS%20sqlite使用</a></p>
]]></content>
    
    <summary type="html">
    
      sqlite几乎在每个APP编码都会涉及到，它是一种轻量级的数据库，在手机端使用起来极其方便，因为SQLite原生的接口都是使用C写的，不是特别友好，所有有一个强大库就出现了FMDB，今天我们基于FMDB来进行二次封装
    
    </summary>
    
      <category term="sqlite数据库" scheme="http://ppsheep.com/categories/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sqlite" scheme="http://ppsheep.com/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title>iOS每个ViewController一个NavigationBar</title>
    <link href="http://ppsheep.com/2016/11/17/iOS%E6%AF%8F%E4%B8%AAViewController%E4%B8%80%E4%B8%AANavigationBar/"/>
    <id>http://ppsheep.com/2016/11/17/iOS每个ViewController一个NavigationBar/</id>
    <published>2016-11-17T05:03:38.000Z</published>
    <updated>2016-11-17T06:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<p>我们先来看看已经有的一些APP使用的这种效果</p>
<p>这是天猫APP的效果，注意观察他的导航栏</p>
<p><img src="http://i.imgur.com/Hz7Ixkj.gif" alt=""></p>
<p>这是网易新闻，注意看导航栏</p>
<p><img src="http://i.imgur.com/JClX4Z3.gif" alt=""></p>
<p>越来越多的APP采用这种样式来控制导航栏的不同风格，今天我们就来实现这一效果。</p>
<p>这里需要使用到一个第三方库</p>
<p><a href="https://github.com/rickytan/RTRootNavigationController" target="_blank" rel="external">https://github.com/rickytan/RTRootNavigationController</a></p>
<p>借助这个库我们能够轻松实现这一效果</p>
<p>新建一个工程，这里我们使用cocoapods来集成这个第三方库</p>
<h3 id="集成RTRootNavigationController"><a href="#集成RTRootNavigationController" class="headerlink" title="集成RTRootNavigationController"></a>集成RTRootNavigationController</h3><p>podfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">workspace ‘iOS每个VC单独的一个导航栏.xcworkspace’</div><div class="line"></div><div class="line">project ‘iOS每个VC单独的一个导航栏.xcodeproj’</div><div class="line"></div><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line"></div><div class="line">target &apos;iOS每个VC单独的一个导航栏&apos; do </div><div class="line"></div><div class="line">pod ‘RTRootNavigationController’</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="使用RTRootNavigationController当做当前的rootController"><a href="#使用RTRootNavigationController当做当前的rootController" class="headerlink" title="使用RTRootNavigationController当做当前的rootController"></a>使用RTRootNavigationController当做当前的rootController</h3><h4 id="创建BaseViewController"><a href="#创建BaseViewController" class="headerlink" title="创建BaseViewController"></a>创建BaseViewController</h4><p>我这里新建一个BaseViewController 主要是为了引入RTRootNavigationController，当然如果是OC项目的话，可以直接创建一个PCH文件，直接全局引用也行，不过我们一般都会有一个基类的ViewController，在这个基类中，没有做任何操作，只是引用了一个RTRootNavigationController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &quot;RTRootNavigationController.h&quot;</div><div class="line"></div><div class="line">@interface BaseViewController : UIViewController</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="设置根控制器"><a href="#设置根控制器" class="headerlink" title="设置根控制器"></a>设置根控制器</h4><p>在Appdelegate中，我们需要将我们的window的rootcontroller设置为RTRootNavigationController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">ViewController *viewController = [[ViewController alloc] init];</div><div class="line">RTRootNavigationController *rootViewController1 = [[RTRootNavigationController alloc] initWithRootViewController:viewController];</div><div class="line">_window.rootViewController = rootViewController1;</div><div class="line">_window.backgroundColor = [UIColor whiteColor];</div><div class="line">[_window makeKeyAndVisible];</div><div class="line">return YES;</div></pre></td></tr></table></figure>
<p>在ViewController中，我们需要push出去一个vc的时候，我们需要这样实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//注意这里push的时候需要使用rt_navigation push出去</div><div class="line">[self.rt_navigationController pushViewController:vc1 animated:YES complete:nil];</div></pre></td></tr></table></figure>
<p>看一下效果</p>
<p><img src="http://i.imgur.com/L89Z6fk.gif" alt=""></p>
<h4 id="设置返回NavigationBar按钮"><a href="#设置返回NavigationBar按钮" class="headerlink" title="设置返回NavigationBar按钮"></a>设置返回NavigationBar按钮</h4><p>在当前的vc中，我们设置返回按钮，或者其他的按钮，也很方便</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> UIButton *btn1 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn1 addTarget:self action:@selector(leftBar1Clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn1 setTitle:@&quot;返回1&quot; forState:UIControlStateNormal];</div><div class="line">[btn1 setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</div><div class="line">[btn1 sizeToFit];</div><div class="line">UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithCustomView:btn1];</div><div class="line">    </div><div class="line">UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn2 setTitle:@&quot;返回2&quot; forState:UIControlStateNormal];</div><div class="line">[btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">[btn2 addTarget:self action:@selector(leftBar2Clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn2 sizeToFit];</div><div class="line">UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithCustomView:btn2];</div><div class="line"></div><div class="line">self.navigationItem.leftBarButtonItems = @[item1,item2];</div><div class="line">    </div><div class="line">UIButton *btn3 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">[btn3 setTitle:@&quot;右键&quot; forState:UIControlStateNormal];</div><div class="line">[btn3 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">[btn3 addTarget:self action:@selector(rightBarClicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">[btn3 sizeToFit];</div><div class="line">UIBarButtonItem *rightItem = [[UIBarButtonItem alloc] initWithCustomView:btn3];</div><div class="line">    </div><div class="line">self.navigationItem.rightBarButtonItem = rightItem;</div><div class="line">    </div><div class="line">[self.view addSubview:label];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/zOrrJZW.jpg" alt=""></p>
<p>多个按钮定义也是很方便的</p>
<p>如果只是需要一个左边的返回按钮，这个按钮需要自定义样式，那么可以直接在当前VC冲下方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> 如果对于返回事件不需要做任何处理，</div><div class="line"> 但是有想要自定义返回按钮的样式，</div><div class="line"> 可以直接重写这个方法</div><div class="line"></div><div class="line"> @param target 监听对象</div><div class="line"> @param action 返回事件</div><div class="line"> @return 自定义的返回按钮</div><div class="line"> */</div><div class="line">-(UIBarButtonItem *)customBackItemWithTarget:(id)target action:(SEL)action&#123;</div><div class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</div><div class="line">    [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class="line">    [btn sizeToFit];</div><div class="line">    [btn addTarget:target action:action forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithCustomView:btn];</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，就不要去单独设置左上角的返回按钮了</p>
<p><img src="http://i.imgur.com/I5tVOEx.gif" alt=""></p>
<h4 id="跳到最开始的VC"><a href="#跳到最开始的VC" class="headerlink" title="跳到最开始的VC"></a>跳到最开始的VC</h4><p>在我们pop的时候，可以直接pop在栈顶的VC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[self.rt_navigationController popToRootViewControllerAnimated:YES complete:nil];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/tQ2vyPz.gif" alt=""></p>
<h4 id="push到另外一个VC-销毁当前的VC"><a href="#push到另外一个VC-销毁当前的VC" class="headerlink" title="push到另外一个VC 销毁当前的VC"></a>push到另外一个VC 销毁当前的VC</h4><p>有时我们想要实现这样一种效果，当当前的VCpush出去过后，希望销毁当前的VC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ViewController4 *vc4 = [[ViewController4 alloc] init];</div><div class="line">[self.rt_navigationController pushViewController:vc4 animated:vc4 complete:^(BOOL finished) &#123;</div><div class="line">     [self.rt_navigationController removeViewController:self];</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/8ABurCG.gif" alt=""></p>
<h4 id="更改导航栏颜色"><a href="#更改导航栏颜色" class="headerlink" title="更改导航栏颜色"></a>更改导航栏颜色</h4><p>之前忘记更改导航栏的颜色了，这里看一下，更改导航栏的颜色，只需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self.navigationController.navigationBar.barTintColor = [UIColor greenColor];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/mFby2bB.gif" alt=""></p>
<p><strong>总结</strong></p>
<p>如果你的APP在导航栏有多种样式的话，你完全可以使用这种方法，使用起来很方便</p>
<p>感谢:<br>    rickyTan开源<br>    <a href="https://github.com/rickytan/RTRootNavigationController" target="_blank" rel="external">https://github.com/rickytan/RTRootNavigationController</a></p>
<p>项目的源码我放在了：<br>    <a href="https://github.com/yangqian111/blog/tree/master/iOS每个VC单独的一个导航栏" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/iOS每个VC单独的一个导航栏</a></p>
]]></content>
    
    <summary type="html">
    
      在日常开发中，我们经常会碰到一些关于导航栏的问题，例如视觉设计，经常性的改变NavigationBar的风格，虽然我们能够在viewwillApper中来进行处理，但是总是太麻烦，而且需要写很多多余的代码，今天就来讲讲这种效果，其实已经有很多APP都是使用这种效果
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS CALayer基础介绍-动画基础之一</title>
    <link href="http://ppsheep.com/2016/11/16/iOS%20CALayer%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D-%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/"/>
    <id>http://ppsheep.com/2016/11/16/iOS CALayer基础介绍-动画基础之一/</id>
    <published>2016-11-16T10:40:46.000Z</published>
    <updated>2016-11-19T07:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎大家关注我的公众号，我会定期分享一些我在项目中遇到问题的解决办法和一些iOS实用的技巧，现阶段主要是整理出一些基础的知识记录下来</strong></p>
<div align="middle"><br>    <image src="http://ac-mhke0kuv.clouddn.com/830a4ead8294ceff5160.jpg"></image><br></div>

<p>文章也会同步更新到我的博客：<br><a href="http://ppsheep.com">http://ppsheep.com</a></p>
<h3 id="动画的由来"><a href="#动画的由来" class="headerlink" title="动画的由来"></a>动画的由来</h3><p>在iOS中所有的视图都是从UIView的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，也能够做一些简单的动画，比如旋转、缩放或者其他一些滑动渐变的动画。但是实际上，这是苹果为我们封装了一层，真正实现动画的其实是一个叫做图层的玩意儿(CALayer)，UIView所做的一切动画，都是苹果从CALayer封装而来。</p>
<h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><p>CALayer类在概念上和UIView类似，也可以像View一样添加一些子layer(图片，文本等等)，也能够像View一样，管理子图层的位置大小等等，并且，CALayer有一些非常重要的属性和方法，iOS中的动画就是通过这些来做动画和变换，CALayer和UIView最大的不同就是CALayer不处理用户的交互。</p>
<h3 id="UIView和CALayer的关系"><a href="#UIView和CALayer的关系" class="headerlink" title="UIView和CALayer的关系"></a>UIView和CALayer的关系</h3><p>每一个UIView都有一个CALayer实例属性，UIView的职责就是创建并创建这个图层，以确保在子视图被创建时，子图层也能够被创建，子视图被添加和移除的时候，子图层也能够做相对的添加移除操作。 他们的关系是一一对应的。</p>
<p><img src="http://i.imgur.com/2tvoYIJ.jpg" alt=""></p>
<p>实际上，我们在屏幕上看到的视图或者动画，其实都是图层。UIView只是苹果为我们封装的高级API</p>
<p>这个就有个历史原因了，主要呢 是要在Mac上也使用CALayer，但是iOS设备的触摸和Mac的鼠标点击又不一样，在Mac上，高级API就叫做NSView了，更多了，就不在这里讲了。</p>
<h3 id="哪里能用到CALayer"><a href="#哪里能用到CALayer" class="headerlink" title="哪里能用到CALayer"></a>哪里能用到CALayer</h3><p>一般的，我们在处理一些简单的动画时，都用不到CALayer，既然苹果为我们封装好了，干嘛不用呢？但是如果需要再处理一些高级的动画，那UIView可能就不能满足我们的需求了。</p>
<p>没有暴露出来的CALayer功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h3 id="使用图层"><a href="#使用图层" class="headerlink" title="使用图层"></a>使用图层</h3><p>我们先来感受一下图层</p>
<p>新建一个工程</p>
<p>在view中添加一个view</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIView *layerView = [[UIView alloc] initWithFrame:CGRectMake(10, 10, 200, 200)];</div><div class="line">layerView.backgroundColor = [UIColor redColor];</div><div class="line">layerView.center = self.view.center;</div><div class="line">[self.view addSubview:layerView];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/zEKwKE7.jpg" alt=""></p>
<p>然后我们想要在这个小红方框的中间添加上一个蓝色的小方框。当然，我们肯定知道这很简单，直接加上一个子view就行了，但是这样做的，就失去了我们学习CALayer的意义。</p>
<p>我的想法是这样，既然layer像view一样，那我们是否可以在layerView的layer上加上一个蓝色方框样式的layer 我们的做法是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CALayer *blueLayer = [CALayer layer];</div><div class="line">blueLayer.frame = CGRectMake(50, 50, 100, 100);</div><div class="line">blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">[layerView.layer addSublayer:blueLayer];</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/TrH8GPi.jpg" alt=""></p>
<p>效果就出来了 我们来看看3D图</p>
<p><img src="http://i.imgur.com/z6Tv4S7.jpg" alt=""></p>
<p>我们可以看到，这样的效果，我们只能看到一个图层，一个view 并没有向layerView上添加子view</p>
<p>当然这里我们只是做一个layer的介绍，并不是说你之后添加视图这样添加，这样肯定是错误的，我们之前讲过，layer不能处理用户的交互，这个很重要。</p>
<p>但是在什么情况下，我们需要这样来使用CALayer呢？</p>
<ul>
<li>开发同时可以在macOS上运行的跨平台应用</li>
<li>使用多种CALayer，并不想创建额外的UIView去封装他们(这个后面会讲到)</li>
<li>做一些对性能要求较高的工作，但是遇到这种情况，我们很多时候都直接使用OpenGL绘图了</li>
</ul>
<p>总的来说呢，处理视图肯定比处理图层简单多了</p>
<p>我们这里创建这一个例子，只是为了来介绍，图层的树状结构，和视图的一一关联关系。</p>
<h3 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h3><p>寄宿图是什么意思呢?其实呢，就是图层中包含图</p>
<h4 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h4><p>在CALayer中有一个属性，叫做contents，这个属性的类型被定义为id，看上去好像这个属性能够接收任意类型的值，如果给contents赋予了任意一个类型的值，你的APP也能够编译成功，但是得到的图层确实一个空白的图层，事实上，这个contents在iOS下，是需要一个CGImage的值。</p>
<p>那为什么这个又要写作一个id类型呢，这个又是一个历史原因了 ，明显的这个是因为macOS的原因，因为在macOS下，这个是接收NSImage类型。</p>
<p>在UIImage中 有一个CGImage属性，他返回的是一个CGImageRef(指向CGImage的指针)，如果你直接把这个赋给contents，那是会编译出错的。CGImageRef是一个Core Foundation对象，并不是一个cocoa对象，但是我们可以通过bridged来进行转换，我们来向刚刚创建的layerView的图层赋予一张图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImage *image = [UIImage imageNamed:@&quot;plane&quot;];</div><div class="line">layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/TbHbXhg.jpg" alt=""></p>
<p>这样我们就避开了UIImageView，直接向UIView的图层设置一张图片</p>
<h4 id="contentsGravity属性"><a href="#contentsGravity属性" class="headerlink" title="contentsGravity属性"></a>contentsGravity属性</h4><p>但是我们看到中间的图片明显被拉伸了，我们想要展示他原有的效果，怎么做呢？</p>
<p>在我们使用UIImageView时，我们处理这种拉伸，一般是使用UIimageView的一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">imageView.contentModel = UIViewContentModeScaleAspectFit;</div></pre></td></tr></table></figure>
<p>在CALayer中有一个和contentMode相似的属性，叫做contentsGravity，不同的是他是一个NSString类型。</p>
<p>contentsGravity值的类型包含：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>这其中的类型与contentMode都有一一对应关系的，其中kCAGravityResizeAspect相当于视图中contentMode类型的UIViewContentModeScaleAspectFit</p>
<p>当我们将layerView的contentsGravity设置成kCAGravityResizeAspect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">layerView.layer.contentsGravity = kCAGravityResizeAspect;</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/cTH6idP.jpg" alt=""></p>
<p>效果就不一样了</p>
<h4 id="contentsScale属性-主要针对Mac"><a href="#contentsScale属性-主要针对Mac" class="headerlink" title="contentsScale属性(主要针对Mac)"></a>contentsScale属性(主要针对Mac)</h4><p>contentsScale定义了寄宿图的像素尺寸和视图大小的比例，默认情况下是一个值为1.0的浮点数。那么我们一般怎么使用这个属性呢？</p>
<p>这个属性其实是为了支持高分辨率屏幕机制而出现的，他用来判断在绘制图层的时候，应该为寄宿图创建创建的空间大小和需要显示图片的拉伸度。</p>
<p>简单来说，如果我们将contentsScale设置为1.0 那么寄宿图创建出来的图片将会以每个点一个像素来绘制图片，如果设置为2，那么将会以每个点2个像素来绘制图片。这个就是我们熟知的retina屏幕。</p>
<p>在我们之前使用contentsGravity = kCAGravityResizeAspect这个属性时，默认是将图片等比例拉伸至适应图层大小，但是，如果我们将contentsGravity设置成kCAGravityCenter，我们看一下，效果会是什么样？</p>
<p><img src="http://i.imgur.com/e9qmb5i.jpg" alt=""></p>
<p>整个图片直接放大，将原图层盖住，这是因为kCAGravityCenter属性值，默认是不会对图片进行拉伸，所以将图片的原始大小展示了出来，这时候，我们的contentsScale就起到了作用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">layerView.layer.contentsScale = image.scale;</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/RyHbQXJ.jpg" alt=""></p>
<p>这时，我们看到，现在使用了正确的图片来进行绘制</p>
<p><strong>注意，当我们使用代码来设置寄宿图时，我们一定要手动设置contentsScale</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">layerView.layer.contentsScale = [UIScreen mainScreen].scale;</div></pre></td></tr></table></figure>
<p>这样，我们的图片在retina设备上，才会显示正常。</p>
<h4 id="maskToBounds属性"><a href="#maskToBounds属性" class="headerlink" title="maskToBounds属性"></a>maskToBounds属性</h4><p>不知大家有没有注意到，在上面的图中，我们的图片已经超过了图层的边界，默认情况下，在UIView中，也会绘制超过边界的内容或者子视图。</p>
<p>在UIView中，控制是否超出边界的属性是clipsToBounds，在CALayer中，控制的属性是masksToBounds，将他设置成yes</p>
<p><img src="http://i.imgur.com/7Uh0sZd.jpg" alt=""></p>
<h4 id="contentsRect属性"><a href="#contentsRect属性" class="headerlink" title="contentsRect属性"></a>contentsRect属性</h4><p>contentRect属性，允许我们在图层中显示寄宿图的部分区域，这涉及到图片的显示和图片是如何拉伸的，所以比contentsGravity灵活得多，这里也会多讲一下。</p>
<p>虽然这个属性有带一个rect的样式，这样很容易让我们想到bounds和frame，但是这个属性和他们的使用方法确是不一样的。他使用的是单位坐标，单位坐标指定在0到1之间，是一个相对值，是相对于寄宿图的位置和大小。</p>
<p>默认的contentsRect是{0，0，1，1} 这样就表示寄宿图的全部区域。如果我们指定一个区域，那么寄宿图就会被显示一部分区域</p>
<p><img src="https://farm6.staticflickr.com/5726/25392255929_3569dda784_o.jpg" alt=""></p>
<p>可以看到现在寄宿图是全部显示的，这时候我们来设置一下layer的contentsRect属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">layerView.layer.contentsRect = CGRectMake(0.5, 0.5, 0.5, 0.5);</div></pre></td></tr></table></figure>
<p>这时候，图层就会这样显示</p>
<p><img src="https://farm6.staticflickr.com/5583/30726952920_0a80ddf4ee_o.jpg" alt=""></p>
<p>明显我们可以看到 这是显示的图片的右下角区域 这样显示也是我们给定的{0.5，0.5，0.5，0.5}决定的 从图片的中点位置开始，显示半宽半高</p>
<p>那么我们在做APP时，什么地方经常使用到这个属性呢？</p>
<p>我们经常在图片拼合的时候用到这个属性，这个图片拼合概念在游戏开发中经常碰到。<br>说简单点，就是将多张图片打包成一张图片，然后一次性载入这一帐图片，这样带来的好处就是能够在内存使用上，屏幕渲染上节省很多性能。</p>
<p>例子：这种使用方法，我们常见的APP中，很多美颜的相机使用了layer添加一些效果图片到当前的显示视图上，比如添加一个什么笑脸啊，相框啊之类的。</p>
<h4 id="contentsCenter属性"><a href="#contentsCenter属性" class="headerlink" title="contentsCenter属性"></a>contentsCenter属性</h4><p>咋一看，我们会以为这个和寄宿图的位置相关，其实不是的，这个属性主要是用来控制图片的拉伸，其实他是一个CGRect，他定义了<strong>一个固定的边框和一个在图层上可以拉伸的区域，改变contentsCenter的值，并不会影响寄宿图的显示，除非这个图层的大小改变了，我们才能看得到结果</strong></p>
<p>contentsCenter默认的大小是{0，0，1，1}，这就意味着，如果图层的大小改变了，那么整个寄宿图都会被均匀拉伸，如果我们改变contentsCenter这个属性，定义一个拉伸的区域，那么我们就能看到效果了</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/blog/2016-11-16-006tNbRwjw1f9u68sxw6ij31kw23uqt1.jpg" alt=""></p>
<p><strong>注意</strong><br>这里我画了一张图，整个一个方框表示的是一个图层，如果我们将图层的contentsCenter设置为{0.25，0.25，0.25，0.25}那么，其实这个rect形成的一个方框就是中间的I区域，相当于整个图层的正中心，宽高各一半的位置  如果我们现在改变了图层的大小的话，我们定义了这样一个拉伸区域{0.25，0.25，0.25，0.25}，表示的就是在横向拉伸中H区域和D区域会被拉伸，在纵向拉伸中，B区域和F区域会被拉伸，而中间的I区域则是横向纵向均会被拉伸，而其中的A、C、E、G则不会被拉伸，可能这里需要着重理解一下</p>
<blockquote>
<p>到这里，基本上就将CALayer中我们可能会经常使用到的一些重要属性讲解了一下</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      在上一篇文章中我们讲了CALayer和UIView之间的相似的树级关系，和他们之间的管理关系，并且介绍了CALayer的一些属性，在这片文章中，将继续介绍一些CALayer的属性，虽然这看起来很简单，但是后面等到我们做动画的时候，这些属性都是极其重要的。
    
    </summary>
    
      <category term="iOS动画基础" scheme="http://ppsheep.com/categories/iOS%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="动画基础" scheme="http://ppsheep.com/tags/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS基础开发技巧-二</title>
    <link href="http://ppsheep.com/2016/11/09/iOS%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E4%BA%8C/"/>
    <id>http://ppsheep.com/2016/11/09/iOS基础开发技巧-二/</id>
    <published>2016-11-09T08:51:35.000Z</published>
    <updated>2016-11-15T09:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要讲一些我在日常开发中用到的一些小的技巧，其实也算不上技巧吧，就是省去一些不必要的代码，或者有的小问题困扰你很久说不行在这里你能找到答案</p>
<a id="more"></a>
<h3 id="打印系统所有已注册的字体名称"><a href="#打印系统所有已注册的字体名称" class="headerlink" title="打印系统所有已注册的字体名称"></a>打印系统所有已注册的字体名称</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)enumerateFonts&#123;</div><div class="line">    for(NSString *familyName in [UIFont familyNames])</div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,familyName);</div><div class="line">        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];</div><div class="line">        for(NSString *fontName in fontNames)</div><div class="line">        &#123;</div><div class="line">            NSLog(@&quot;\t|- %@&quot;,fontName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (NSString*)reverseWordsInString:(NSString*)str</div><div class="line">&#123;</div><div class="line">    NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length];</div><div class="line">    [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences  usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) &#123;</div><div class="line">        [reverString appendString:substring];</div><div class="line">    &#125;];</div><div class="line">    return reverString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="禁止锁屏"><a href="#禁止锁屏" class="headerlink" title="禁止锁屏"></a>禁止锁屏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[UIApplication sharedApplication].idleTimerDisabled = YES;</div></pre></td></tr></table></figure>
<h3 id="字符串按多个符号分割"><a href="#字符串按多个符号分割" class="headerlink" title="字符串按多个符号分割"></a>字符串按多个符号分割</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)seprartStringWithCharters&#123;</div><div class="line">    NSString *str = @&quot;abc,dsd/123.789&quot;;</div><div class="line">    NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;,/.&quot;];</div><div class="line">    NSLog(@&quot;%@&quot;,[str componentsSeparatedByCharactersInSet:set]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="iOS跳转到App-Store下载应用评分"><a href="#iOS跳转到App-Store下载应用评分" class="headerlink" title="iOS跳转到App Store下载应用评分"></a>iOS跳转到App Store下载应用评分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=APPID&quot;]];</div></pre></td></tr></table></figure>
<h3 id="判断当前ViewController是push还是present的方式显示的"><a href="#判断当前ViewController是push还是present的方式显示的" class="headerlink" title="判断当前ViewController是push还是present的方式显示的"></a>判断当前ViewController是push还是present的方式显示的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSArray *viewcontrollers=self.navigationController.viewControllers;</div><div class="line"></div><div class="line">if (viewcontrollers.count &gt; 1)</div><div class="line">&#123;</div><div class="line">    if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self)</div><div class="line">    &#123;</div><div class="line">        //push方式</div><div class="line">       [self.navigationController popViewControllerAnimated:YES];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    //present方式</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取实际使用的LaunchImage图片"><a href="#获取实际使用的LaunchImage图片" class="headerlink" title="获取实际使用的LaunchImage图片"></a>获取实际使用的LaunchImage图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (NSString *)getLaunchImageName</div><div class="line">&#123;</div><div class="line">    CGSize viewSize = self.window.bounds.size;</div><div class="line">    // 竖屏    </div><div class="line">    NSString *viewOrientation = @&quot;Portrait&quot;;  </div><div class="line">    NSString *launchImageName = nil;    </div><div class="line">    NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];</div><div class="line">    for (NSDictionary* dict in imagesDict)</div><div class="line">    &#123;</div><div class="line">        CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]);</div><div class="line">        if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]])</div><div class="line">        &#123;</div><div class="line">            launchImageName = dict[@&quot;UILaunchImageName&quot;];        </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">    return launchImageName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="iOS在当前屏幕获取第一响应"><a href="#iOS在当前屏幕获取第一响应" class="headerlink" title="iOS在当前屏幕获取第一响应"></a>iOS在当前屏幕获取第一响应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow];</div><div class="line">UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)];</div></pre></td></tr></table></figure>
<h3 id="判断对象是否遵循了某协议"><a href="#判断对象是否遵循了某协议" class="headerlink" title="判断对象是否遵循了某协议"></a>判断对象是否遵循了某协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])</div><div class="line">&#123;</div><div class="line">     [self.selectedController performSelector:@selector(onTriggerRefresh)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断view是不是指定视图的子视图"><a href="#判断view是不是指定视图的子视图" class="headerlink" title="判断view是不是指定视图的子视图"></a>判断view是不是指定视图的子视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BOOL isView = [textView isDescendantOfView:self.view];</div></pre></td></tr></table></figure>
<h3 id="NSArray-快速求总和-最大值-最小值-和-平均值"><a href="#NSArray-快速求总和-最大值-最小值-和-平均值" class="headerlink" title="NSArray 快速求总和 最大值 最小值 和 平均值"></a>NSArray 快速求总和 最大值 最小值 和 平均值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil];</div><div class="line">CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue];</div><div class="line">CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue];</div><div class="line">CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];</div><div class="line">CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];</div><div class="line">NSLog(@&quot;%f\n%f\n%f\n%f&quot;,sum,avg,max,min);</div></pre></td></tr></table></figure>
<h3 id="修改UITextField中Placeholder的文字颜色"><a href="#修改UITextField中Placeholder的文字颜色" class="headerlink" title="修改UITextField中Placeholder的文字颜色"></a>修改UITextField中Placeholder的文字颜色</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</div></pre></td></tr></table></figure>
<h3 id="关于NSDateFormatter的格式"><a href="#关于NSDateFormatter的格式" class="headerlink" title="关于NSDateFormatter的格式"></a>关于NSDateFormatter的格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">G: 公元时代，例如AD公元</div><div class="line">yy: 年的后2位</div><div class="line">yyyy: 完整年</div><div class="line">MM: 月，显示为1-12</div><div class="line">MMM: 月，显示为英文月份简写,如 Jan</div><div class="line">MMMM: 月，显示为英文月份全称，如 Janualy</div><div class="line">dd: 日，2位数表示，如02</div><div class="line">d: 日，1-2位显示，如 2</div><div class="line">EEE: 简写星期几，如Sun</div><div class="line">EEEE: 全写星期几，如Sunday</div><div class="line">aa: 上下午，AM/PM</div><div class="line">H: 时，24小时制，0-23</div><div class="line">K：时，12小时制，0-11</div><div class="line">m: 分，1-2位</div><div class="line">mm: 分，2位</div><div class="line">s: 秒，1-2位</div><div class="line">ss: 秒，2位</div><div class="line">S: 毫秒</div></pre></td></tr></table></figure>
<h3 id="阿拉伯数字转中文格式"><a href="#阿拉伯数字转中文格式" class="headerlink" title="阿拉伯数字转中文格式"></a>阿拉伯数字转中文格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+(NSString *)translation:(NSString *)arebic</div><div class="line">&#123;  </div><div class="line">    NSString *str = arebic;</div><div class="line">    NSArray *arabic_numerals = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;0&quot;];</div><div class="line">    NSArray *chinese_numerals = @[@&quot;一&quot;,@&quot;二&quot;,@&quot;三&quot;,@&quot;四&quot;,@&quot;五&quot;,@&quot;六&quot;,@&quot;七&quot;,@&quot;八&quot;,@&quot;九&quot;,@&quot;零&quot;];</div><div class="line">    NSArray *digits = @[@&quot;个&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;万&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;亿&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;兆&quot;];</div><div class="line">    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];</div><div class="line"></div><div class="line">    NSMutableArray *sums = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; str.length; i ++) &#123;</div><div class="line">        NSString *substr = [str substringWithRange:NSMakeRange(i, 1)];</div><div class="line">        NSString *a = [dictionary objectForKey:substr];</div><div class="line">        NSString *b = digits[str.length -i-1];</div><div class="line">        NSString *sum = [a stringByAppendingString:b];</div><div class="line">        if ([a isEqualToString:chinese_numerals[9]])</div><div class="line">        &#123;</div><div class="line">            if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]])</div><div class="line">            &#123;</div><div class="line">                sum = b;</div><div class="line">                if ([[sums lastObject] isEqualToString:chinese_numerals[9]])</div><div class="line">                &#123;</div><div class="line">                    [sums removeLastObject];</div><div class="line">                &#125;</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                sum = chinese_numerals[9];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if ([[sums lastObject] isEqualToString:sum])</div><div class="line">            &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [sums addObject:sum];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSString *sumStr = [sums componentsJoinedByString:@&quot;&quot;];</div><div class="line">    NSString *chinese = [sumStr substringToIndex:sumStr.length-1];</div><div class="line">    NSLog(@&quot;%@&quot;,str);</div><div class="line">    NSLog(@&quot;%@&quot;,chinese);</div><div class="line">    return chinese;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Base64编码与NSString对象或NSData对象的转换"><a href="#Base64编码与NSString对象或NSData对象的转换" class="headerlink" title="Base64编码与NSString对象或NSData对象的转换"></a>Base64编码与NSString对象或NSData对象的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">NSData *nsdata = [@&quot;iOS Developer Tips encoded in Base64&quot;</div><div class="line">  dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line"></div><div class="line"></div><div class="line">NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0];</div><div class="line"></div><div class="line"></div><div class="line">NSLog(@&quot;Encoded: %@&quot;, base64Encoded);</div><div class="line"></div><div class="line">//另外一种方法</div><div class="line"></div><div class="line"></div><div class="line">NSData *nsdataFromBase64String = [[NSData alloc]</div><div class="line">  initWithBase64EncodedString:base64Encoded options:0];</div><div class="line"></div><div class="line"></div><div class="line">NSString *base64Decoded = [[NSString alloc]</div><div class="line">  initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding];</div><div class="line">NSLog(@&quot;Decoded: %@&quot;, base64Decoded);</div></pre></td></tr></table></figure>
<h3 id="取消UICollectionView的隐式动画"><a href="#取消UICollectionView的隐式动画" class="headerlink" title="取消UICollectionView的隐式动画"></a>取消UICollectionView的隐式动画</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//方法一</div><div class="line">[UIView performWithoutAnimation:^&#123;</div><div class="line">    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">//方法二</div><div class="line">[UIView animateWithDuration:0 animations:^&#123;</div><div class="line">    [collectionView performBatchUpdates:^&#123;</div><div class="line">        [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];</div><div class="line">    &#125; completion:nil];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">//方法三</div><div class="line">[UIView setAnimationsEnabled:NO];</div><div class="line">[self.trackPanel performBatchUpdates:^&#123;</div><div class="line">    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    [UIView setAnimationsEnabled:YES];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="查看某个UIImage占用内存大小"><a href="#查看某个UIImage占用内存大小" class="headerlink" title="查看某个UIImage占用内存大小"></a>查看某个UIImage占用内存大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImage *image = [UIImage imageNamed:@&quot;image&quot;];</div><div class="line">NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);</div></pre></td></tr></table></figure>
<h3 id="UIView设置部分圆角"><a href="#UIView设置部分圆角" class="headerlink" title="UIView设置部分圆角"></a>UIView设置部分圆角</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CGRect rect = view.bounds;</div><div class="line">CGSize radio = CGSizeMake(30, 30);//圆角尺寸</div><div class="line">UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//这只圆角位置</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];</div><div class="line">CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer</div><div class="line">masklayer.frame = view.bounds;</div><div class="line">masklayer.path = path.CGPath;//设置路径</div><div class="line">view.layer.mask = masklayer;</div></pre></td></tr></table></figure>
<h3 id="去掉导航栏的back标题"><a href="#去掉导航栏的back标题" class="headerlink" title="去掉导航栏的back标题"></a>去掉导航栏的back标题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[UIBarButtonItemappearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault];</div></pre></td></tr></table></figure>
<h3 id="dispatch-group的使用"><a href="#dispatch-group的使用" class="headerlink" title="dispatch_group的使用"></a>dispatch_group的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class="line">    dispatch_group_enter(dispatchGroup);</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;第一个请求完成&quot;);</div><div class="line">        dispatch_group_leave(dispatchGroup);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_group_enter(dispatchGroup);</div><div class="line"></div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;第二个请求完成&quot;);</div><div class="line">        dispatch_group_leave(dispatchGroup);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123;</div><div class="line">        NSLog(@&quot;请求完成&quot;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h3 id="获取私有属性和成员变量-记得引入runtime"><a href="#获取私有属性和成员变量-记得引入runtime" class="headerlink" title="获取私有属性和成员变量 记得引入runtime"></a>获取私有属性和成员变量 记得引入runtime</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//获取私有属性 比如设置UIDatePicker的字体颜色</div><div class="line">- (void)setTextColor</div><div class="line">&#123;</div><div class="line">    //获取所有的属性，去查看有没有对应的属性</div><div class="line">    unsigned int count = 0;</div><div class="line">    objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &amp;count);</div><div class="line">    for(int i = 0;i &lt; count;i ++)</div><div class="line">    &#123;</div><div class="line">        //获得每一个属性</div><div class="line">        objc_property_t property = propertys[i];</div><div class="line">        //获得属性对应的nsstring</div><div class="line">        NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">        //输出打印看对应的属性</div><div class="line">        NSLog(@&quot;propertyname = %@&quot;,propertyName);</div><div class="line">        if ([propertyName isEqualToString:@&quot;textColor&quot;])</div><div class="line">        &#123;</div><div class="line">            [datePicker setValue:[UIColor whiteColor] forKey:propertyName];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//获得成员变量 比如修改UIAlertAction的按钮字体颜色</div><div class="line">    unsigned int count = 0;</div><div class="line">    Ivar *ivars = class_copyIvarList([UIAlertAction class], &amp;count);</div><div class="line">    for(int i =0;i &lt; count;i ++)</div><div class="line">    &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding];</div><div class="line">        NSLog(@&quot;uialertion.ivarName = %@&quot;,ivarName);</div><div class="line">        if ([ivarName isEqualToString:@&quot;_titleTextColor&quot;])</div><div class="line">        &#123;</div><div class="line">            [alertOk setValue:[UIColor blueColor] forKey:@&quot;titleTextColor&quot;];</div><div class="line">            [alertCancel setValue:[UIColor purpleColor] forKey:@&quot;titleTextColor&quot;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="iOS中数字的格式化"><a href="#iOS中数字的格式化" class="headerlink" title="iOS中数字的格式化"></a>iOS中数字的格式化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//通过NSNumberFormatter，同样可以设置NSNumber输出的格式。例如如下代码：</div><div class="line">NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];</div><div class="line">formatter.numberStyle = NSNumberFormatterDecimalStyle;</div><div class="line">NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]];</div><div class="line">NSLog(@&quot;Formatted number string:%@&quot;,string);</div><div class="line">//输出结果为：[1223:403] Formatted number string:123,456,789</div><div class="line"></div><div class="line">//其中NSNumberFormatter类有个属性numberStyle，它是一个枚举型，设置不同的值可以输出不同的数字格式。该枚举包括：</div><div class="line">typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) &#123;</div><div class="line">    NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle,</div><div class="line">    NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle,</div><div class="line">    NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle,</div><div class="line">    NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle,</div><div class="line">    NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle,</div><div class="line">    NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle</div><div class="line">&#125;;</div><div class="line">//各个枚举对应输出数字格式的效果如下：其中第三项和最后一项的输出会根据系统设置的语言区域的不同而不同。</div><div class="line">[1243:403] Formatted number string:123456789</div><div class="line">[1243:403] Formatted number string:123,456,789</div><div class="line">[1243:403] Formatted number string:￥123,456,789.00</div><div class="line">[1243:403] Formatted number string:-539,222,988%</div><div class="line">[1243:403] Formatted number string:1.23456789E8</div><div class="line">[1243:403] Formatted number string:一亿二千三百四十五万六千七百八十九</div></pre></td></tr></table></figure>
<h3 id="获取WebView所有的图片地址"><a href="#获取WebView所有的图片地址" class="headerlink" title="获取WebView所有的图片地址"></a>获取WebView所有的图片地址</h3><p>在网页加载完成时，通过js获取图片和添加点击的识别方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//UIWebView</div><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    //这里是js，主要目的实现对url的获取</div><div class="line">    static  NSString * const jsGetImages =</div><div class="line">    @&quot;function getImages()&#123;\</div><div class="line">    var objs = document.getElementsByTagName(\&quot;img\&quot;);\</div><div class="line">    var imgScr = &apos;&apos;;\</div><div class="line">    for(var i=0;i&lt;objs.length;i++)&#123;\</div><div class="line">    imgScr = imgScr + objs[i].src + &apos;+&apos;;\</div><div class="line">    &#125;;\</div><div class="line">    return imgScr;\</div><div class="line">    &#125;;&quot;;</div><div class="line"></div><div class="line">    [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法</div><div class="line">    NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;];</div><div class="line">    NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@&quot;+&quot;]];</div><div class="line">    //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组</div><div class="line">&#125;</div><div class="line"></div><div class="line">//WKWebView</div><div class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation</div><div class="line">&#123;</div><div class="line">    static  NSString * const jsGetImages =</div><div class="line">    @&quot;function getImages()&#123;\</div><div class="line">    var objs = document.getElementsByTagName(\&quot;img\&quot;);\</div><div class="line">    var imgScr = &apos;&apos;;\</div><div class="line">    for(var i=0;i&lt;objs.length;i++)&#123;\</div><div class="line">    imgScr = imgScr + objs[i].src + &apos;+&apos;;\</div><div class="line">    &#125;;\</div><div class="line">    return imgScr;\</div><div class="line">    &#125;;&quot;;</div><div class="line"></div><div class="line">    [webView evaluateJavaScript:jsGetImages completionHandler:nil];</div><div class="line">    [webView evaluateJavaScript:@&quot;getImages()&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,result);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取到webview的高度"><a href="#获取到webview的高度" class="headerlink" title="获取到webview的高度"></a>获取到webview的高度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.offsetHeight&quot;] floatValue];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要讲一些我在日常开发中用到的一些小的技巧，其实也算不上技巧吧，就是省去一些不必要的代码，或者有的小问题困扰你很久说不行在这里你能找到答案&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-有效编写高质量Objective-C方法-三</title>
    <link href="http://ppsheep.com/2016/11/08/iOS-%E6%9C%89%E6%95%88%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FObjective-C%E6%96%B9%E6%B3%95-%E4%B8%89/"/>
    <id>http://ppsheep.com/2016/11/08/iOS-有效编写高质量Objective-C方法-三/</id>
    <published>2016-11-08T01:49:28.000Z</published>
    <updated>2016-11-09T08:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章，主要是对OC中的一些原理的讲解，可能会有一些枯燥，但是真正当你理解时，会有一种豁然开朗的感觉。这里会涉及到 对象，属性，消息以及运行期的一些介绍，只有我们真正理解了这些原理之后，我们的开发水平才会进一步提升，而不是止步于view的简单编写，view的编写想要写得好，也需要了解这一些原理。</p>
<a id="more"></a>
<h3 id="理解属性-property-这一概念"><a href="#理解属性-property-这一概念" class="headerlink" title="理解属性(property)这一概念"></a>理解属性(property)这一概念</h3><p>在开始讲属性之前，我们先来理解一下几个概念：</p>
<ul>
<li>对象：对象是”基本的构造单元”，在OC中，我们经常使用对象来储存和传递数据</li>
<li>消息传递：在对象之间传递数据并执行任务的过程就叫做消息传递</li>
<li>OC Runtime：当应用程序运行起来，为其提供相关支持的代码叫做”运行环境(Runtime)”，它提供了一些使得对象之间能够传递数据的函数，并且包含了创建类实例需要的所有逻辑</li>
</ul>
<p>上面三个概念，在OC编程中尤其重要，虽然现在可能你没有很深刻的理解，但是随着学习深入，你肯定能够体会到。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>“属性(property)”相信大家都很熟悉，是OC中用来存储对象的数据的实例变量。实例变量一般是通过”存取方法”来访问，”设置方法”来设置实例变量。在之前我们已经讲过，对于实例变量，如果是本身访问，那么读取最好是直接读取(采用下划线方式直接访问)，而设置最好使用属性来设置。具体的，可以参见上一篇(iOS-有效编写高质量Objective-C方法-二)。</p>
<p>对于一些简单的概念性的东西我就不讲了，给出结论就行：</p>
<ul>
<li>不一定要在接口中或者说是声明文件中定义好所有的实例变量，可以在实现文件中定义，以保护与类实现相关的内部信息</li>
<li>属性按照标准的命名方式，在编译器编译期间会自动加上存取方法</li>
</ul>
<p>接下来，我们来说几个关键字：</p>
<p><strong>@synthesize</strong></p>
<p>我们可以在代码中通过这个关键字来指定我们想要的实例变量</p>
<p>例如：在头文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@interface : NSObject</div><div class="line"></div><div class="line">@property(nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个属性，在我们运行期环境下，生成的实例变量为_name，但是我们在.m中并不想使用这个名称，那么我们在实现文件里就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@implementation</div><div class="line"></div><div class="line">@synthesize name =  _myName</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>那么我们在.m实现文件中，都可以直接使用_myName来操作属性name</p>
<p>不过为了书写的规范，和团队之间协作，我还是建议按照规范的OC代码风格来编写代码，团队成员之间，一看就能够看清楚代码</p>
<p><strong>@dynamic</strong></p>
<p>这个关键字 是用来阻止编译器自动合成存取方法，不过这个关键字我都用的很少，上面的关键字同样的，也使用较少。</p>
<p>这个关键字的意思是：阻止编译器合成属性所对应的实例变量，也不要合成实例变量的存取方法  </p>
<p>这里讲一下<strong>实例变量</strong>就是带下划线的_name而<strong>属性</strong>是通过property声明的name</p>
<p>这两个需要区分开来</p>
<h3 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h3><h4 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h4><p>所谓的属性特质，就是指我们在申明属性的时候，property括号中跟的一些关键字<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property(nonatomic, readwrite, copy);</div></pre></td></tr></table></figure></p>
<p>其中的nonatomic，readwrite，copy这些都是属性特质，我们先来说nonatomic</p>
<p>这个关键字叫做属性的原子性，通俗来说，这个关键字主要是来控制属性的<strong>同步锁</strong>。<br>同步锁：不同的线程在读取属性的时候，如果属性是通过atomic来声明的，那么这两个线程总是能够读到属性的有效值<strong>(注意这里是有效的属性值，并没有说是正确的属性值)</strong>，如果属性是通过nonatomic声明的，那么不同的线程读取属性值时，如果有线程正在修改该属性的值，另外的线程正在读取属性值，那么就可能将还未修改完成的属性值读取出来<strong>(这里是尚未修改完成的属性值，有可能读出一个完全没有任何意义的属性值)</strong>。</p>
<p>那么又要来说一说，为什么我们总是看到在编写iOS程序时，属性总是使用nonatomic来声明的呢，这是因为在iOS中使用同步锁的开销太大，这会带来性能问题。在一般情况下，我们并不要求属性必须具有原子性，因为这个原子性并不是说就是”线程安全了”，如果我们需要实现线程安全，那么还需要使用更为底层的同步锁定机制才行，即便是使用atomic来声明，不同的线程还是可能读取到不同的属性值，只是说这个属性值是有效的，有意义的。</p>
<p><strong>所以我们在开发iOS程序时，还是使用nonaomic来声明，但是在macOS程序开发中，却不会遇到这种性能瓶颈，性能配置不一样嘛</strong></p>
<h4 id="readwrite-readonly"><a href="#readwrite-readonly" class="headerlink" title="readwrite/readonly"></a>readwrite/readonly</h4><p>这个属性特质，我们根据字面意思就能看出来，就是声明属性权限的，这个也没什么好说的了。</p>
<h4 id="strong-copy-assign-weak"><a href="#strong-copy-assign-weak" class="headerlink" title="strong/copy/assign/weak"></a>strong/copy/assign/weak</h4><p>这个可能是我们平时用的最多的，也是思考最多的，其实平时我们怎么用，都是知道的，但是为什么这么用呢？</p>
<p>assign：”设置方法”只会针对”纯量类型”进行赋值，例如CGFloat、NSInteger这种</p>
<p>strong：此特质象征了一种拥有关系，在”设置方法”中，这种属性是先保留新值，并且释放旧值，然后将新值设置上去</p>
<p>copy：这种方法和strong类型有点相似，但是它并不是保留新值，而是直接就想新值拷贝，当属性为NSString类型时，我们经常使用这种，那么为什么我们在NSString经常使用拷贝呢，以为我们在设置时，可能会传进来一个NSMutableString对象，这个对象是NSString的子类，是可以赋值给NSString的，如果我们不使用拷贝，那么当外部改变NSMultableString值时，我们的属性值也会直接被修改掉，所以这时，我们就需要拷贝一份不可变的</p>
<p>weak：这个是一种弱引用，为这种方法设置时，既不会保留新值，也不会释放旧值，当属性所指的对象销毁时，属性值也会被清空，在ViewController中定义view时我们经常会使用到weak，但是我们经常还是将view声明为strong，当然这使用起来不会有很大的影响，但是我们的应用在运行过程中，就会产生很多的没用view属性值没有被释放掉，占用无效内存。所以建议大家在使用view时，还是声明为weak</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property(nonatomic,weak) UILable *lable;</div><div class="line"></div><div class="line">//初始化lable时</div><div class="line"></div><div class="line">UILable * lable = [[UILable alloc] init];</div><div class="line">[self.view addSubview: lable];</div><div class="line">self.lable = lable;</div></pre></td></tr></table></figure>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>在我们定义的属性为Boolean值时，我们的习惯是获取方法，一般是”is”<br>开头，那么我们就可以在声明时，这样书写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@property(nonatomic,getter=isOn) Bool on;</div></pre></td></tr></table></figure>
<p>属性的获取方法，就成了isOn;</p>
<p>我们在属性中定义了属性特质，那么我们在书写赋值时，就应该严格按照属性特质赋值，例如，我们有一个初始方法，需要对我们的属性NSString name赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (instancetype)initWithName:(NSString *)name&#123;</div><div class="line">	if(self = [super init])&#123;</div><div class="line">	//此处就应该使用copy来对name赋值</div><div class="line">		_name = [name copy];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="以”类族模式”隐藏实现细节"><a href="#以”类族模式”隐藏实现细节" class="headerlink" title="以”类族模式”隐藏实现细节"></a>以”类族模式”隐藏实现细节</h3><p>类族是一种隐藏抽象基类背后实现细节的很有用的模式。。那么什么叫做类族呢？</p>
<p>举个例子：</p>
<p>在UIKit中有一个名叫UIButton的类，如果想要创建按钮，我们可以调用一个类方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+ (UIButton *)buttonWithType:(UIButtonType)type;</div></pre></td></tr></table></figure>
<p>该方法返回的对象，取决于传入按钮的类型，然而，不管传入的是什么类型，返回的类都是继承自同一个基类：UIButton。 这样，所有继承自UIButton的类组成了一个类族。</p>
<p>在系统框架中，使用到了很多的类族。。</p>
<p>那么为什么要这样做呢？<br>UIButton这个例子，在实现时，使用者无需关心创建出来的按钮是属于哪一个类，也不用考虑按钮的绘制细节，我只需要知道，我怎么创建按钮，如何设置标题。如何增加点击操作等。</p>
<h4 id="创建类族"><a href="#创建类族" class="headerlink" title="创建类族"></a>创建类族</h4><p>我们现在来假设一个处理雇员的类，每个雇员都拥有自己的名字和薪水这两个属性，管理者可以命令器执行日常工作。但是，各种雇员的工作内容却不同，经理在带领雇员做项目的时候，无需关心每个人怎样完成自己的工作，只需要指示其开工即可。</p>
<p>首先我们定义一个基类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef NS_ENUM(NSUinteger, PPSEmployeeType)&#123;</div><div class="line">	PPSEmployeeTypeDeveloper,</div><div class="line">	PPSEmployeeTypeDesigner,</div><div class="line">	PPSEmployeeTypeFinance,</div><div class="line">&#125;</div><div class="line"></div><div class="line">@interface PPSEmployee	:	NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSStirng *name;</div><div class="line">@property (nonamotic, assign) NSUInteger salary;</div><div class="line"></div><div class="line">//创建方法</div><div class="line">+ (PPSEmployee *)employeeWithType:(PPSEmployeeType) type;</div><div class="line"></div><div class="line">//指示开工</div><div class="line">- (void)doADaysWork;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@implementation PPSEmployee</div><div class="line"></div><div class="line">+ (PPSEmployee *)employeeWithType:(PPSEmployeeType) type&#123;</div><div class="line">	switch (type)&#123;</div><div class="line">		case PPSEmployeeTypeDeveloper:</div><div class="line">			return [PPSEmployeeDeveloper new];</div><div class="line">			break;</div><div class="line">		case PPSEmployeeTypeDesigner:</div><div class="line">			return [PPSEmployeeDesigner new];</div><div class="line">			break;</div><div class="line">		case PPSEmployeeTypeFinance:</div><div class="line">			return [PPSEmployeeFinance new];</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doADaysWork&#123;</div><div class="line">	// 子类覆写</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>每个实体子类都是从基类继承而来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@interface PPSEmployeeDeveloper	:	PPSEmployee</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@implementation PPSEmployeeDeveloper</div><div class="line"></div><div class="line">- (void)doADaysWork&#123;</div><div class="line">	[self coding];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们上面实现的方式，是根据雇员的类别，创建雇员类的实例，这其实是一种工厂模式。在Java中，我们知道这种方式一般是通过抽象类来实现，但是OC中没有抽象类这一说，于是开发者通常会在文档中写明使用方法。</p>
<p>在Cocoa中  有很多的类族 大部分的集合类型都是类族 我们在一个对象是否是属于某一个类时，如果我们采用下面的方式，往往得不到我们想要的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id myArr = @[@&quot;a&quot;,@&quot;b&quot;];</div><div class="line">if([myArr class] == [NSArray class])&#123;</div><div class="line">	//这里永远不会跑到 因为 我们知道这里[myArr class]返回的永远是NSArr的一个子类，NSArray只是一个基类</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们要做这个判断的时候，应该都知道是使用isKindOfClass 这个方法，这个方法其实是用来判断是否是同一类族，而不是某个类</p>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><p>有时候我们需要在对象中存放相关的信息，这时候我们能想到的方法就是，创建一个子类，然后我们使用的时候 直接使用子类。 但是并不是所有情况都能够这样做，有时候类的实例可能是由于某种机制所建立的，我们开发者是没有办法创建出自己建立的子类的实例。幸好，我们可以通过OC的一项强大的特性”关联对象”来解决这个问题。</p>
<p>那么什么事关联对象呢？</p>
<p><strong>我们可以给某个对象关联许多其他对象，这些对象通过”键”来区分。存储值的时候，可以通过指明存储策略来维护内存，存储策略就是你存储的是一个NSString啊，那你就该把从存储策略改为copy，类似于这种</strong></p>
<p>下面是对象关联类型：</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的@property属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic,copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic,retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
</tbody>
</table>
<p>管理关联对象的相关方法：</p>
<ul>
<li>void objc _ setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) 使用此方法 以给定的键和策略为某对象设置关联对象</li>
<li>void objc _ getAssociatedObject(id object, void *key) 使用此方法根据给定的键从某对象中获取相关的关联对象的值</li>
<li>void objc_removeAssociatedObject(id object)使用此方法移除指定对象的全部关联对象</li>
</ul>
<p>使用这种方法时，我们可以把某对象想象成一个NSDictionary，把关联到该对象的值理解为字典中的条目，那么这些关联对象，就相当于设置字典里的值和获取字典里的值了</p>
<h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><p>在iOS中,我们如果想要使用UIAlertView 我们需要这样定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;你确定吗？&quot; </div><div class="line">					 message:@&quot;可能没那么确定吧&quot; </div><div class="line">					 delegate:self</div><div class="line">					 cancelButtonTitle:@&quot;取消&quot; </div><div class="line">					 otherButtonTitles:@&quot;继续&quot;, nil];</div><div class="line">[alert show];</div></pre></td></tr></table></figure>
<p>然后我们需要实现UIAlertView的代理，来进行操作的识别判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123;</div><div class="line">    if (buttonIndex == 0) &#123;</div><div class="line">        [self doCancle];</div><div class="line">    &#125;else&#123;</div><div class="line">        [self doContinue];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样写，现在看来是没有什么问题的，但是如果我们需要在当前的一个类中，处理多个警告信息，那么代码将会变得复杂，我们需要在delegate中判断当前的UIAlertView的信息，根据不同的信息实行不同的操作。</p>
<p>如果 我们能在创建UIAlertView的时候 就将这些操作做好，那么，在delegate中我们就不需要判断UIAlertView了。事实上这种方法是可行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;你确定吗？&quot; </div><div class="line">					 message:@&quot;可能没那么确定吧&quot; </div><div class="line">					 delegate:self </div><div class="line">					 cancelButtonTitle:@&quot;取消&quot; </div><div class="line">					 otherButtonTitles:@&quot;继续&quot;, nil];</div><div class="line">void (^block) (NSInteger) = ^(NSInteger buttonIndex)&#123;</div><div class="line">    if (buttonIndex == 0) &#123;</div><div class="line">        NSLog(@&quot;cancle&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;continue&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">//将block设置为UIAlertView的关联对象</div><div class="line">objc_setAssociatedObject(alert, PPSMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">[alert show];</div></pre></td></tr></table></figure>
<p>我们只需要在delegate中拿到block就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void (^block)(NSInteger) =  objc_getAssociatedObject(alertView, PPSMyAlertViewKey);</div><div class="line">block(buttonIndex);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章，主要是对OC中的一些原理的讲解，可能会有一些枯燥，但是真正当你理解时，会有一种豁然开朗的感觉。这里会涉及到 对象，属性，消息以及运行期的一些介绍，只有我们真正理解了这些原理之后，我们的开发水平才会进一步提升，而不是止步于view的简单编写，view的编写想要写得好，也需要了解这一些原理。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 编写高质量代码的方法" scheme="http://ppsheep.com/categories/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="iOS 编写高质量代码" scheme="http://ppsheep.com/tags/iOS-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS 应用之间跳转传输数据以及跳回源程序</title>
    <link href="http://ppsheep.com/2016/11/07/iOS-%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E8%B7%B3%E5%9B%9E%E6%BA%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://ppsheep.com/2016/11/07/iOS-应用之间跳转传输数据以及跳回源程序/</id>
    <published>2016-11-07T03:15:19.000Z</published>
    <updated>2016-11-07T08:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇关于APP之间跳转的文章，期间有同学说能否出一个类似于微信登录或者支付宝支付之类的，跳转到支付宝获得消息再调回源程序，并且带上信息。今天我们就再来聊聊，实现这样一种效果，没看过之前应用跳转的，请移步:<br>    <a href="http://ppsheep.com/2016/10/27/iOS应用之间的跳转解析/">http://ppsheep.com/2016/10/27/iOS应用之间的跳转解析/</a></p>
<a id="more"></a>
<p>之前我们说到APP之间的跳转，其实就是通过一个URL Schemes进行跳转，APP之间的传值，其实也是通过这个URL进行传值。</p>
<p>再有我们想跳回原来程序，那么我们还需要知道源程序的URL Schemes，这样我们才能跳回到源程序，所以在传递参数的时候 我们还需要把源程序的URL Schemes传递过去。</p>
<p>我们需要传递的参数：</p>
<ul>
<li>当前APP的 URL Schemes</li>
<li>我们需要传递的实际参数</li>
</ul>
<p><strong>还有一个重要的事情，因为我们需要从APP2跳回APP1，所以我们还需要设置APP1的URL Schemes，怎么设置，我这里就不写出来了，具体可以看上一篇跳转解析</strong></p>
<p>我们之前知道 打开另一个APP，是打开一个URL<br> APP2://类似于这种，那我们会想到一般我们http有一种方式携带参数 <a href="http://url?name=?&amp;age=?" target="_blank" rel="external">http://url?name=?&amp;age=?</a></p>
<p> 我们APP之间的传递参数方式其实也是这样的方式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//获取APP2的URL Scheme 还需要带上当前App的APP1</div><div class="line">  NSString *URLScheme = @&quot;APP2://APP1&quot;;</div><div class="line">  </div><div class="line">  //我们参数需要穿name age</div><div class="line">  NSString *params = @&quot;name=yq&amp;age=23&quot;;</div><div class="line">  //接下来加上我们需要携带的参数</div><div class="line">  NSString *realURL = [NSString stringWithFormat:@&quot;%@?%@&quot;,URLScheme,params];</div><div class="line">  </div><div class="line">  NSURL *appURL = [NSURL URLWithString:realURL];</div><div class="line">  </div><div class="line">  //判断手机中是否安装了APP2</div><div class="line">  if ([[UIApplication sharedApplication] canOpenURL:appURL]) &#123;</div><div class="line">      //打开APP2ViewController2</div><div class="line">      [[UIApplication sharedApplication] openURL:appURL];</div><div class="line">  &#125;else&#123;</div><div class="line">      NSLog(@&quot;没有安装APP2&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 我们最终的appURL 是： </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">APP2://APP1?name=yq&amp;age=23</div></pre></td></tr></table></figure>
<p> 我们在APP2中处理这个跳转的URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;</div><div class="line">	if ([url.absoluteString containsString:@&quot;APP1&quot;])&#123;</div><div class="line">       NSLog(@&quot;%@&quot;,url);</div><div class="line">       </div><div class="line">       //拿到源程序的</div><div class="line">       NSString * urlschemes = [[url.absoluteString componentsSeparatedByString:@&quot;//&quot;][1] componentsSeparatedByString:@&quot;?&quot;][0];</div><div class="line">       </div><div class="line">       //拿到参数</div><div class="line">       NSRange range = [url.absoluteString rangeOfString:@&quot;?&quot;];</div><div class="line">       NSString *paramStr = [url.absoluteString substringFromIndex:range.location+1];//去除问号</div><div class="line">       NSArray *params = [paramStr componentsSeparatedByString:@&quot;&amp;&quot;];</div><div class="line">       NSLog(@&quot;%@&quot;,params);</div><div class="line">       </div><div class="line">       //跳回源程序</div><div class="line">       dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">           // 延时3s模拟处理后回调指定的 URL Schemes并传递结果</div><div class="line">           </div><div class="line">           if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;APP2://&quot;]]) &#123;</div><div class="line">               </div><div class="line">               NSLog(@&quot;跳转成功&quot;);</div><div class="line">               </div><div class="line">               [[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@&quot;%@://back?name=back&amp;code=200&quot;,urlschemes]]];</div><div class="line">               </div><div class="line">           &#125;else&#123;</div><div class="line">               NSLog(@&quot;跳转失败&quot;);</div><div class="line">               NSLog(@&quot;未安装应用!&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在APP2中  我们拿到了APP1传递的参数 放在了params数组中，同样的 我们在APP1中再处理从APP2跳回来的信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  /**</div><div class="line"> 跳转回来</div><div class="line"> */</div><div class="line">-(BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options&#123;</div><div class="line">    if ([url.absoluteString containsString:@&quot;back&quot;]) &#123;</div><div class="line">        //拿到参数</div><div class="line">        NSRange range = [url.absoluteString rangeOfString:@&quot;?&quot;];</div><div class="line">        NSString *paramStr = [url.absoluteString substringFromIndex:range.location+1];//去除问号</div><div class="line">        NSArray *params = [paramStr componentsSeparatedByString:@&quot;&amp;&quot;];</div><div class="line">        NSLog(@&quot;%@&quot;,params);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们也拿到了APP2跳回来的数据</p>
<p>在iOS10中跳转的API有更新，具体的变化可以看API 我这里就不列出来了</p>
<p>源代码放在：</p>
<p><a href="https://github.com/yangqian111/blog/tree/master/APP-2" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/APP-2</a></p>
<p><a href="https://github.com/yangqian111/blog/tree/master/APP-1" target="_blank" rel="external">https://github.com/yangqian111/blog/tree/master/APP-1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇关于APP之间跳转的文章，期间有同学说能否出一个类似于微信登录或者支付宝支付之类的，跳转到支付宝获得消息再调回源程序，并且带上信息。今天我们就再来聊聊，实现这样一种效果，没看过之前应用跳转的，请移步:&lt;br&gt;    &lt;a href=&quot;http://ppsheep.com/2016/10/27/iOS应用之间的跳转解析/&quot;&gt;http://ppsheep.com/2016/10/27/iOS应用之间的跳转解析/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS进阶" scheme="http://ppsheep.com/categories/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS应用之间的跳转" scheme="http://ppsheep.com/tags/iOS%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%B3%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>iOS基础开发技巧(一)</title>
    <link href="http://ppsheep.com/2016/11/07/iOS%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E4%B8%80/"/>
    <id>http://ppsheep.com/2016/11/07/iOS基础开发技巧-一/</id>
    <published>2016-11-07T01:43:23.000Z</published>
    <updated>2016-11-07T02:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里主要讲一些我在日常开发中用到的一些小的技巧，其实也算不上技巧吧，就是省去一些不必要的代码，或者有的小问题困扰你很久说不行在这里你能找到答案</strong></p>
<a id="more"></a>
<h3 id="在UIView的扩展-快速修改frame"><a href="#在UIView的扩展-快速修改frame" class="headerlink" title="在UIView的扩展 快速修改frame"></a>在UIView的扩展 快速修改frame</h3><p>在iOS修改view的frame，我们经常需要写一大堆代码，来修改frame中的一个小属性，这里有一个方法，就是直接修改frame的每个值</p>
<p>新建一个category UIView+PPSFrame.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface UIView (PPSFrame)</div><div class="line"></div><div class="line">@property (assign, nonatomic) CGFloat    top;//上 相当于frame.origin.y</div><div class="line">@property (assign, nonatomic) CGFloat    bottom;//下 相当于frame.size.height + frame.origin.y</div><div class="line">@property (assign, nonatomic) CGFloat    left;//相当于frame.origin.x</div><div class="line">@property (assign, nonatomic) CGFloat    right;//相当于frame.origin.x+frame.size.width</div><div class="line"></div><div class="line">@property (assign, nonatomic) CGFloat    centerX;</div><div class="line">@property (assign, nonatomic) CGFloat    centerY;</div><div class="line"></div><div class="line">@property (assign, nonatomic) CGFloat    width;</div><div class="line">@property (assign, nonatomic) CGFloat    height;</div><div class="line">@property (assign, nonatomic) CGSize    size;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在.m文件中设置各个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#import &quot;UIView+Layout.h&quot;</div><div class="line"></div><div class="line">@implementation UIView (Layout)</div><div class="line"></div><div class="line">@dynamic top;</div><div class="line">@dynamic bottom;</div><div class="line">@dynamic left;</div><div class="line">@dynamic right;</div><div class="line"></div><div class="line">@dynamic width;</div><div class="line">@dynamic height;</div><div class="line"></div><div class="line">@dynamic size;</div><div class="line"></div><div class="line">- (CGFloat)top</div><div class="line">&#123;</div><div class="line">    return self.frame.origin.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setTop:(CGFloat)top</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.origin.y = top;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)left</div><div class="line">&#123;</div><div class="line">    return self.frame.origin.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setLeft:(CGFloat)left</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.origin.x = left;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)bottom</div><div class="line">&#123;</div><div class="line">    return self.frame.size.height + self.frame.origin.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setBottom:(CGFloat)bottom</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.origin.y = bottom - frame.size.height;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)right</div><div class="line">&#123;</div><div class="line">    return self.frame.size.width + self.frame.origin.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setRight:(CGFloat)right</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.origin.x = right - frame.size.width;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)centerX</div><div class="line">&#123;</div><div class="line">    return self.center.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setCenterX:(CGFloat)centerX</div><div class="line">&#123;</div><div class="line">    CGPoint center = self.center;</div><div class="line">    center.x = centerX;</div><div class="line">    self.center = center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)centerY</div><div class="line">&#123;</div><div class="line">    return self.center.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setCenterY:(CGFloat)centerY</div><div class="line">&#123;</div><div class="line">    CGPoint center = self.center;</div><div class="line">    center.y = centerY;</div><div class="line">    self.center = center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)width</div><div class="line">&#123;</div><div class="line">    return self.frame.size.width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setWidth:(CGFloat)width</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.size.width = width;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)height</div><div class="line">&#123;</div><div class="line">    return self.frame.size.height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setHeight:(CGFloat)height</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.size.height = height;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGSize)size</div><div class="line">&#123;</div><div class="line">    return self.frame.size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSize:(CGSize)size</div><div class="line">&#123;</div><div class="line">    CGRect frame = self.frame;</div><div class="line">    frame.size = size;</div><div class="line">    self.frame = frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="iOS-OC项目的pch文件使用"><a href="#iOS-OC项目的pch文件使用" class="headerlink" title="iOS OC项目的pch文件使用"></a>iOS OC项目的pch文件使用</h3><p>在项目中如果我们需要一些公共的引用，或者一些全局的宏  那我们经常在pch中设置好</p>
<p>具体怎么设置呢 在项目下新建一个pch文件 </p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/Snip20161028_3.png" alt="1"></p>
<p>一般我会取名 项目名-PrefixHeader</p>
<p>在target——&gt;Bulid Setting 中 设置 PrefixHeader<br><img src="http://o8bxt3lx0.bkt.clouddn.com/Snip20161028_6.png" alt="2"></p>
<p>我的项目文件夹结构</p>
<p><img src="http://o8bxt3lx0.bkt.clouddn.com/Snip20161028_5.png" alt=""></p>
<p>$(SRCROOT)这个是指工程的根目录</p>
<p>找到这个pch文件就行  然后启动APP就会编译这个文件了</p>
<p>pch.h中 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//</div><div class="line">//  APP-1-PrefixHeader.pch</div><div class="line">//  APP-1</div><div class="line">//</div><div class="line">//  Created by 羊谦 on 2016/10/28.</div><div class="line">//  Copyright © 2016年 羊谦. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#ifndef APP_1_PrefixHeader_pch</div><div class="line">#define APP_1_PrefixHeader_pch</div><div class="line"></div><div class="line">//在这里直接定义你的宏变量   或者公共引用就行</div><div class="line"></div><div class="line">#endif /* APP_1_PrefixHeader_pch */</div></pre></td></tr></table></figure>
<h3 id="UITableView的Group样式下顶部空白处理"><a href="#UITableView的Group样式下顶部空白处理" class="headerlink" title="UITableView的Group样式下顶部空白处理"></a>UITableView的Group样式下顶部空白处理</h3><p>要给tableHeaderView赋一个高度不为0的view才能处理顶部留白</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//分组列表头部空白处理</div><div class="line">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)];</div><div class="line">self.tableView.tableHeaderView = view;</div></pre></td></tr></table></figure>
<h3 id="获取某个view的Controller"><a href="#获取某个view的Controller" class="headerlink" title="获取某个view的Controller"></a>获取某个view的Controller</h3><p>其实就是根据view的响应链，来查找viewcontroller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (UIViewController *)viewController</div><div class="line">&#123;</div><div class="line">  UIViewController *viewController = nil;  </div><div class="line">  UIResponder *next = self.nextResponder;</div><div class="line">  while (next)</div><div class="line">  &#123;</div><div class="line">    if ([next isKindOfClass:[UIViewController class]])</div><div class="line">    &#123;</div><div class="line">      viewController = (UIViewController *)next;      </div><div class="line">      break;    </div><div class="line">    &#125;    </div><div class="line">    next = next.nextResponder;  </div><div class="line">  &#125; </div><div class="line">    return viewController;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="清空NSUserDefaults的记录"><a href="#清空NSUserDefaults的记录" class="headerlink" title="清空NSUserDefaults的记录"></a>清空NSUserDefaults的记录</h3><p>方法一：是获取当前的app的bundleId NSUserDefaults中有方法根据bundleId清空记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];</div><div class="line">[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];</div></pre></td></tr></table></figure>
<p>方法二：获取所有存储在NSUserDefaults中的数据，因为是按照key-value形式存储，所以循环key就能够删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (void)clearDefaults&#123;</div><div class="line">	NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];</div><div class="line">    NSDictionary * dict = [defs dictionaryRepresentation];</div><div class="line">    for (id key in dict)</div><div class="line">    &#123;</div><div class="line">        [defs removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">    [defs synchronize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="GCD-timer定时器的使用"><a href="#GCD-timer定时器的使用" class="headerlink" title="GCD timer定时器的使用"></a>GCD timer定时器的使用</h3><p>这里的定时器，是一个每秒在主线程跑的一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">__block int countSecond = 30; //倒计时</div><div class="line">   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</div><div class="line">   dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行</div><div class="line">   dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">       if (countSecond==0) &#123; //倒计时完毕</div><div class="line">           //@&quot;倒计时结束，关闭&quot;</div><div class="line">           dispatch_source_cancel(timer);</div><div class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               //倒计时完毕需要执行的操作</div><div class="line">           &#125;);</div><div class="line">       &#125;else&#123; //倒计时</div><div class="line">           NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%ld&quot;,(long)countSecond]);</div><div class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               //每秒需要执行的操作</div><div class="line">               //在这里更新UI之类的</div><div class="line">           &#125;);</div><div class="line"></div><div class="line">           countSecond--;</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   dispatch_resume(timer);</div></pre></td></tr></table></figure>
<h3 id="计算文件大小"><a href="#计算文件大小" class="headerlink" title="计算文件大小"></a>计算文件大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (long long)fileSizeAtPath:(NSString *)path</div><div class="line">&#123;</div><div class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</div><div class="line"></div><div class="line">    if ([fileManager fileExistsAtPath:path])</div><div class="line">    &#123;</div><div class="line">        long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize;</div><div class="line">        return size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="计算文件夹大小"><a href="#计算文件夹大小" class="headerlink" title="计算文件夹大小"></a>计算文件夹大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (long long)folderSizeAtPath:(NSString *)path</div><div class="line">&#123;</div><div class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</div><div class="line"></div><div class="line">    long long folderSize = 0;</div><div class="line"></div><div class="line">    if ([fileManager fileExistsAtPath:path])</div><div class="line">    &#123;</div><div class="line">        NSArray *childerFiles = [fileManager subpathsAtPath:path];</div><div class="line">        for (NSString *fileName in childerFiles)</div><div class="line">        &#123;</div><div class="line">            NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName];</div><div class="line">            if ([fileManager fileExistsAtPath:fileAbsolutePath])</div><div class="line">            &#123;</div><div class="line">                long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize;</div><div class="line">                folderSize += size;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return folderSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">floor(x)函数，是一个向下取整函数，是一个C函数 即是去不大于x的一个最大整数</div><div class="line">floor(3.12) = 3 floor(4.9) = 4</div><div class="line"></div><div class="line">与floor(x)函数对应的是ceil函数</div><div class="line">这个即是向上取整了</div><div class="line">ceil(3.9) = 4  ceil(1.2) = 2</div></pre></td></tr></table></figure>
<h3 id="给任何一个view设置一张图片"><a href="#给任何一个view设置一张图片" class="headerlink" title="给任何一个view设置一张图片"></a>给任何一个view设置一张图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UIImage *image = [UIImage imageNamed:@&quot;image&quot;];</div><div class="line">self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage);</div><div class="line">self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);</div></pre></td></tr></table></figure>
<p>未完待续。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这里主要讲一些我在日常开发中用到的一些小的技巧，其实也算不上技巧吧，就是省去一些不必要的代码，或者有的小问题困扰你很久说不行在这里你能找到答案&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS基础" scheme="http://ppsheep.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOSTips" scheme="http://ppsheep.com/tags/iOSTips/"/>
    
  </entry>
  
</feed>
